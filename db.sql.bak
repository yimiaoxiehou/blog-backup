-- MySQL dump 10.13  Distrib 5.7.22, for Linux (x86_64)
--
-- Host: localhost    Database: sql118_126_105_
-- ------------------------------------------------------
-- Server version	5.7.22-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `typecho_baidusubmit`
--

DROP TABLE IF EXISTS `typecho_baidusubmit`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_baidusubmit` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `subject` varchar(255) DEFAULT NULL COMMENT '主体',
  `action` varchar(255) DEFAULT NULL COMMENT '动作',
  `object` varchar(255) DEFAULT NULL COMMENT '对象',
  `result` varchar(255) DEFAULT NULL COMMENT '结果',
  `more` text COMMENT '更多信息',
  `time` bigint(20) DEFAULT NULL COMMENT '时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_baidusubmit`
--

LOCK TABLES `typecho_baidusubmit` WRITE;
/*!40000 ALTER TABLE `typecho_baidusubmit` DISABLE KEYS */;
/*!40000 ALTER TABLE `typecho_baidusubmit` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_comments`
--

DROP TABLE IF EXISTS `typecho_comments`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_comments` (
  `coid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `cid` int(10) unsigned DEFAULT '0',
  `created` int(10) unsigned DEFAULT '0',
  `author` varchar(200) DEFAULT NULL,
  `authorId` int(10) unsigned DEFAULT '0',
  `ownerId` int(10) unsigned DEFAULT '0',
  `mail` varchar(200) DEFAULT NULL,
  `url` varchar(255) DEFAULT NULL,
  `ip` varchar(64) DEFAULT NULL,
  `agent` varchar(511) DEFAULT NULL,
  `text` text,
  `type` varchar(16) DEFAULT 'comment',
  `status` varchar(16) DEFAULT 'approved',
  `parent` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`coid`),
  KEY `cid` (`cid`),
  KEY `created` (`created`)
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_comments`
--

LOCK TABLES `typecho_comments` WRITE;
/*!40000 ALTER TABLE `typecho_comments` DISABLE KEYS */;
INSERT INTO `typecho_comments` VALUES (1,1,1545183095,'Typecho',0,1,NULL,'http://typecho.org','127.0.0.1','Typecho 1.1/17.10.30','欢迎加入 Typecho 大家族','comment','approved',0);
/*!40000 ALTER TABLE `typecho_comments` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_contents`
--

DROP TABLE IF EXISTS `typecho_contents`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_contents` (
  `cid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(200) DEFAULT NULL,
  `slug` varchar(200) DEFAULT NULL,
  `created` int(10) unsigned DEFAULT '0',
  `modified` int(10) unsigned DEFAULT '0',
  `text` longtext,
  `order` int(10) unsigned DEFAULT '0',
  `authorId` int(10) unsigned DEFAULT '0',
  `template` varchar(32) DEFAULT NULL,
  `type` varchar(16) DEFAULT 'post',
  `status` varchar(16) DEFAULT 'publish',
  `password` varchar(32) DEFAULT NULL,
  `commentsNum` int(10) unsigned DEFAULT '0',
  `allowComment` char(1) DEFAULT '0',
  `allowPing` char(1) DEFAULT '0',
  `allowFeed` char(1) DEFAULT '0',
  `parent` int(10) unsigned DEFAULT '0',
  `views` int(10) DEFAULT '0',
  PRIMARY KEY (`cid`),
  UNIQUE KEY `slug` (`slug`),
  KEY `created` (`created`)
) ENGINE=MyISAM AUTO_INCREMENT=39 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_contents`
--

LOCK TABLES `typecho_contents` WRITE;
/*!40000 ALTER TABLE `typecho_contents` DISABLE KEYS */;
INSERT INTO `typecho_contents` VALUES (1,'欢迎使用 Typecho','start',1545183095,1545183095,'<!--markdown-->如果您看到这篇文章,表示您的 blog 已经安装成功.',0,1,NULL,'post','publish',NULL,1,'1','1','1',0,0),(2,'关于','start-page',1545183095,1545183095,'<!--markdown-->本页面由 Typecho 创建, 这只是个测试页面.',0,1,NULL,'page','publish',NULL,0,'1','1','1',0,0),(3,'java中的==,equals,hashCode','3',1545620460,1550538409,'<!--markdown-->1. 概述\r\n\r\n| 概念 | 含义 |\r\n| :------------: | :------------: |\r\n|  ==  |  计算操作数的值之间的关系  |\r\n|  equals  |  比较两个对象的content  |\r\n|  hashCode  |  获取hash值，用于确定对象在hash表中的位置  |\r\n\r\n2. ==\r\n - 基本数据类型\r\n 对于基本数据类型 （byte,short,int,long,double,float,boolean,char） 来说，== 直接比较他们保存的值。\r\n\r\n - 引用数据类型\r\n 对于引用数据类型，== 直接比较对象的地址，如果相同即引用指向的对象是同一个。\r\n\r\n3. equals()\r\n > 来源于 Object 类，所有继承于 Object 的类都有该方法。\r\n\r\n Object 类中，equals() 直接返回 `this == obj` 即直接比较内存地址。\r\n在 JDK 其他类中，equals() 分如下三个实现步骤：\r\n - 比较内存地址是否相同 `this == obj`\r\n - 判断对象类型是否一致 `obj instanceof this.type`\r\n - 比较对象内容是否一致 `this.value == obj.value`\r\n\r\n4. hashCode()\r\n\r\n > 源于 Object 类的 navite 方法（由 c 语言实现），所有继承 Obejct 类的类都有该方法。\r\n\r\n - 作用\r\n  将对象的内存地址转换成一个小范围内的整数。\r\n  `a.equals(b)=true -> a.hashCode() == b.hashCode() = true `\r\n  `a.equals(b)!=true !-> a.hashCode() == b.hashCode()`\r\n\r\n5. 小结\r\n - hashCode是系统用来快速检索对象而使用\r\n - equals方法本意是用来判断引用的对象是否一致\r\n - 重写equals方法和hashcode方法时，equals方法中用到的成员变量也必定会在hashcode方法中用到,只不过前者作为比较项，后者作为生成摘要的信息项，本质上所用到的数据是一样的，从而保证二者的一致性\r\n> 参考：https://blog.csdn.net/justloveyou_/article/details/52464440 \r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,0),(4,'mysql 组成','4',1545620760,1550538430,'<!--markdown-->### MySQL 的组成\r\n![mysql 逻辑架构图](http://wp.yimiao.tk/zb_users/upload/2018/12/201812172101154340195.png)\r\n*MySQL 的逻辑架构图*\r\n\r\n- MySQL 大概分为两部分 \r\n- Server 层\r\n	包括 **连接器、查询缓存、分析器、优化器、执行器** 等，涵盖 MySQL 大多数核心服务功能，以及所有内置函数，所有跨存储引擎的功能（如存储过程，触发器，视图）\r\n- 存储引擎层\r\n	负责数据存储和提取，插件式架构，支持 **InnoDB、MyISAM、Memory** 等\r\n\r\n> InnoDB 是最常见的存储引擎，MySQL 5.5.5 起默认\r\n\r\n### 查询语句执行流程\r\n\r\n- #### 连接器\r\n\r\n连接器负责跟客户端连接、获取权限、维持和管理连接。\r\n连接命令一般如下：\r\n` mysql -h $ip -P $port -u $user -p`\r\n\r\n> mysql 连接时，用户密码被修改仍旧保持连接。\r\n\r\n- #### 查询缓存\r\n\r\nMySQL 执行过的查询语句会以`  key —— value ` ~~查询语句 -> 查询结果~~ 的方式缓存在内存中。所以执行新语句时，会先向缓存查询，存在直接返回结果，不存在则进入下一步。\r\n\r\n从缓存查询理论上确实能提高速度，但是实际上不行。\r\nMySQL 缓存的命中率很低，只要一个表更新了，整个表的缓存结果也就被清空了，也就是说你之前废了老大劲做的存储是无用功。\r\n所以不建议使用查询结果缓存，除非存在静态表（如系统配置），几万年不更新的那种。\r\n\r\n`query_cache_type` 设置为 `DEMAND` 即可默认不使用查询缓存\r\n使用 `SQL_CACHE` 可以显示指定使用缓存\r\n如：` select SQL_CACHE * from T where ID=10;`\r\n\r\n- #### 分析器\r\n没有命中缓存，MySQL 就必须进行真正的查询了。\r\n\r\n首先，需要对 SQL 进行分析。\r\n**词法分析 -> 语法分析**\r\n分析器先分词，然后识别关键字和参数，接着进行语法分析（如果语法有误就会报错）。\r\n\r\n- #### 优化器\r\n优化器 : 在表有多个索引时，决定使用哪个索引；或者在多表连接时决定连接顺序。\r\n\r\n- #### 执行器\r\n调用存储引擎执行查询语句\r\n```flow\r\nst=>start: 开始\r\ne=>end: 返回查询结果\r\ner=>end: 错误\r\ncond=>condition: 是否有权限\r\nop=>operation: 调用查询引擎接口\r\ncond2=>condition: 查询条件结束 \r\nst->cond\r\ncond(yes,right)->op->cond2\r\ncond(no)->er\r\ncond2(yes,right)->op\r\ncond2(no)->e\r\n```\r\n\r\n- #### 课后问题：\r\n语句 `select k from T where ID=10;` column k 不存在时，何时报错？\r\n我认为是执行器阶段报错。\r\n\r\n\r\n\r\n',0,1,NULL,'post_draft','publish',NULL,0,'1','1','1',0,0),(5,'pcre2-10.21.zip','pcre2-10-21-zip',1550195431,1550195431,'a:5:{s:4:\"name\";s:15:\"pcre2-10.21.zip\";s:4:\"path\";s:35:\"/usr/uploads/2019/02/2662671198.zip\";s:4:\"size\";i:2169128;s:4:\"type\";s:3:\"zip\";s:4:\"mime\";s:15:\"application/zip\";}',1,1,NULL,'attachment','publish',NULL,0,'1','0','1',6,0),(6,'未命名文档','6',1550195460,1550802269,'<!--markdown-->[epel-release-latest-7.noarch.rpm][1][vpnsetup_centos.zip][2][pcre2-10.21.zip][3]\r\n\r\n\r\n  [1]: http://118.126.105.229/usr/uploads/2019/02/2136510359.rpm\r\n  [2]: http://118.126.105.229/usr/uploads/2019/02/3768048974.zip\r\n  [3]: http://118.126.105.229/usr/uploads/2019/02/2662671198.zip',0,1,NULL,'post_draft','publish',NULL,0,'1','1','1',0,0),(7,'二维数组中的查找','7',1550213940,1550651483,'<!--markdown-->题目描述\r\n在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\r\n\r\n解题思路\r\n利用二维数组由上到下，由左到右递增的规律，\r\n那么选取右上角或者左下角的元素a[row][col]与target进行比较，\r\n当target小于元素a[row][col]时，那么target必定在元素a所在行的左边,\r\n即col--；\r\n当target大于元素a[row][col]时，那么target必定在元素a所在列的下边,\r\n即row++；\r\n\r\n    public class Solution {\r\n        public boolean Find(int target, int [][] array) {\r\n            int length=array[0].length-1;\r\n            if(length<0){\r\n                return false;\r\n            }\r\n            int i=length;\r\n            int j=0;\r\n            while(i>=0&&j<=array.length-1){\r\n                if(target==array[j][i])\r\n                    return true;\r\n                else if(target > array[j][i])\r\n                    j++;\r\n                else\r\n                    i--;\r\n            }\r\n            \r\n            return false;\r\n        }\r\n    }',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,0),(8,'替换空格','8',1550214600,1550538393,'<!--markdown-->题目描述\r\n请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。\r\n\r\n    public class Solution {\r\n        public String replaceSpace(StringBuffer str) {\r\n            if(str == null)\r\n                return null;\r\n            for(int i=0;i<str.length();i++){\r\n                if(str.charAt(i)==\' \'){\r\n                    str.deleteCharAt(i);\r\n                    str.insert(i,\"%20\");\r\n                }\r\n            }\r\n            return str.toString();\r\n        }\r\n    }',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,0),(10,'从尾到头打印链表','10',1550216520,1550538386,'<!--markdown-->题目描述\r\n输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。\r\n\r\n解题思路：\r\n两种方法：\r\n\r\n1.递归思路\r\n    public class Solution {\r\n         \r\n        public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {\r\n            ArrayList<Integer> ret = new ArrayList<Integer>();\r\n            if(listNode == null){\r\n                return ret;\r\n            }\r\n            listNode = reverse(listNode);\r\n            while(listNode != null){\r\n                ret.add(listNode.val);\r\n                listNode = listNode.next;\r\n            }\r\n            return ret;\r\n        }\r\n         \r\n        public ListNode reverse(ListNode listNode){\r\n            ListNode head = listNode;\r\n            ListNode end = listNode;\r\n            ListNode temp;\r\n             \r\n            while(end.next!=null){\r\n                temp = head;\r\n                head = end.next;\r\n                end.next = end.next.next;\r\n                head.next = temp;\r\n                 \r\n            }\r\n             \r\n            return head;\r\n        }\r\n    }\r\n\r\n2.反转链表，然后遍历\r\n    public class Solution {\r\n         \r\n        public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {\r\n            ArrayList<Integer> ret = new ArrayList<Integer>();\r\n            if(listNode == null){\r\n                return ret;\r\n            }\r\n            listNode = reverse(listNode);\r\n            while(listNode != null){\r\n                ret.add(listNode.val);\r\n                listNode = listNode.next;\r\n            }\r\n            return ret;\r\n        }\r\n         \r\n        public ListNode reverse(ListNode listNode){\r\n            ListNode head = listNode;\r\n            ListNode end = listNode;\r\n             \r\n            while(end.next!=null){\r\n                head = end.next;\r\n                end.next = head.next;\r\n                head.next = end;\r\n                 \r\n            }\r\n             \r\n            return head;\r\n        }\r\n    }\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,0),(11,'mysql-connector-java-5.1.40-bin.jar','mysql-connector-java-5-1-40-bin-jar',1550453563,1550453563,'a:5:{s:4:\"name\";s:35:\"mysql-connector-java-5.1.40-bin.jar\";s:4:\"path\";s:35:\"/usr/uploads/2019/02/3267633349.jar\";s:4:\"size\";i:990927;s:4:\"type\";s:3:\"jar\";s:4:\"mime\";s:26:\"application/x-java-archive\";}',1,1,NULL,'attachment','publish',NULL,0,'1','0','1',14,0),(12,'quickstart.gz','quickstart-gz',1550454337,1550454337,'a:5:{s:4:\"name\";s:13:\"quickstart.gz\";s:4:\"path\";s:34:\"/usr/uploads/2019/02/1723271270.gz\";s:4:\"size\";i:9676;s:4:\"type\";s:2:\"gz\";s:4:\"mime\";s:18:\"application/x-gtar\";}',2,1,NULL,'attachment','publish',NULL,0,'1','0','1',14,0),(14,'Java 面试题全集（上）','14',1550481000,1550557080,'<!--markdown-->> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 https://blog.csdn.net/jackfrued/article/details/44921941 版权声明：本文为博主原创文章，请在转载时说明出处。 https://blog.csdn.net/jackfrued/article/details/44921941\r\n\r\n2013 年年底的时候，我看到了网上流传的一个叫做《Java 面试题大全》的东西，认真的阅读了以后发现里面的很多题目是重复且没有价值的题目，还有不少的参考答案也是错误的，于是我花了半个月时间对这个所谓的《Java 面试大全》进行了全面的修订并重新发布在我的 CSDN 博客。在修订的过程中，参照了当时 JDK 最新版本（Java 7）给出了题目的答案和相关代码，去掉了 EJB 2.x、JSF 等无用内容或过时内容，补充了数据结构和算法、大型网站技术架构、设计模式、UML、Spring MVC 等内容并对很多知识点进行了深入的剖析，例如 hashCode 方法的设计、垃圾收集、并发编程、数据库事务等。当时我甚至希望把面试中经常出现的操作系统、数据库、软件测试等内容也补充进去，但是由于各种原因，最终只整理出了 150 道面试题。让我欣慰的是，这 150 道题还是帮助到了很多人，而且在我 CSDN 博客上的总访问量超过了 5 万次，最终还被很多网站和个人以原创的方式转载了。最近一年内，用百度搜索 \"Java 面试\" 我写的这些东西基本上都排在搜索结果的前 5 名，这让我觉得 \"亚历山大\"，因为我写的这些东西一旦不准确就可能误导很多人。2014 年的时候我又整理了 30 道题，希望把之前遗漏的面试题和知识点补充上去，但是仍然感觉挂一漏万，而且 Java 8 问世后很多新的东西又需要去总结和整理。为此，我不止一次的修改了之前的 180 题，修改到自己已经感觉有些疲惫或者厌烦了。2014 年至今，自己带的学生又有很多走上了 Java 程序员、Java 工程师的工作岗位，他们的面试经验也还没来得及跟大家分享，冥冥之中似乎有一股力量在刺激我要重新写一篇《Java 面试题全集》，于是这篇文章就诞生了。请不要责备我把那些出现过的内容又写了一次，因为每次写东西就算是重复的内容，我也需要对编程语言和相关技术进行重新思考，不仅字斟句酌更是力求至臻完美，所以请相信我分享的一定是更新的、更好的、更有益的东西，这些内容也诉说着一个职业程序员和培训师的思想、精神和情感。\r\n\r\n**1、面向对象的特征有哪些方面？**\r\n答：面向对象的特征主要有以下几个方面：\r\n- 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。\r\n- 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java 与模式》或《设计模式精解》中关于桥梁模式的部分）。\r\n- 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。\r\n- 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当 A 系统访问 B 系统提供的服务时，B 系统有多种提供服务的方式，但一切对 A 系统来说都是透明的（就像电动剃须刀是 A 系统，它的供电系统是 B 系统，B 系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A 系统只会通过 B 类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。\r\n\r\n**2、访问修饰符 public,private,protected, 以及不写（默认）时的区别？**\r\n答：\r\n\r\n| 修饰符 | 当前类 | 同 包 | 子 类 | 其他包 |\r\n| :--: | :--: | :--: | :--: | :--: |\r\n| public | √ | √ | √ | √ |\r\n| protected | √ | √ | √ | × |\r\n| default | √ | √ | × | × |\r\n| private | √ | × | × | × |\r\n\r\n\r\n类的成员不写访问修饰时默认为 default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java 中，外部类的修饰符只能是 public 或默认，类的成员（包括内部类）的修饰符可以是以上四种。\r\n\r\n**3、String 是最基本的数据类型吗？**\r\n答：不是。Java 中的基本数据类型只有 8 个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference type），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。\r\n\r\n**4、float f=3.4; 是否正确？**\r\n答: 不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换 float f =(float)3.4; 或者写成 float f =3.4F;。\r\n\r\n**5、short s1 = 1; s1 = s1 + 1; 有错吗? short s1 = 1; s1 += 1; 有错吗？**\r\n答：对于 short s1 = 1; s1 = s1 + 1; 由于 1 是 int 类型，因此 s1+1 运算结果也是 int 型，需要强制转换类型才能赋值给 short 型。而 short s1 = 1; s1 += 1; 可以正确编译，因为 s1+= 1; 相当于 s1 = (short)(s1 + 1); 其中有隐含的强制类型转换。\r\n\r\n**6、Java 有没有 goto？**\r\n答：goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。（根据 James Gosling（Java 之父）编写的《The Java Programming Language》一书的附录中给出了一个 Java 关键字列表，其中有 goto 和 const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉 C 语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字）\r\n\r\n**7、int 和 Integer 有什么区别？**\r\n答：Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱 / 拆箱机制，使得二者可以相互转换。\r\nJava 为每个原始类型提供了包装类型：\r\n- 原始类型: boolean，char，byte，short，int，long，float，double\r\n- 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double\r\n\r\n```\r\nclass AutoUnboxingTest {\r\n\r\n    public static void main(String[] args) {\r\n        Integer a = new Integer(3);\r\n        Integer b = 3;                  // 将3自动装箱成Integer类型\r\n        int c = 3;\r\n        System.out.println(a == b);     // false 两个引用没有引用同一对象\r\n        System.out.println(a == c);     // true a自动拆箱成int类型再和c比较\r\n    }\r\n}\r\n```\r\n\r\n最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示：\r\n\r\n```\r\npublic class Test03 {\r\n\r\n    public static void main(String[] args) {\r\n        Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;\r\n\r\n        System.out.println(f1 == f2);\r\n        System.out.println(f3 == f4);\r\n    }\r\n}\r\n```\r\n\r\n如果不明就里很容易认为两个输出要么都是 true 要么都是 false。首先需要注意的是 f1、f2、f3、f4 四个变量都是 Integer 对象引用，所以下面的 == 运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个 Integer 对象赋一个 int 值的时候，会调用 Integer 类的静态方法 valueOf，如果看看 valueOf 的源代码就知道发生了什么。\r\n\r\n```\r\n    public static Integer valueOf(int i) {\r\n        if (i >= IntegerCache.low && i <= IntegerCache.high)\r\n            return IntegerCache.cache[i + (-IntegerCache.low)];\r\n        return new Integer(i);\r\n    }\r\n```\r\n\r\nIntegerCache 是 Integer 的内部类，其代码如下所示：\r\n\r\n```\r\n/**\r\n     * Cache to support the object identity semantics of autoboxing for values between\r\n     * -128 and 127 (inclusive) as required by JLS.\r\n     *\r\n     * The cache is initialized on first usage.  The size of the cache\r\n     * may be controlled by the {@code -XX:AutoBoxCacheMax=<size>} option.\r\n     * During VM initialization, java.lang.Integer.IntegerCache.high property\r\n     * may be set and saved in the private system properties in the\r\n     * sun.misc.VM class.\r\n     */\r\n\r\n    private static class IntegerCache {\r\n        static final int low = -128;\r\n        static final int high;\r\n        static final Integer cache[];\r\n\r\n        static {\r\n            // high value may be configured by property\r\n            int h = 127;\r\n            String integerCacheHighPropValue =\r\n                sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\r\n            if (integerCacheHighPropValue != null) {\r\n                try {\r\n                    int i = parseInt(integerCacheHighPropValue);\r\n                    i = Math.max(i, 127);\r\n                    // Maximum array size is Integer.MAX_VALUE\r\n                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\r\n                } catch( NumberFormatException nfe) {\r\n                    // If the property cannot be parsed into an int, ignore it.\r\n                }\r\n            }\r\n            high = h;\r\n\r\n            cache = new Integer[(high - low) + 1];\r\n            int j = low;\r\n            for(int k = 0; k < cache.length; k++)\r\n                cache[k] = new Integer(j++);\r\n\r\n            // range [-128, 127] must be interned (JLS7 5.1.7)\r\n            assert IntegerCache.high >= 127;\r\n        }\r\n\r\n        private IntegerCache() {}\r\n    }\r\n```\r\n\r\n简单的说，如果整型字面量的值在 - 128 到 127 之间，那么不会 new 新的 Integer 对象，而是直接引用常量池中的 Integer 对象，所以上面的面试题中 f1==f2 的结果是 true，而 f3==f4 的结果是 false。\r\n\r\n> **提醒：**越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。\r\n\r\n**8、& 和 && 的区别？**\r\n答：& 运算符有两种用法：(1) 按位与；(2) 逻辑与。&& 运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是 true。&& 之所以称为短路运算是因为，如果 && 左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用 && 而不是 &，例如在验证用户登录时判定用户名不是 null 而且不是空字符串，应当写为：username != null &&!username.equals(\"\")，二者的顺序不能交换，更不能用 & 运算符，因为第一个条件如果不成立，根本不能进行字符串的 equals 比较，否则会产生 NullPointerException 异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。\r\n\r\n> **补充：**如果你熟悉 JavaScript，那你可能更能感受到短路运算的强大，想成为 JavaScript 的高手就先从玩转短路运算开始吧。\r\n\r\n**9、解释内存中的栈 (stack)、堆(heap) 和方法区 (method area) 的用法。**\r\n答：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用 JVM 中的栈空间；而通过 new 关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为 Eden、Survivor（又可分为 From Survivor 和 To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被 JVM 加载的类信息、常量、静态变量、JIT 编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的 100、\"hello\" 和常量都是放在常量池中，常量池是方法区的一部分，。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过 JVM 的启动参数来进行调整，栈空间用光了会引发 StackOverflowError，而堆和常量池空间不足则会引发 OutOfMemoryError。\r\n\r\n```\r\nString str = new String(\"hello\");\r\n```\r\n\r\n上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而 \"hello\" 这个字面量是放在方法区的。\r\n\r\n> **补充 1：**较新版本的 Java（从 Java 6 的某个更新开始）中，由于 JIT 编译器的发展和 \"逃逸分析\" 技术的逐渐成熟，栈上分配、标量替换等优化技术使得对象一定分配在堆上这件事情已经变得不那么绝对了。\r\n> \r\n> **补充 2**：运行时常量池相当于 Class 文件常量池具有动态性，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 intern() 方法就是这样的。\r\n\r\n看看下面代码的执行结果是什么并且比较一下 Java 7 以前和以后的运行结果是否一致。\r\n\r\n```\r\nString s1 = new StringBuilder(\"go\")\r\n    .append(\"od\").toString();\r\nSystem.out.println(s1.intern() == s1);\r\nString s2 = new StringBuilder(\"ja\")\r\n    .append(\"va\").toString();\r\nSystem.out.println(s2.intern() == s2);\r\n```\r\n\r\n**10、Math.round(11.5) 等于多少？Math.round(-11.5) 等于多少？**\r\n答：Math.round(11.5) 的返回值是 12，Math.round(-11.5) 的返回值是 - 11。四舍五入的原理是在参数上加 0.5 然后进行下取整。\r\n\r\n**11、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？**\r\n答：在 Java 5 以前，switch(expr) 中，expr 只能是 byte、short、char、int。从 Java 5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。\r\n\r\n**12、用最有效率的方法计算 2 乘以 8？**\r\n答： 2 << 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。\r\n\r\n> **补充：**我们为编写的类重写 hashCode 方法时，可能会看到如下所示的代码，其实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为什么这个数是个素数，为什么通常选择 31 这个数？前两个问题的答案你可以自己百度一下，选择 31 是因为可以用移位和减法运算来代替乘法，从而得到更好的性能。说到这里你可能已经想到了：31 * num 等价于 (num << 5) - num，左移 5 位相当于乘以 2 的 5 次方再减去自身就相当于乘以 31，现在的 VM 都能自动完成这个优化。\r\n\r\n```\r\npublic class PhoneNumber {\r\n    private int areaCode;\r\n    private String prefix;\r\n    private String lineNumber;\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        final int prime = 31;\r\n        int result = 1;\r\n        result = prime * result + areaCode;\r\n        result = prime * result\r\n                + ((lineNumber == null) ? 0 : lineNumber.hashCode());\r\n        result = prime * result + ((prefix == null) ? 0 : prefix.hashCode());\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (this == obj)\r\n            return true;\r\n        if (obj == null)\r\n            return false;\r\n        if (getClass() != obj.getClass())\r\n            return false;\r\n        PhoneNumber other = (PhoneNumber) obj;\r\n        if (areaCode != other.areaCode)\r\n            return false;\r\n        if (lineNumber == null) {\r\n            if (other.lineNumber != null)\r\n                return false;\r\n        } else if (!lineNumber.equals(other.lineNumber))\r\n            return false;\r\n        if (prefix == null) {\r\n            if (other.prefix != null)\r\n                return false;\r\n        } else if (!prefix.equals(other.prefix))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n}\r\n```\r\n\r\n**13、数组有没有 length() 方法？String 有没有 length() 方法？**\r\n答：数组没有 length() 方法，有 length 的属性。String 有 length() 方法。JavaScript 中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。\r\n\r\n**14、在 Java 中，如何跳出当前的多重嵌套循环？**\r\n答：在最外层循环前加一个标记如 A，然后用 break A; 可以跳出多重循环。（Java 中支持带标签的 break 和 continue 语句，作用有点类似于 C 和 C++ 中的 goto 语句，但是就像要避免使用 goto 一样，应该避免使用带标签的 break 和 continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好）\r\n\r\n**15、构造器（constructor）是否可被重写（override）？**\r\n答：构造器不能被继承，因此不能被重写，但可以被重载。\r\n\r\n**16、两个对象值相同 (x.equals(y) == true)，但却可有不同的 hash code，这句话对不对？**\r\n答：不对，如果两个对象 x 和 y 满足 x.equals(y) == true，它们的哈希码（hash code）应当相同。Java 对于 eqauls 方法和 hashCode 方法是这样规定的：(1) 如果两个对象相同（equals 方法返回 true），那么它们的 hashCode 值一定要相同；(2) 如果两个对象的 hashCode 相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在 Set 集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。\r\n\r\n> **补充：**关于 equals 和 hashCode 方法，很多 Java 程序都知道，但很多人也就是仅仅知道而已，在 Joshua Bloch 的大作《Effective Java》（很多软件公司，《Effective Java》、《Java 编程思想》以及《重构：改善既有代码质量》是 Java 程序员必看书籍，如果你还没看过，那就赶紧去[亚马逊](http://z.cn)买一本吧）中是这样介绍 equals 方法的：首先 equals 方法必须满足自反性（x.equals(x) 必须返回 true）、对称性（x.equals(y) 返回 true 时，y.equals(x) 也必须返回 true）、传递性（x.equals(y) 和 y.equals(z) 都返回 true 时，x.equals(z) 也必须返回 true）和一致性（当 x 和 y 引用的对象信息没有被修改时，多次调用 x.equals(y) 应该得到同样的返回值），而且对于任何非 null 值的引用 x，x.equals(null) 必须返回 false。实现高质量的 equals 方法的诀窍包括：1\\. 使用 == 操作符检查 \"参数是否为这个对象的引用\"；2\\. 使用 instanceof 操作符检查 \"参数是否为正确的类型\"；3\\. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4\\. 编写完 equals 方法后，问自己它是否满足对称性、传递性、一致性；5\\. 重写 equals 时总是要重写 hashCode；6\\. 不要将 equals 方法参数中的 Object 对象替换为其他的类型，在重写时不要忘掉 @Override 注解。\r\n\r\n**17、是否可以继承 String 类？**\r\n答：String 类是 final 类，不可以被继承。\r\n\r\n> **补充：**继承 String 本身就是一个错误的行为，对 String 类型最好的重用方式是关联关系（Has-A）和依赖关系（Use-A）而不是继承关系（Is-A）。\r\n\r\n**18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？**\r\n答：是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。C++ 和 C# 中可以通过传引用或传输出参数来改变传入的参数的值。在 C# 中可以编写如下所示的代码，但是在 Java 中却做不到。\r\n\r\n```\r\nusing System;\r\n\r\nnamespace CS01 {\r\n\r\n    class Program {\r\n        public static void swap(ref int x, ref int y) {\r\n            int temp = x;\r\n            x = y;\r\n            y = temp;\r\n        }\r\n\r\n        public static void Main (string[] args) {\r\n            int a = 5, b = 10;\r\n            swap (ref a, ref b);\r\n            // a = 10, b = 5;\r\n            Console.WriteLine (\"a = {0}, b = {1}\", a, b);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n> 说明：Java 中没有传引用实在是非常的不方便，这一点在 Java 8 中仍然没有得到改进，正是如此在 Java 编写的代码中才会出现大量的 Wrapper 类（将需要通过方法调用修改的引用置于一个 Wrapper 类中，再将 Wrapper 对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从 C 和 C++ 转型为 Java 程序员的开发者无法容忍。\r\n\r\n**19、String 和 StringBuilder、StringBuffer 的区别？**\r\n答：Java 平台提供了两种类型的字符串：String 和 StringBuffer/StringBuilder，它们可以储存和操作字符串。其中 String 是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的。而 StringBuffer/StringBuilder 类表示的字符串对象可以直接进行修改。StringBuilder 是 Java 5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被 synchronized 修饰，因此它的效率也比 StringBuffer 要高。\r\n\r\n> **面试题 1** - 什么情况下用 + 运算符进行字符串连接比调用 StringBuffer/StringBuilder 对象的 append 方法连接字符串性能更好？\r\n> \r\n> **面试题 2** - 请说出下面程序的输出。\r\n\r\n```\r\nclass StringEqualTest {\r\n\r\n    public static void main(String[] args) {\r\n        String s1 = \"Programming\";\r\n        String s2 = new String(\"Programming\");\r\n        String s3 = \"Program\";\r\n        String s4 = \"ming\";\r\n        String s5 = \"Program\" + \"ming\";\r\n        String s6 = s3 + s4;\r\n        System.out.println(s1 == s2);\r\n        System.out.println(s1 == s5);\r\n        System.out.println(s1 == s6);\r\n        System.out.println(s1 == s6.intern());\r\n        System.out.println(s2 == s2.intern());\r\n    }\r\n}\r\n```\r\n\r\n> 补充：解答上面的面试题需要清除两点：1\\. String 对象的 intern 方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与 String 对象的 equals 结果是 true），如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用；2\\. 字符串的 + 操作其本质是创建了 StringBuilder 对象进行 append 操作，然后将拼接后的 StringBuilder 对象用 toString 方法处理成 String 对象，这一点可以用 javap -c StringEqualTest.class 命令获得 class 文件对应的 JVM 字节码指令就可以看出来。\r\n\r\n**20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？**\r\n答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。\r\n\r\n> **面试题：**华为的面试题中曾经问过这样一个问题 - \"为什么不能根据返回类型来区分重载\"，快说出你的答案吧！\r\n\r\n**21、描述一下 JVM 加载 class 文件的原理机制？**\r\n答：JVM 中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java 中的类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。\r\n由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一个或多个类文件。当 Java 程序需要使用某个类时，JVM 会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的. class 文件中的数据读入到内存中，通常是创建一个字节数组读入. class 文件，然后产生与所加载类对应的 Class 对象。加载完成后，Class 对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后 JVM 对类进行初始化，包括：1) 如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2) 如果类中存在初始化语句，就依次执行这些初始化语句。\r\n类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader 的子类）。从 Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM 更好的保证了 Java 平台的安全性，在该机制中，JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM 不会向 Java 程序提供对 Bootstrap 的引用。下面是关于几个类加载器的说明：\r\n\r\n> *   Bootstrap：一般用本地代码实现，负责加载 JVM 基础核心类库（rt.jar）；\r\n> *   Extension：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap；\r\n> *   System：又叫应用类加载器，其父类是 Extension。它是应用最广泛的类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目录中记载类，是用户自定义加载器的默认父加载器。\r\n\r\n**22、char 型变量中能不能存贮一个中文汉字，为什么？**\r\n答：char 类型可以存储一个中文汉字，因为 Java 中使用的编码是 Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个 char 类型占 2 个字节（16 比特），所以放一个中文是没问题的。\r\n\r\n> **补充：**使用 Unicode 意味着字符在 JVM 内部和外部有不同的表现形式，在 JVM 内部都是 Unicode，当这个字符被从 JVM 内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以 Java 中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如 InputStreamReader 和 OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于 C 程序员来说，要完成这样的编码转换恐怕要依赖于 union（联合体 / 共用体）共享内存的特征来实现了。\r\n\r\n**23、抽象类（abstract class）和接口（interface）有什么异同？**\r\n答：抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是 private、默认、protected、public 的，而接口中的成员全都是 public 的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。\r\n\r\n**24、静态嵌套类 (Static Nested Class) 和内部类（Inner Class）的不同？**\r\n答：Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的，如下所示。\r\n\r\n```\r\n/**\r\n * 扑克类（一副扑克）\r\n * @author 骆昊\r\n *\r\n */\r\npublic class Poker {\r\n    private static String[] suites = {\"黑桃\", \"红桃\", \"草花\", \"方块\"};\r\n    private static int[] faces = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13};\r\n\r\n    private Card[] cards;\r\n\r\n    /**\r\n     * 构造器\r\n     * \r\n     */\r\n    public Poker() {\r\n        cards = new Card[52];\r\n        for(int i = 0; i < suites.length; i++) {\r\n            for(int j = 0; j < faces.length; j++) {\r\n                cards[i * 13 + j] = new Card(suites[i], faces[j]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 洗牌 （随机乱序）\r\n     * \r\n     */\r\n    public void shuffle() {\r\n        for(int i = 0, len = cards.length; i < len; i++) {\r\n            int index = (int) (Math.random() * len);\r\n            Card temp = cards[index];\r\n            cards[index] = cards[i];\r\n            cards[i] = temp;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 发牌\r\n     * @param index 发牌的位置\r\n     * \r\n     */\r\n    public Card deal(int index) {\r\n        return cards[index];\r\n    }\r\n\r\n    /**\r\n     * 卡片类（一张扑克）\r\n     * [内部类]\r\n     * @author 骆昊\r\n     *\r\n     */\r\n    public class Card {\r\n        private String suite;   // 花色\r\n        private int face;       // 点数\r\n\r\n        public Card(String suite, int face) {\r\n            this.suite = suite;\r\n            this.face = face;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            String faceStr = \"\";\r\n            switch(face) {\r\n            case 1: faceStr = \"A\"; break;\r\n            case 11: faceStr = \"J\"; break;\r\n            case 12: faceStr = \"Q\"; break;\r\n            case 13: faceStr = \"K\"; break;\r\n            default: faceStr = String.valueOf(face);\r\n            }\r\n            return suite + faceStr;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n测试代码：\r\n\r\n```\r\nclass PokerTest {\r\n\r\n    public static void main(String[] args) {\r\n        Poker poker = new Poker();\r\n        poker.shuffle();                // 洗牌\r\n        Poker.Card c1 = poker.deal(0);  // 发第一张牌\r\n        // 对于非静态内部类Card\r\n        // 只有通过其外部类Poker对象才能创建Card对象\r\n        Poker.Card c2 = poker.new Card(\"红心\", 1);    // 自己创建一张牌\r\n\r\n        System.out.println(c1);     // 洗牌后的第一张\r\n        System.out.println(c2);     // 打印: 红心A\r\n    }\r\n}\r\n```\r\n\r\n> 面试题 - 下面的代码哪些地方会产生编译错误？\r\n\r\n```\r\nclass Outer {\r\n\r\n    class Inner {}\r\n\r\n    public static void foo() { new Inner(); }\r\n\r\n    public void bar() { new Inner(); }\r\n\r\n    public static void main(String[] args) {\r\n        new Inner();\r\n    }\r\n}\r\n```\r\n\r\n> 注意：Java 中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中 foo 和 main 方法都是静态方法，静态方法中没有 this，也就是说没有所谓的外部类对象，因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样做：\r\n\r\n```\r\n    new Outer().new Inner();\r\n```\r\n\r\n**25、Java 中会存在内存泄漏吗，请简单描述。**\r\n答：理论上 Java 因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是 Java 被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被 GC 回收，因此也会导致内存泄露的发生。例如 Hibernate 的 Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。下面例子中的代码也会导致内存泄露。\r\n\r\n```\r\nimport java.util.Arrays;\r\nimport java.util.EmptyStackException;\r\n\r\npublic class MyStack<T> {\r\n    private T[] elements;\r\n    private int size = 0;\r\n\r\n    private static final int INIT_CAPACITY = 16;\r\n\r\n    public MyStack() {\r\n        elements = (T[]) new Object[INIT_CAPACITY];\r\n    }\r\n\r\n    public void push(T elem) {\r\n        ensureCapacity();\r\n        elements[size++] = elem;\r\n    }\r\n\r\n    public T pop() {\r\n        if(size == 0) \r\n            throw new EmptyStackException();\r\n        return elements[--size];\r\n    }\r\n\r\n    private void ensureCapacity() {\r\n        if(elements.length == size) {\r\n            elements = Arrays.copyOf(elements, 2 * size + 1);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的 pop 方法却存在内存泄露的问题，当我们用 pop 方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发 Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成 OutOfMemoryError。\r\n\r\n**26、抽象的（abstract）方法是否可同时是静态的（static）, 是否可同时是本地方法（native），是否可同时被 synchronized 修饰？**\r\n答：都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如 C 代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized 和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。\r\n\r\n**27、阐述静态变量和实例变量的区别。**\r\n答：静态变量是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。\r\n\r\n> **补充：**在 Java 开发中，上下文类和工具类中通常会有大量的静态成员。\r\n\r\n**28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？**\r\n答：不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。\r\n\r\n**29、如何实现对象克隆？**\r\n答：有两种方式：\r\n  1). 实现 Cloneable 接口并重写 Object 类中的 clone() 方法；\r\n  2). 实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。\r\n\r\n```\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.io.Serializable;\r\n\r\npublic class MyUtil {\r\n\r\n    private MyUtil() {\r\n        throw new AssertionError();\r\n    }\r\n\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static <T extends Serializable> T clone(T obj) throws Exception {\r\n        ByteArrayOutputStream bout = new ByteArrayOutputStream();\r\n        ObjectOutputStream oos = new ObjectOutputStream(bout);\r\n        oos.writeObject(obj);\r\n\r\n        ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray());\r\n        ObjectInputStream ois = new ObjectInputStream(bin);\r\n        return (T) ois.readObject();\r\n\r\n        // 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义\r\n        // 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放\r\n    }\r\n}\r\n```\r\n\r\n下面是测试代码：\r\n\r\n```\r\nimport java.io.Serializable;\r\n\r\n/**\r\n * 人类\r\n * @author 骆昊\r\n *\r\n */\r\nclass Person implements Serializable {\r\n    private static final long serialVersionUID = -9102017020286042305L;\r\n\r\n    private String name;    // 姓名\r\n    private int age;        // 年龄\r\n    private Car car;        // 座驾\r\n\r\n    public Person(String name, int age, Car car) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.car = car;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public Car getCar() {\r\n        return car;\r\n    }\r\n\r\n    public void setCar(Car car) {\r\n        this.car = car;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Person []\";\r\n    }\r\n\r\n}\r\n```\r\n\r\n```\r\n/**\r\n * 小汽车类\r\n * @author 骆昊\r\n *\r\n */\r\nclass Car implements Serializable {\r\n    private static final long serialVersionUID = -5713945027627603702L;\r\n\r\n    private String brand;       // 品牌\r\n    private int maxSpeed;       // 最高时速\r\n\r\n    public Car(String brand, int maxSpeed) {\r\n        this.brand = brand;\r\n        this.maxSpeed = maxSpeed;\r\n    }\r\n\r\n    public String getBrand() {\r\n        return brand;\r\n    }\r\n\r\n    public void setBrand(String brand) {\r\n        this.brand = brand;\r\n    }\r\n\r\n    public int getMaxSpeed() {\r\n        return maxSpeed;\r\n    }\r\n\r\n    public void setMaxSpeed(int maxSpeed) {\r\n        this.maxSpeed = maxSpeed;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Car [brand=\" + brand + \", maxSpeed=\" + maxSpeed + \"]\";\r\n    }\r\n\r\n}\r\n```\r\n\r\n```\r\nclass CloneTest {\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            Person p1 = new Person(\"Hao LUO\", 33, new Car(\"Benz\", 300));\r\n            Person p2 = MyUtil.clone(p1);   // 深度克隆\r\n            p2.getCar().setBrand(\"BYD\");\r\n            // 修改克隆的Person对象p2关联的汽车对象的品牌属性\r\n            // 原来的Person对象p1关联的汽车不会受到任何影响\r\n            // 因为在克隆Person对象时其关联的汽车对象也被克隆了\r\n            System.out.println(p1);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n> **注意：**基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用 Object 类的 clone 方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。\r\n\r\n30、GC 是什么？为什么要有 GC？\r\n答：GC 是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或 Runtime.getRuntime().gc() ，但 JVM 可以屏蔽掉显示的垃圾回收调用。\r\n垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在 Java 诞生初期，垃圾回收是 Java 最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今 Java 的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得 iOS 的系统比 Android 系统有更好的用户体验，其中一个深层次的原因就在于 Android 系统中垃圾回收的不可预知性。\r\n\r\n> **补充：**垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的 Java 进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java 平台对堆内存回收和再利用的基本算法被称为标记和清除，但是 Java 对其进行了改进，采用 “分代式垃圾收集”。这种方法会跟 Java 对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域：\r\n> - 伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。\r\n> - 幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。\r\n> - 终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。\r\n\r\n与垃圾回收相关的 JVM 参数：\r\n\r\n> *   -Xms / -Xmx — 堆的初始大小 / 堆的最大大小\r\n> *   -Xmn — 堆中年轻代的大小\r\n> *   -XX:-DisableExplicitGC — 让 System.gc() 不产生任何作用\r\n> *   -XX:+PrintGCDetails — 打印 GC 的细节\r\n> *   -XX:+PrintGCDateStamps — 打印 GC 操作的时间戳\r\n> *   -XX:NewSize / XX:MaxNewSize — 设置新生代大小 / 新生代最大大小\r\n> *   -XX:NewRatio — 可以设置老生代和新生代的比例\r\n> *   -XX:PrintTenuringDistribution — 设置每次新生代 GC 后输出幸存者乐园中对象年龄的分布\r\n> *   -XX:InitialTenuringThreshold / -XX:MaxTenuringThreshold：设置老年代阀值的初始值和最大值\r\n> *   -XX:TargetSurvivorRatio：设置幸存区的目标使用率\r\n\r\n**31、String s = new String(\"xyz\"); 创建了几个字符串对象？**\r\n答：两个对象，一个是静态区的 \"xyz\"，一个是用 new 创建在堆上的对象。\r\n\r\n**32、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？**\r\n答：接口可以继承接口，而且支持多重继承。抽象类可以实现 (implements) 接口，抽象类可继承具体类也可以继承抽象类。\r\n\r\n**33、一个 \".java\" 源文件中是否可以包含多个类（不是内部类）？有什么限制？**\r\n答：可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。\r\n\r\n**34、Anonymous Inner Class(匿名内部类) 是否可以继承其它类？是否可以实现接口？**\r\n答：可以继承其他类或实现其他接口，在 Swing 编程和 Android 开发中常用此方式来实现事件监听和回调。\r\n\r\n**35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？**\r\n答：一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。\r\n\r\n**36、Java 中的 final 关键字有哪些用法？**\r\n答：(1) 修饰类：表示该类不能被继承；(2) 修饰方法：表示方法不能被重写；(3) 修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。\r\n\r\n**37、指出下面程序的运行结果。**\r\n\r\n```\r\nclass A {\r\n\r\n    static {\r\n        System.out.print(\"1\");\r\n    }\r\n\r\n    public A() {\r\n        System.out.print(\"2\");\r\n    }\r\n}\r\n\r\nclass B extends A{\r\n\r\n    static {\r\n        System.out.print(\"a\");\r\n    }\r\n\r\n    public B() {\r\n        System.out.print(\"b\");\r\n    }\r\n}\r\n\r\npublic class Hello {\r\n\r\n    public static void main(String[] args) {\r\n        A ab = new B();\r\n        ab = new B();\r\n    }\r\n\r\n}\r\n```\r\n\r\n答：执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。\r\n\r\n> **提示：**如果不能给出此题的正确答案，说明之前第 21 题 Java 类加载机制还没有完全理解，赶紧再看看吧。\r\n\r\n**38、数据类型之间的转换：**\r\n**- 如何将字符串转换为基本数据类型？**\r\n**- 如何将基本数据类型转换为字符串？**\r\n答：\r\n- 调用基本数据类型对应的包装类中的方法 parseXXX(String) 或 valueOf(String) 即可返回相应基本类型；\r\n- 一种方法是将基本数据类型与空字符串（\"\"）连接（+）即可获得其所对应的字符串；另一种方法是调用 String 类中的 valueOf() 方法返回相应字符串\r\n\r\n**39、如何实现字符串的反转及替换？**\r\n答：方法很多，可以自己写实现也可以使用 String 或 StringBuffer/StringBuilder 中的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示：\r\n\r\n```\r\n    public static String reverse(String originStr) {\r\n        if(originStr == null || originStr.length() <= 1) \r\n            return originStr;\r\n        return reverse(originStr.substring(1)) + originStr.charAt(0);\r\n    }\r\n```\r\n\r\n**40、怎样将 GB2312 编码的字符串转换为 ISO-8859-1 编码的字符串？**\r\n答：代码如下所示：\r\n\r\n```\r\nString s1 = \"你好\";\r\nString s2 = new String(s1.getBytes(\"GB2312\"), \"ISO-8859-1\");\r\n```\r\n\r\n**41、日期和时间：**\r\n**- 如何取得年月日、小时分钟秒？**\r\n**- 如何取得从 1970 年 1 月 1 日 0 时 0 分 0 秒到现在的毫秒数？**\r\n**- 如何取得某月的最后一天？**\r\n**- 如何格式化日期？**\r\n答：\r\n问题 1：创建 java.util.Calendar 实例，调用其 get() 方法传入不同的参数即可获得参数所对应的值。Java 8 中可以使用 java.time.LocalDateTimel 来获取，代码如下所示。\r\n\r\n```\r\npublic class DateTimeTest {\r\n    public static void main(String[] args) {\r\n        Calendar cal = Calendar.getInstance();\r\n        System.out.println(cal.get(Calendar.YEAR));\r\n        System.out.println(cal.get(Calendar.MONTH));    // 0 - 11\r\n        System.out.println(cal.get(Calendar.DATE));\r\n        System.out.println(cal.get(Calendar.HOUR_OF_DAY));\r\n        System.out.println(cal.get(Calendar.MINUTE));\r\n        System.out.println(cal.get(Calendar.SECOND));\r\n\r\n        // Java 8\r\n        LocalDateTime dt = LocalDateTime.now();\r\n        System.out.println(dt.getYear());\r\n        System.out.println(dt.getMonthValue());     // 1 - 12\r\n        System.out.println(dt.getDayOfMonth());\r\n        System.out.println(dt.getHour());\r\n        System.out.println(dt.getMinute());\r\n        System.out.println(dt.getSecond());\r\n    }\r\n}\r\n```\r\n\r\n问题 2：以下方法均可获得该毫秒数。\r\n\r\n```\r\nCalendar.getInstance().getTimeInMillis();\r\nSystem.currentTimeMillis();\r\nClock.systemDefaultZone().millis(); // Java 8\r\n```\r\n\r\n问题 3：代码如下所示。\r\n\r\n```\r\nCalendar time = Calendar.getInstance();\r\ntime.getActualMaximum(Calendar.DAY_OF_MONTH);\r\n```\r\n\r\n问题 4：利用 java.text.DataFormat 的子类（如 SimpleDateFormat 类）中的 format(Date) 方法可将日期格式化。Java 8 中可以用 java.time.format.DateTimeFormatter 来格式化时间日期，代码如下所示。\r\n\r\n```\r\nimport java.text.SimpleDateFormat;\r\nimport java.time.LocalDate;\r\nimport java.time.format.DateTimeFormatter;\r\nimport java.util.Date;\r\n\r\nclass DateFormatTest {\r\n\r\n    public static void main(String[] args) {\r\n        SimpleDateFormat oldFormatter = new SimpleDateFormat(\"yyyy/MM/dd\");\r\n        Date date1 = new Date();\r\n        System.out.println(oldFormatter.format(date1));\r\n\r\n        // Java 8\r\n        DateTimeFormatter newFormatter = DateTimeFormatter.ofPattern(\"yyyy/MM/dd\");\r\n        LocalDate date2 = LocalDate.now();\r\n        System.out.println(date2.format(newFormatter));\r\n    }\r\n}\r\n```\r\n\r\n> 补充：Java 的时间日期 API 一直以来都是被诟病的东西，为了解决这一问题，Java 8 中引入了新的时间日期 API，其中包括 LocalDate、LocalTime、LocalDateTime、Clock、Instant 等类，这些的类的设计都使用了不变模式，因此是线程安全的设计。如果不理解这些内容，可以参考我的另一篇文章[《关于 Java 并发编程的总结和思考》](http://blog.csdn.net/jackfrued/article/details/44499227)。\r\n\r\n**42、打印昨天的当前时刻。**\r\n答：\r\n\r\n```\r\nimport java.util.Calendar;\r\n\r\nclass YesterdayCurrent {\r\n    public static void main(String[] args){\r\n        Calendar cal = Calendar.getInstance();\r\n        cal.add(Calendar.DATE, -1);\r\n        System.out.println(cal.getTime());\r\n    }\r\n}\r\n```\r\n\r\n在 Java 8 中，可以用下面的代码实现相同的功能。\r\n\r\n```\r\nimport java.time.LocalDateTime;\r\n\r\nclass YesterdayCurrent {\r\n\r\n    public static void main(String[] args) {\r\n        LocalDateTime today = LocalDateTime.now();\r\n        LocalDateTime yesterday = today.minusDays(1);\r\n\r\n        System.out.println(yesterday);\r\n    }\r\n}\r\n```\r\n\r\n**43、比较一下 Java 和 JavaSciprt。**\r\n答：JavaScript 与 Java 是两个公司开发的不同的两个产品。Java 是原 Sun Microsystems 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而 JavaScript 是 Netscape 公司的产品，为了扩展 Netscape 浏览器的功能而开发的一种可以嵌入 Web 页面中运行的基于对象和事件驱动的解释性语言。JavaScript 的前身是 LiveScript；而 Java 的前身是 Oak 语言。\r\n下面对两种语言间的异同作如下比较：\r\n- 基于对象和面向对象：Java 是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript 是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。\r\n- 解释和编译：Java 的源代码在执行之前，必须经过编译。JavaScript 是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了 JIT（即时编译）技术来提升 JavaScript 的运行效率）\r\n- 强类型变量和类型弱变量：Java 采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript 中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript 的解释器在运行时检查推断其数据类型。\r\n- 代码格式不一样。\r\n\r\n> **补充：**上面列出的四点是网上流传的所谓的标准答案。其实 Java 和 JavaScript 最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在 Java 中类（class）是一等公民，而 JavaScript 中函数（function）是一等公民，因此 JavaScript 支持函数式编程，可以使用 Lambda 函数和闭包（closure），当然 Java 8 也开始支持函数式编程，提供了对 Lambda 表达式以及函数式接口的支持。对于这类问题，在面试的时候最好还是用自己的语言回答会更加靠谱，不要背网上所谓的标准答案。\r\n\r\n**44、什么时候用断言（assert）？**\r\n答：断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为 true；如果表达式的值为 false，那么系统会报告一个 AssertionError。断言的使用如下面的代码所示：\r\n\r\n```\r\nassert(a > 0); // throws an AssertionError if a <= 0\r\n```\r\n\r\n断言可以有两种形式：\r\nassert Expression1;\r\nassert Expression1 : Expression2 ;\r\nExpression1 应该总是产生一个布尔值。\r\nExpression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。\r\n\r\n要在运行时启用断言，可以在启动 JVM 时使用 - enableassertions 或者 - ea 标记。要在运行时选择禁用断言，可以在启动 JVM 时使用 - da 或者 - disableassertions 标记。要在系统类中启用或禁用断言，可使用 - esa 或 - dsa 标记。还可以在包的基础上启用或者禁用断言。\r\n\r\n> **注意：**断言不应该以任何方式改变程序的状态。简单的说，如果希望在不满足某些条件时阻止代码的执行，就可以考虑用断言来阻止它。\r\n\r\n**45、Error 和 Exception 有什么区别？**\r\n答：Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。\r\n\r\n> 面试题：2005 年摩托罗拉的面试中曾经问过这么一个问题 “If a process reports a stack overflow run-time error, what’s the most possible cause?”，给了四个选项 a. lack of memory; b. write on an invalid memory space; c. recursive function calling; d. array index out of boundary. Java 程序在运行时也可能会遭遇 StackOverflowError，这是一个无法恢复的错误，只能重新修改代码了，这个面试题的答案是 c。如果写了不能迅速收敛的递归，则很有可能引发栈溢出的错误，如下所示：\r\n\r\n```\r\nclass StackOverflowErrorTest {\r\n\r\n    public static void main(String[] args) {\r\n        main(null);\r\n    }\r\n}\r\n```\r\n\r\n> **提示：**用递归编写程序时一定要牢记两点：1\\. 递归公式；2\\. 收敛条件（什么时候就不再继续递归）。\r\n\r\n**46、try{} 里有一个 return 语句，那么紧跟在这个 try 后的 finally{} 里的代码会不会被执行，什么时候被执行，在 return 前还是后?**\r\n答：会执行，在方法返回调用者前执行。\r\n\r\n> **注意：**在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try 中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的困扰，C# 中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java 中也可以通过提升编译器的语法检查级别来产生警告或错误，Eclipse 中可以在如图所示的地方进行设置，强烈建议将此项设置为编译错误。\r\n\r\n![](https://img-blog.csdn.net/20150407162012325)\r\n\r\n**47、Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally 分别如何使用？**\r\n答：Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在 Java 中，每个异常都是一个对象，它是 Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws 和 finally。一般情况下是用 try 来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try 用来指定一块预防所有异常的程序；catch 子句紧跟在 try 块后面，用来指定你想要捕获的异常的类型；throw 语句用来明确地抛出一个异常；throws 用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally 为确保一段代码不管发生什么异常状况都要被执行；try 语句可以嵌套，每当遇到一个 try 语句，异常的结构就会被放入异常栈中，直到所有的 try 语句都完成。如果下一级的 try 语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的 try 语句或者最终将异常抛给 JVM。\r\n\r\n**48、运行时异常与受检异常有何异同？**\r\n答：异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java 编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在 _Effective Java_ 中对异常的使用给出了以下指导原则：\r\n- 不要将异常处理用于正常的控制流（设计良好的 API 不应该强迫它的调用者为了正常的控制流而使用异常）\r\n- 对可以恢复的情况使用受检异常，对编程错误使用运行时异常\r\n- 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）\r\n- 优先使用标准的异常\r\n- 每个方法抛出的异常都要有文档\r\n- 保持异常的原子性\r\n- 不要在 catch 中忽略掉捕获到的异常\r\n\r\n**49、列出一些你常见的运行时异常？**\r\n答：\r\n- ArithmeticException（算术异常）\r\n- ClassCastException （类转换异常）\r\n- IllegalArgumentException （非法参数异常）\r\n- IndexOutOfBoundsException （下标越界异常）\r\n- NullPointerException （空指针异常）\r\n- SecurityException （安全异常）\r\n\r\n**50、阐述 final、finally、finalize 的区别。**\r\n答：\r\n- final：修饰符（关键字）有三种用法：如果一个类被声明为 final，意味着它不能再派生出新的子类，即不能被继承，因此它和 abstract 是反义词。将变量声明为 final，可以保证它们在使用中不被改变，被声明为 final 的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为 final 的方法也同样只能使用，不能在子类中被重写。\r\n- finally：通常放在 try…catch… 的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要 JVM 不关闭都能执行，可以将释放外部资源的代码写在 finally 块中。\r\n- finalize：Object 类中定义的方法，Java 中允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写 finalize() 方法可以整理系统资源或者执行其他清理工作。\r\n\r\n**51、类 ExampleA 继承 Exception，类 ExampleB 继承 ExampleA。**\r\n**有如下代码片断：**\r\n\r\n```\r\ntry {\r\n    throw new ExampleB(\"b\")\r\n} catch（ExampleA e）{\r\n    System.out.println(\"ExampleA\");\r\n} catch（Exception e）{\r\n    System.out.println(\"Exception\");\r\n}\r\n```\r\n\r\n**请问执行此段代码的输出是什么？**\r\n答：输出：ExampleA。（根据里氏代换原则 [能使用父类型的地方一定能使用子类型]，抓取 ExampleA 类型异常的 catch 块能够抓住 try 块中抛出的 ExampleB 类型的异常）\r\n\r\n> **面试题** - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书）\r\n\r\n```\r\nclass Annoyance extends Exception {}\r\nclass Sneeze extends Annoyance {}\r\n\r\nclass Human {\r\n\r\n    public static void main(String[] args) \r\n        throws Exception {\r\n        try {\r\n            try {\r\n                throw new Sneeze();\r\n            } \r\n            catch ( Annoyance a ) {\r\n                System.out.println(\"Caught Annoyance\");\r\n                throw a;\r\n            }\r\n        } \r\n        catch ( Sneeze s ) {\r\n            System.out.println(\"Caught Sneeze\");\r\n            return ;\r\n        }\r\n        finally {\r\n            System.out.println(\"Hello World!\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**52、List、Set、Map 是否继承自 Collection 接口？**\r\n答：List、Set 是，Map 不是。Map 是键值对映射容器，与 List 和 Set 有明显的区别，而 Set 存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List 是线性结构的容器，适用于按数值索引访问元素的情形。\r\n\r\n**53、阐述 ArrayList、Vector、LinkedList 的存储性能和特性。**\r\n答：ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 中的方法由于添加了 synchronized 修饰，因此 Vector 是线程安全的容器，但性能上较 ArrayList 差，因此已经是 Java 中的遗留容器。LinkedList 使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector 属于遗留容器（Java 早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties 都是遗留容器），已经不推荐使用，但是由于 ArrayList 和 LinkedListed 都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类 Collections 中的 synchronizedList 方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。\r\n\r\n> **补充：**遗留容器中的 Properties 类和 Stack 类在设计上有严重的问题，Properties 是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个 Hashtable 并将其两个泛型参数设置为 String 类型，但是 Java API 中的 Properties 直接继承了 Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是 Has-A 关系而不是 Is-A 关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是 Has-A 关系（关联）或 Use-A 关系（依赖）。同理，Stack 类继承 Vector 也是不正确的。Sun 公司的工程师们也会犯这种低级错误，让人唏嘘不已。\r\n\r\n**54、Collection 和 Collections 的区别？**\r\n答：Collection 是一个接口，它是 Set、List 等容器的父接口；Collections 是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。\r\n\r\n**55、List、Map、Set 三个接口存取元素时，各有什么特点？**\r\n答：List 以特定索引来存取元素，可以有重复元素。Set 不能存放重复元素（用对象的 equals() 方法来区分元素是否重复）。Map 保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set 和 Map 容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为 O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。\r\n\r\n**56、TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort() 方法如何比较元素？**\r\n答：TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo() 方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进行排序。Collections 工具类的 sort 方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是 Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。\r\n例子 1：\r\n\r\n```\r\n\r\npublic class Student implements Comparable<Student> {\r\n    private String name;        // 姓名\r\n    private int age;            // 年龄\r\n\r\n    public Student(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Student []\";\r\n    }\r\n\r\n    @Override\r\n    public int compareTo(Student o) {\r\n        return this.age - o.age; // 比较年龄(年龄的升序)\r\n    }\r\n\r\n}\r\n```\r\n\r\n```\r\nimport java.util.Set;\r\nimport java.util.TreeSet;\r\n\r\nclass Test01 {\r\n\r\n    public static void main(String[] args) {\r\n        Set<Student> set = new TreeSet<>();     // Java 7的钻石语法(构造器后面的尖括号中不需要写类型)\r\n        set.add(new Student(\"Hao LUO\", 33));\r\n        set.add(new Student(\"XJ WANG\", 32));\r\n        set.add(new Student(\"Bruce LEE\", 60));\r\n        set.add(new Student(\"Bob YANG\", 22));\r\n\r\n        for(Student stu : set) {\r\n            System.out.println(stu);\r\n        }\r\n//      输出结果: \r\n//      Student [name=Bob YANG, age=22]\r\n//      Student [name=XJ WANG, age=32]\r\n//      Student [name=Hao LUO, age=33]\r\n//      Student [name=Bruce LEE, age=60]\r\n    }\r\n}\r\n```\r\n\r\n例子 2：\r\n\r\n```\r\npublic class Student {\r\n    private String name;    // 姓名\r\n    private int age;        // 年龄\r\n\r\n    public Student(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    /**\r\n     * 获取学生姓名\r\n     */\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * 获取学生年龄\r\n     */\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Student []\";\r\n    }\r\n\r\n}\r\n```\r\n\r\n```\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.List;\r\n\r\nclass Test02 {\r\n\r\n    public static void main(String[] args) {\r\n        List<Student> list = new ArrayList<>();     // Java 7的钻石语法(构造器后面的尖括号中不需要写类型)\r\n        list.add(new Student(\"Hao LUO\", 33));\r\n        list.add(new Student(\"XJ WANG\", 32));\r\n        list.add(new Student(\"Bruce LEE\", 60));\r\n        list.add(new Student(\"Bob YANG\", 22));\r\n\r\n        // 通过sort方法的第二个参数传入一个Comparator接口对象\r\n        // 相当于是传入一个比较对象大小的算法到sort方法中\r\n        // 由于Java中没有函数指针、仿函数、委托这样的概念\r\n        // 因此要将一个算法传入一个方法中唯一的选择就是通过接口回调\r\n        Collections.sort(list, new Comparator<Student> () {\r\n\r\n            @Override\r\n            public int compare(Student o1, Student o2) {\r\n                return o1.getName().compareTo(o2.getName());    // 比较学生姓名\r\n            }\r\n        });\r\n\r\n        for(Student stu : list) {\r\n            System.out.println(stu);\r\n        }\r\n//      输出结果: \r\n//      Student [name=Bob YANG, age=22]\r\n//      Student [name=Bruce LEE, age=60]\r\n//      Student [name=Hao LUO, age=33]\r\n//      Student [name=XJ WANG, age=32]\r\n    }\r\n}\r\n```\r\n\r\n**57、Thread 类的 sleep() 方法和对象的 wait() 方法都可以让线程暂停执行，它们有什么区别?**\r\n答：sleep() 方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第 66 题中的线程状态转换图）。wait() 是 Object 类的方法，调用对象的 wait() 方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的 notify() 方法（或 notifyAll() 方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。\r\n\r\n> **补充：**可能不少人对什么是进程，什么是线程还比较模糊，对于为什么需要多线程编程也不是特别理解。简单的说：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是 CPU 调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的 CPU 资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费 CPU 时间。时下很时髦的 [Node.js](https://nodejs.org) 就采用了单线程异步 I/O 的工作模式。\r\n\r\n**58、线程的 sleep() 方法和 yield() 方法有什么区别？**\r\n答：\r\n① sleep() 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield() 方法只会给相同优先级或更高优先级的线程以运行的机会；\r\n② 线程执行 sleep() 方法后转入阻塞（blocked）状态，而执行 yield() 方法后转入就绪（ready）状态；\r\n③ sleep() 方法声明抛出 InterruptedException，而 yield() 方法没有声明任何异常；\r\n④ sleep() 方法比 yield() 方法（跟操作系统 CPU 调度相关）具有更好的可移植性。\r\n\r\n**59、当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？**\r\n答：不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的 synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入 A 方法说明对象锁已经被取走，那么试图进入 B 方法的线程就只能在等锁池（**注意不是等待池哦**）中等待对象的锁。\r\n\r\n**60、请说出与线程同步以及线程调度相关的方法。**\r\n答：\r\n- wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；\r\n- sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常；\r\n- notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；\r\n- notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；\r\n\r\n> **提示：**关于 Java 多线程和并发编程的问题，建议大家看我的另一篇文章[《关于 Java 并发编程的总结和思考》](http://blog.csdn.net/jackfrued/article/details/44499227)。\r\n> \r\n> 补充：Java 5 通过 Lock 接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。Lock 接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了 newCondition() 方法来产生用于线程之间通信的 Condition 对象；此外，Java 5 还提供了信号量机制（semaphore），信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用 Semaphore 对象的 acquire() 方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用 Semaphore 对象的 release() 方法）。\r\n\r\n下面的例子演示了 100 个线程同时向一个银行账户中存入 1 元钱，在没有使用同步机制和使用同步机制情况下的执行情况。\r\n\r\n*   银行账户类：\r\n\r\n```\r\n/**\r\n * 银行账户\r\n * @author 骆昊\r\n *\r\n */\r\npublic class Account {\r\n    private double balance;     // 账户余额\r\n\r\n    /**\r\n     * 存款\r\n     * @param money 存入金额\r\n     */\r\n    public void deposit(double money) {\r\n        double newBalance = balance + money;\r\n        try {\r\n            Thread.sleep(10);   // 模拟此业务需要一段处理时间\r\n        }\r\n        catch(InterruptedException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        balance = newBalance;\r\n    }\r\n\r\n    /**\r\n     * 获得账户余额\r\n     */\r\n    public double getBalance() {\r\n        return balance;\r\n    }\r\n}\r\n```\r\n\r\n*   存钱线程类：\r\n\r\n```\r\n/**\r\n * 存钱线程\r\n * @author 骆昊\r\n *\r\n */\r\npublic class AddMoneyThread implements Runnable {\r\n    private Account account;    // 存入账户\r\n    private double money;       // 存入金额\r\n\r\n    public AddMoneyThread(Account account, double money) {\r\n        this.account = account;\r\n        this.money = money;\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        account.deposit(money);\r\n    }\r\n\r\n}\r\n```\r\n\r\n*   测试类：\r\n\r\n```\r\nimport java.util.concurrent.ExecutorService;\r\nimport java.util.concurrent.Executors;\r\n\r\npublic class Test01 {\r\n\r\n    public static void main(String[] args) {\r\n        Account account = new Account();\r\n        ExecutorService service = Executors.newFixedThreadPool(100);\r\n\r\n        for(int i = 1; i <= 100; i++) {\r\n            service.execute(new AddMoneyThread(account, 1));\r\n        }\r\n\r\n        service.shutdown();\r\n\r\n        while(!service.isTerminated()) {}\r\n\r\n        System.out.println(\"账户余额: \" + account.getBalance());\r\n    }\r\n}\r\n```\r\n\r\n在没有同步的情况下，执行结果通常是显示账户余额在 10 元以下，出现这种状况的原因是，当一个线程 A 试图存入 1 元的时候，另外一个线程 B 也能够进入存款的方法中，线程 B 读取到的账户余额仍然是线程 A 存入 1 元钱之前的账户余额，因此也是在原来的余额 0 上面做了加 1 元的操作，同理线程 C 也会做类似的事情，所以最后 100 个线程执行结束时，本来期望账户余额为 100 元，但实际得到的通常在 10 元以下（很可能是 1 元哦）。解决这个问题的办法就是同步，当一个线程对银行账户存钱时，需要将此账户锁定，待其操作完成后才允许其他的线程进行操作，代码有如下几种调整方案：\r\n\r\n*   在银行账户的存款（deposit）方法上同步（synchronized）关键字\r\n\r\n```\r\n/**\r\n * 银行账户\r\n * @author 骆昊\r\n *\r\n */\r\npublic class Account {\r\n    private double balance;     // 账户余额\r\n\r\n    /**\r\n     * 存款\r\n     * @param money 存入金额\r\n     */\r\n    public synchronized void deposit(double money) {\r\n        double newBalance = balance + money;\r\n        try {\r\n            Thread.sleep(10);   // 模拟此业务需要一段处理时间\r\n        }\r\n        catch(InterruptedException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        balance = newBalance;\r\n    }\r\n\r\n    /**\r\n     * 获得账户余额\r\n     */\r\n    public double getBalance() {\r\n        return balance;\r\n    }\r\n}\r\n```\r\n\r\n*   在线程调用存款方法时对银行账户进行同步\r\n\r\n```\r\n/**\r\n * 存钱线程\r\n * @author 骆昊\r\n *\r\n */\r\npublic class AddMoneyThread implements Runnable {\r\n    private Account account;    // 存入账户\r\n    private double money;       // 存入金额\r\n\r\n    public AddMoneyThread(Account account, double money) {\r\n        this.account = account;\r\n        this.money = money;\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        synchronized (account) {\r\n            account.deposit(money); \r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n*   通过 Java 5 显示的锁机制，为每个银行账户创建一个锁对象，在存款操作进行加锁和解锁的操作\r\n\r\n```\r\nimport java.util.concurrent.locks.Lock;\r\nimport java.util.concurrent.locks.ReentrantLock;\r\n\r\n/**\r\n * 银行账户\r\n * \r\n * @author 骆昊\r\n *\r\n */\r\npublic class Account {\r\n    private Lock accountLock = new ReentrantLock();\r\n    private double balance; // 账户余额\r\n\r\n    /**\r\n     * 存款\r\n     * \r\n     * @param money\r\n     *            存入金额\r\n     */\r\n    public void deposit(double money) {\r\n        accountLock.lock();\r\n        try {\r\n            double newBalance = balance + money;\r\n            try {\r\n                Thread.sleep(10); // 模拟此业务需要一段处理时间\r\n            }\r\n            catch (InterruptedException ex) {\r\n                ex.printStackTrace();\r\n            }\r\n            balance = newBalance;\r\n        }\r\n        finally {\r\n            accountLock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获得账户余额\r\n     */\r\n    public double getBalance() {\r\n        return balance;\r\n    }\r\n}\r\n```\r\n\r\n按照上述三种方式对代码进行修改后，重写执行测试代码 Test01，将看到最终的账户余额为 100 元。当然也可以使用 Semaphore 或 CountdownLatch 来实现同步。\r\n\r\n**61、编写多线程程序有几种实现方式？**\r\n答：Java 5 以前实现多线程有两种实现方法：一种是继承 Thread 类；另一种是实现 Runnable 接口。两种方式都要通过重写 run() 方法来定义线程的行为，推荐使用后者，因为 Java 中的继承是单继承，一个类有一个父类，如果继承了 Thread 类就无法再继承其他类了，显然使用 Runnable 接口更为灵活。\r\n\r\n> 补充：Java 5 以后创建线程还有第三种方式：实现 Callable 接口，该接口中的 call 方法可以在线程执行结束时产生一个返回值，代码如下所示：\r\n\r\n```\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.concurrent.Callable;\r\nimport java.util.concurrent.ExecutorService;\r\nimport java.util.concurrent.Executors;\r\nimport java.util.concurrent.Future;\r\n\r\nclass MyTask implements Callable<Integer> {\r\n    private int upperBounds;\r\n\r\n    public MyTask(int upperBounds) {\r\n        this.upperBounds = upperBounds;\r\n    }\r\n\r\n    @Override\r\n    public Integer call() throws Exception {\r\n        int sum = 0; \r\n        for(int i = 1; i <= upperBounds; i++) {\r\n            sum += i;\r\n        }\r\n        return sum;\r\n    }\r\n\r\n}\r\n\r\nclass Test {\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        List<Future<Integer>> list = new ArrayList<>();\r\n        ExecutorService service = Executors.newFixedThreadPool(10);\r\n        for(int i = 0; i < 10; i++) {\r\n            list.add(service.submit(new MyTask((int) (Math.random() * 100))));\r\n        }\r\n\r\n        int sum = 0;\r\n        for(Future<Integer> future : list) {\r\n            // while(!future.isDone()) ;\r\n            sum += future.get();\r\n        }\r\n\r\n        System.out.println(sum);\r\n    }\r\n}\r\n```\r\n\r\n**62、synchronized 关键字的用法？**\r\n答：synchronized 关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用 synchronized(对象) { … } 定义同步代码块，或者在声明方法时将 synchronized 作为方法的修饰符。在第 60 题的例子中已经展示了 synchronized 关键字的用法。\r\n\r\n**63、举例说明同步和异步。**\r\n答：如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。\r\n\r\n**64、启动一个线程是调用 run() 还是 start() 方法？**\r\n答：启动一个线程是调用 start() 方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由 JVM 调度并执行，这并不意味着线程就会立即运行。run() 方法是线程启动后要进行回调（callback）的方法。\r\n\r\n**65、什么是线程池（thread pool）？**\r\n答：在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是” 池化资源” 技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。\r\nJava 5 + 中的 Executor 接口定义一个执行线程的工具。它的子类型即线程池接口是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 Executors 面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：\r\n- newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。\r\n- newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。\r\n- newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。\r\n- newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。\r\n- newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。\r\n\r\n第 60 题的例子中演示了通过 Executors 工具类创建线程池并使用线程池执行线程的代码。如果希望在服务器上使用线程池，强烈建议使用 newFixedThreadPool 方法来创建线程池，这样能获得更好的性能。\r\n\r\n**66、线程的基本状态以及状态之间的关系？**\r\n答：\r\n![](https://img-blog.csdn.net/20150408002007838)\r\n\r\n> **说明：**其中 Running 表示运行状态，Runnable 表示就绪状态（万事俱备，只欠 CPU），Blocked 表示阻塞状态，阻塞状态又有多种情况，可能是因为调用 wait() 方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了 sleep() 方法或 join() 方法等待休眠或其他线程结束，或是因为发生了 I/O 中断。\r\n\r\n**67、简述 synchronized 和 java.util.concurrent.locks.Lock 的异同？**\r\n答：Lock 是 Java 5 以后引入的新的 API，和关键字 synchronized 相比主要相同点：Lock 能完成 synchronized 所实现的所有功能；主要不同点：Lock 有比 synchronized 更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。synchronized 会自动释放锁，而 Lock 一定要求程序员手工释放，并且最好在 finally 块中释放（这是释放外部资源的最好的地方）。\r\n\r\n**68、Java 中如何实现序列化，有什么意义？**\r\n答：序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。\r\n要实现序列化，需要让一个类实现 Serializable 接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过 writeObject(Object) 方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过 readObject 方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆（可以参考第 29 题）。\r\n\r\n**69、Java 中有几种类型的流？**\r\n答：字节流和字符流。字节流继承于 InputStream、OutputStream，字符流继承于 Reader、Writer。在 java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。关于 Java 的 I/O 需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外 Java 中的流不同于 C# 的是它只有一个维度一个方向。\r\n\r\n> **面试题** - 编程实现文件拷贝。（这个题目在笔试的时候经常出现，下面的代码给出了两种实现方案）\r\n\r\n```\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.OutputStream;\r\nimport java.nio.ByteBuffer;\r\nimport java.nio.channels.FileChannel;\r\n\r\npublic final class MyUtil {\r\n\r\n    private MyUtil() {\r\n        throw new AssertionError();\r\n    }\r\n\r\n    public static void fileCopy(String source, String target) throws IOException {\r\n        try (InputStream in = new FileInputStream(source)) {\r\n            try (OutputStream out = new FileOutputStream(target)) {\r\n                byte[] buffer = new byte[4096];\r\n                int bytesToRead;\r\n                while((bytesToRead = in.read(buffer)) != -1) {\r\n                    out.write(buffer, 0, bytesToRead);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void fileCopyNIO(String source, String target) throws IOException {\r\n        try (FileInputStream in = new FileInputStream(source)) {\r\n            try (FileOutputStream out = new FileOutputStream(target)) {\r\n                FileChannel inChannel = in.getChannel();\r\n                FileChannel outChannel = out.getChannel();\r\n                ByteBuffer buffer = ByteBuffer.allocate(4096);\r\n                while(inChannel.read(buffer) != -1) {\r\n                    buffer.flip();\r\n                    outChannel.write(buffer);\r\n                    buffer.clear();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n> **注意：**上面用到 Java 7 的 TWR，使用 TWR 后可以不用在 finally 中释放外部资源 ，从而让代码更加优雅。\r\n\r\n**70、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。**\r\n答：代码如下：\r\n\r\n```\r\nimport java.io.BufferedReader;\r\nimport java.io.FileReader;\r\n\r\npublic final class MyUtil {\r\n\r\n    // 工具类中的方法都是静态方式访问的因此将构造器私有不允许创建对象(绝对好习惯)\r\n    private MyUtil() {\r\n        throw new AssertionError();\r\n    }\r\n\r\n    /**\r\n     * 统计给定文件中给定字符串的出现次数\r\n     * \r\n     * @param filename  文件名\r\n     * @param word 字符串\r\n     * @return 字符串在文件中出现的次数\r\n     */\r\n    public static int countWordInFile(String filename, String word) {\r\n        int counter = 0;\r\n        try (FileReader fr = new FileReader(filename)) {\r\n            try (BufferedReader br = new BufferedReader(fr)) {\r\n                String line = null;\r\n                while ((line = br.readLine()) != null) {\r\n                    int index = -1;\r\n                    while (line.length() >= word.length() && (index = line.indexOf(word)) >= 0) {\r\n                        counter++;\r\n                        line = line.substring(index + word.length());\r\n                    }\r\n                }\r\n            }\r\n        } catch (Exception ex) {\r\n            ex.printStackTrace();\r\n        }\r\n        return counter;\r\n    }\r\n\r\n}\r\n```\r\n\r\n**71、如何用 Java 代码列出一个目录下所有的文件？**\r\n答：\r\n如果只要求列出当前文件夹下的文件，代码如下所示：\r\n\r\n```\r\nimport java.io.File;\r\n\r\nclass Test12 {\r\n\r\n    public static void main(String[] args) {\r\n        File f = new File(\"/Users/Hao/Downloads\");\r\n        for(File temp : f.listFiles()) {\r\n            if(temp.isFile()) {\r\n                System.out.println(temp.getName());\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n如果需要对文件夹继续展开，代码如下所示：\r\n\r\n```\r\nimport java.io.File;\r\n\r\nclass Test12 {\r\n\r\n    public static void main(String[] args) {\r\n        showDirectory(new File(\"/Users/Hao/Downloads\"));\r\n    }\r\n\r\n    public static void showDirectory(File f) {\r\n        _walkDirectory(f, 0);\r\n    }\r\n\r\n    private static void _walkDirectory(File f, int level) {\r\n        if(f.isDirectory()) {\r\n            for(File temp : f.listFiles()) {\r\n                _walkDirectory(temp, level + 1);\r\n            }\r\n        }\r\n        else {\r\n            for(int i = 0; i < level - 1; i++) {\r\n                System.out.print(\"\\t\");\r\n            }\r\n            System.out.println(f.getName());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n在 Java 7 中可以使用 NIO.2 的 API 来做同样的事情，代码如下所示：\r\n\r\n```\r\nclass ShowFileTest {\r\n\r\n    public static void main(String[] args) throws IOException {\r\n        Path initPath = Paths.get(\"/Users/Hao/Downloads\");\r\n        Files.walkFileTree(initPath, new SimpleFileVisitor<Path>() {\r\n\r\n            @Override\r\n            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) \r\n                    throws IOException {\r\n                System.out.println(file.getFileName().toString());\r\n                return FileVisitResult.CONTINUE;\r\n            }\r\n\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n**72、用 Java 的套接字编程实现一个多线程的回显（echo）服务器。**\r\n答：\r\n\r\n```\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.PrintWriter;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\n\r\npublic class EchoServer {\r\n\r\n    private static final int ECHO_SERVER_PORT = 6789;\r\n\r\n    public static void main(String[] args) {        \r\n        try(ServerSocket server = new ServerSocket(ECHO_SERVER_PORT)) {\r\n            System.out.println(\"服务器已经启动...\");\r\n            while(true) {\r\n                Socket client = server.accept();\r\n                new Thread(new ClientHandler(client)).start();\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private static class ClientHandler implements Runnable {\r\n        private Socket client;\r\n\r\n        public ClientHandler(Socket client) {\r\n            this.client = client;\r\n        }\r\n\r\n        @Override\r\n        public void run() {\r\n            try(BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream()));\r\n                    PrintWriter pw = new PrintWriter(client.getOutputStream())) {\r\n                String msg = br.readLine();\r\n                System.out.println(\"收到\" + client.getInetAddress() + \"发送的: \" + msg);\r\n                pw.println(msg);\r\n                pw.flush();\r\n            } catch(Exception ex) {\r\n                ex.printStackTrace();\r\n            } finally {\r\n                try {\r\n                    client.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n> **注意：**上面的代码使用了 Java 7 的 TWR 语法，由于很多外部资源类都间接的实现了 AutoCloseable 接口（单方法回调接口），因此可以利用 TWR 语法在 try 结束的时候通过回调的方式自动调用外部资源类的 close() 方法，避免书写冗长的 finally 代码块。此外，上面的代码用一个静态内部类实现线程的功能，使用多线程可以避免一个用户 I/O 操作所产生的中断影响其他用户对服务器的访问，简单的说就是一个用户的输入操作不会造成其他用户的阻塞。当然，上面的代码使用线程池可以获得更好的性能，因为频繁的创建和销毁线程所造成的开销也是不可忽视的。\r\n\r\n下面是一段回显客户端测试代码：\r\n\r\n```\r\nimport java.io.BufferedReader;\r\nimport java.io.InputStreamReader;\r\nimport java.io.PrintWriter;\r\nimport java.net.Socket;\r\nimport java.util.Scanner;\r\n\r\npublic class EchoClient {\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        Socket client = new Socket(\"localhost\", 6789);\r\n        Scanner sc = new Scanner(System.in);\r\n        System.out.print(\"请输入内容: \");\r\n        String msg = sc.nextLine();\r\n        sc.close();\r\n        PrintWriter pw = new PrintWriter(client.getOutputStream());\r\n        pw.println(msg);\r\n        pw.flush();\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream()));\r\n        System.out.println(br.readLine());\r\n        client.close();\r\n    }\r\n}\r\n```\r\n\r\n如果希望用 NIO 的多路复用套接字实现服务器，代码如下所示。NIO 的操作虽然带来了更好的性能，但是有些操作是比较底层的，对于初学者来说还是有些难于理解。\r\n\r\n```\r\nimport java.io.IOException;\r\nimport java.net.InetSocketAddress;\r\nimport java.nio.ByteBuffer;\r\nimport java.nio.CharBuffer;\r\nimport java.nio.channels.SelectionKey;\r\nimport java.nio.channels.Selector;\r\nimport java.nio.channels.ServerSocketChannel;\r\nimport java.nio.channels.SocketChannel;\r\nimport java.util.Iterator;\r\n\r\npublic class EchoServerNIO {\r\n\r\n    private static final int ECHO_SERVER_PORT = 6789;\r\n    private static final int ECHO_SERVER_TIMEOUT = 5000;\r\n    private static final int BUFFER_SIZE = 1024;\r\n\r\n    private static ServerSocketChannel serverChannel = null;\r\n    private static Selector selector = null;    // 多路复用选择器\r\n    private static ByteBuffer buffer = null;    // 缓冲区\r\n\r\n    public static void main(String[] args) {\r\n        init();\r\n        listen();\r\n    }\r\n\r\n    private static void init() {\r\n        try {\r\n            serverChannel = ServerSocketChannel.open();\r\n            buffer = ByteBuffer.allocate(BUFFER_SIZE);\r\n            serverChannel.socket().bind(new InetSocketAddress(ECHO_SERVER_PORT));\r\n            serverChannel.configureBlocking(false);\r\n            selector = Selector.open();\r\n            serverChannel.register(selector, SelectionKey.OP_ACCEPT);\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    private static void listen() {\r\n        while (true) {\r\n            try {\r\n                if (selector.select(ECHO_SERVER_TIMEOUT) != 0) {\r\n                    Iterator<SelectionKey> it = selector.selectedKeys().iterator();\r\n                    while (it.hasNext()) {\r\n                        SelectionKey key = it.next();\r\n                        it.remove();\r\n                        handleKey(key);\r\n                    }\r\n                }\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    private static void handleKey(SelectionKey key) throws IOException {\r\n        SocketChannel channel = null;\r\n\r\n        try {\r\n            if (key.isAcceptable()) {\r\n                ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();\r\n                channel = serverChannel.accept();\r\n                channel.configureBlocking(false);\r\n                channel.register(selector, SelectionKey.OP_READ);\r\n            } else if (key.isReadable()) {\r\n                channel = (SocketChannel) key.channel();\r\n                buffer.clear();\r\n                if (channel.read(buffer) > 0) {\r\n                    buffer.flip();\r\n                    CharBuffer charBuffer = CharsetHelper.decode(buffer);\r\n                    String msg = charBuffer.toString();\r\n                    System.out.println(\"收到\" + channel.getRemoteAddress() + \"的消息：\" + msg);\r\n                    channel.write(CharsetHelper.encode(CharBuffer.wrap(msg)));\r\n                } else {\r\n                    channel.close();\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            if (channel != null) {\r\n                channel.close();\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n```\r\nimport java.nio.ByteBuffer;\r\nimport java.nio.CharBuffer;\r\nimport java.nio.charset.CharacterCodingException;\r\nimport java.nio.charset.Charset;\r\nimport java.nio.charset.CharsetDecoder;\r\nimport java.nio.charset.CharsetEncoder;\r\n\r\npublic final class CharsetHelper {\r\n    private static final String UTF_8 = \"UTF-8\";\r\n    private static CharsetEncoder encoder = Charset.forName(UTF_8).newEncoder();\r\n    private static CharsetDecoder decoder = Charset.forName(UTF_8).newDecoder();\r\n\r\n    private CharsetHelper() {\r\n    }\r\n\r\n    public static ByteBuffer encode(CharBuffer in) throws CharacterCodingException{\r\n        return encoder.encode(in);\r\n    }\r\n\r\n    public static CharBuffer decode(ByteBuffer in) throws CharacterCodingException{\r\n        return decoder.decode(in);\r\n    }\r\n}\r\n```\r\n\r\n**73、XML 文档定义有几种形式？它们之间有何本质区别？解析 XML 文档有哪几种方式？**\r\n答：XML 文档定义分为 DTD 和 Schema 两种形式，二者都是对 XML 语法的约束，其本质区别在于 Schema 本身也是一个 XML 文件，可以被 XML 解析器解析，而且可以为 XML 承载的数据定义类型，约束能力较之 DTD 更强大。对 XML 的解析主要有 DOM（文档对象模型，<u>D</u>ocument <u>O</u>bject <u>M</u>odel）、SAX（<u>S</u>imple <u>A</u>PI for <u>X</u>ML）和 StAX（Java 6 中引入的新的解析 XML 的方式，<u>St</u>reaming <u>A</u>PI for <u>X</u>ML），其中 DOM 处理大型文件时其性能下降的非常厉害，这个问题是由 DOM 树结构占用的内存较多造成的，而且 DOM 解析方式必须在解析文件之前把整个文档装入内存，适合对 XML 的随机访问（典型的用空间换取时间的策略）；SAX 是事件驱动型的 XML 解析方式，它顺序读取 XML 文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过事件回调代码来处理 XML 文件，适合对 XML 的顺序访问；顾名思义，StAX 把重点放在流上，实际上 StAX 与其他解析方式的本质区别就在于应用程序能够把 XML 作为一个事件流来处理。将 XML 作为一组事件来处理的想法并不新颖（SAX 就是这样做的），但不同之处在于 StAX 允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。\r\n\r\n**74、你在项目中哪些地方用到了 XML？**\r\n答：XML 的主要作用有两个方面：数据交换和信息配置。在做数据交换时，XML 将数据用标签组装成起来，然后压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再从 XML 文件中还原相关信息进行处理，XML 曾经是异构系统间交换数据的事实标准，但此项功能几乎已经被 JSON（<u>J</u>ava<u>S</u>cript <u>O</u>bject <u>N</u>otation）取而代之。当然，目前很多软件仍然使用 XML 来存储配置信息，我们在很多项目中通常也会将作为配置信息的硬代码写在 XML 文件中，Java 的很多框架也是这么做的，而且这些框架都选择了 [dom4j](http://www.dom4j.org) 作为处理 XML 的工具，因为 Sun 公司的官方 API 实在不怎么好用。\r\n\r\n> **补充：**现在有很多时髦的软件（如 Sublime）已经开始将配置文件书写成 JSON 格式，我们已经强烈的感受到 XML 的另一项功能也将逐渐被业界抛弃。\r\n\r\n**75、阐述 JDBC 操作数据库的步骤。**\r\n答：下面的代码以连接本机的 Oracle 数据库为例，演示 JDBC 操作数据库的步骤。\r\n\r\n*   加载驱动。\r\n\r\n```\r\n    Class.forName(\"oracle.jdbc.driver.OracleDriver\");\r\n```\r\n\r\n*   创建连接。\r\n\r\n```\r\n    Connection con = DriverManager.getConnection(\"jdbc:oracle:thin:@localhost:1521:orcl\", \"scott\", \"tiger\");\r\n```\r\n\r\n*   创建语句。\r\n\r\n```\r\n    PreparedStatement ps = con.prepareStatement(\"select * from emp where sal between ? and ?\");\r\n    ps.setInt(1, 1000);\r\n    ps.setInt(2, 3000);\r\n```\r\n\r\n*   执行语句。\r\n\r\n```\r\n    ResultSet rs = ps.executeQuery();\r\n```\r\n\r\n*   处理结果。\r\n\r\n```\r\n    while(rs.next()) {\r\n        System.out.println(rs.getInt(\"empno\") + \" - \" + rs.getString(\"ename\"));\r\n    }\r\n```\r\n\r\n*   关闭资源。\r\n\r\n```\r\n    finally {\r\n        if(con != null) {\r\n            try {\r\n                con.close();\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n> **提示：**关闭外部资源的顺序应该和打开的顺序相反，也就是说先关闭 ResultSet、再关闭 Statement、在关闭 Connection。上面的代码只关闭了 Connection（连接），虽然通常情况下在关闭连接时，连接上创建的语句和打开的游标也会关闭，但不能保证总是如此，因此应该按照刚才说的顺序分别关闭。此外，第一步加载驱动在 JDBC 4.0 中是可以省略的（自动从类路径中加载驱动），但是我们建议保留。\r\n\r\n**76、Statement 和 PreparedStatement 有什么区别？哪个性能更好？**\r\n答：与 Statement 相比，①PreparedStatement 接口代表预编译的语句，它主要的优势在于可以减少 SQL 的编译错误并增加 SQL 的安全性（减少 SQL 注射攻击的可能性）；②PreparedStatement 中的 SQL 语句是可以带参数的，避免了用字符串连接拼接 SQL 语句的麻烦和不安全；③当批量处理 SQL 或频繁执行相同的查询时，PreparedStatement 有明显的性能上的优势，由于数据库可以将编译优化后的 SQL 语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）。\r\n\r\n> **补充：**为了提供对存储过程的调用，JDBC API 中还提供了 CallableStatement 接口。存储过程（Stored Procedure）是数据库中一组为了完成特定功能的 SQL 语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦，因为每种数据库的存储过程在书写上存在不少的差别。\r\n\r\n**77、使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？**\r\n答：要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的 setFetchSize() 方法指定每次抓取的记录数（典型的空间换时间策略）；要提升更新数据的性能可以使用 PreparedStatement 语句构建批处理，将若干 SQL 语句置于一个批处理中执行。\r\n\r\n**78、在进行数据库编程时，连接池有什么作用？**\r\n答：由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行 TCP 的三次握手，释放连接需要进行 TCP 四次握手，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在 Java 开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于 Java 的开源数据库连接池主要有：[C3P0](http://sourceforge.net/projects/c3p0/)、[Proxool](http://proxool.sourceforge.net)、[DBCP](http://commons.apache.org/proper/commons-dbcp/)、[BoneCP](https://github.com/wwadge/bonecp)、[Druid](https://github.com/alibaba/druid) 等。\r\n\r\n> **补充：**在计算机系统中时间和空间是不可调和的矛盾，理解这一点对设计满足性能要求的算法是至关重要的。大型网站性能优化的一个关键就是使用缓存，而缓存跟上面讲的连接池道理非常类似，也是使用空间换时间的策略。可以将热点数据置于缓存中，当用户查询这些数据时可以直接从缓存中得到，这无论如何也快过去数据库中查询。当然，缓存的置换策略等也会对系统性能产生重要影响，对于这个问题的讨论已经超出了这里要阐述的范围。\r\n\r\n**79、什么是 DAO 模式？**\r\n答：DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共 API 中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO 模式实际上包含了两个模式，一是 Data Accessor（数据访问器），二是 Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。\r\n\r\n**80、事务的 ACID 是指什么？**\r\n答：\r\n- 原子性 (Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败；\r\n- 一致性 (Consistent)：事务结束后系统状态是一致的；\r\n- 隔离性 (Isolated)：并发执行的事务彼此无法看到对方的中间状态；\r\n- 持久性 (Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。\r\n\r\n> **补充：**关于事务，在面试中被问到的概率是很高的，可以问的问题也是很多的。首先需要知道的是，只有存在并发数据访问时才需要事务。当多个事务访问同一数据时，可能会存在 5 类问题，包括 3 类数据读取问题（脏读、不可重复读和幻读）和 2 类数据更新问题（第 1 类丢失更新和第 2 类丢失更新）。\r\n\r\n脏读（Dirty Read）：A 事务读取 B 事务尚未提交的数据并在此基础上操作，而 B 事务执行回滚，那么 A 读取到的数据就是脏数据。\r\n\r\n| 时间 | 转账事务 A | 取款事务 B |\r\n| :--: | :--: | :--: |\r\n| T1 |   | 开始事务 |\r\n| T2 | 开始事务 |   |\r\n| T3 |   | 查询账户余额为 1000 元 |\r\n| T4 |   | 取出 500 元余额修改为 500 元 |\r\n| T5 | 查询账户余额为 500 元（脏读） |   |\r\n| T6 |   | 撤销事务余额恢复为 1000 元 |\r\n| T7 | 汇入 100 元把余额修改为 600 元 |   |\r\n| T8 | 提交事务 |   |\r\n\r\n* * *\r\n\r\n不可重复读（Unrepeatable Read）：事务 A 重新读取前面读取过的数据，发现该数据已经被另一个已提交的事务 B 修改过了。\r\n\r\n| 时间 | 转账事务 A | 取款事务 B |\r\n| :--: | :--: | :--: |\r\n| T1 |   | 开始事务 |\r\n| T2 | 开始事务 |   |\r\n| T3 |   | 查询账户余额为 1000 元 |\r\n| T4 | 查询账户余额为 1000 元 |   |\r\n| T5 |   | 取出 100 元修改余额为 900 元 |\r\n| T6 |   | 提交事务 |\r\n| T7 | 查询账户余额为 900 元（不可重复读） |   |\r\n\r\n* * *\r\n\r\n幻读（Phantom Read）：事务 A 重新执行一个查询，返回一系列符合查询条件的行，发现其中插入了被事务 B 提交的行。\r\n\r\n| 时间 | 统计金额事务 A | 转账事务 B |\r\n| :--: | :--: | :--: |\r\n| T1 |   | 开始事务 |\r\n| T2 | 开始事务 |   |\r\n| T3 | 统计总存款为 10000 元 |   |\r\n| T4 |   | 新增一个存款账户存入 100 元 |\r\n| T5 |   | 提交事务 |\r\n| T6 | 再次统计总存款为 10100 元（幻读） |   |\r\n\r\n* * *\r\n\r\n第 1 类丢失更新：事务 A 撤销时，把已经提交的事务 B 的更新数据覆盖了。\r\n\r\n| 时间 | 取款事务 A | 转账事务 B |\r\n| :--: | :--: | :--: |\r\n| T1 | 开始事务 |   |\r\n| T2 |   | 开始事务 |\r\n| T3 | 查询账户余额为 1000 元 |   |\r\n| T4 |   | 查询账户余额为 1000 元 |\r\n| T5 |   | 汇入 100 元修改余额为 1100 元 |\r\n| T6 |   | 提交事务 |\r\n| T7 | 取出 100 元将余额修改为 900 元 |   |\r\n| T8 | 撤销事务 |   |\r\n| T9 | 余额恢复为 1000 元（丢失更新） |   |\r\n\r\n* * *\r\n\r\n第 2 类丢失更新：事务 A 覆盖事务 B 已经提交的数据，造成事务 B 所做的操作丢失。\r\n\r\n| 时间 | 转账事务 A | 取款事务 B |\r\n| :--: | :--: | :--: |\r\n| T1 |   | 开始事务 |\r\n| T2 | 开始事务 |   |\r\n| T3 |   | 查询账户余额为 1000 元 |\r\n| T4 | 查询账户余额为 1000 元 |   |\r\n| T5 |   | 取出 100 元将余额修改为 900 元 |\r\n| T6 |   | 提交事务 |\r\n| T7 | 汇入 100 元将余额修改为 1100 元 |   |\r\n| T8 | 提交事务 |   |\r\n| T9 | 查询账户余额为 1100 元（丢失更新） |   |\r\n\r\n* * *\r\n\r\n数据并发访问所产生的问题，在有些场景下可能是允许的，但是有些场景下可能就是致命的，数据库通常会通过锁机制来解决数据并发访问问题，按锁定对象不同可以分为表级锁和行级锁；按并发事务锁定关系可以分为共享锁和独占锁，具体的内容大家可以自行查阅资料进行了解。\r\n直接使用锁是非常麻烦的，为此数据库为用户提供了自动锁机制，只要用户指定会话的事务隔离级别，数据库就会通过分析 SQL 语句然后为事务访问的资源加上合适的锁，此外，数据库还会维护这些锁通过各种手段提高系统的性能，这些对用户来说都是透明的（就是说你不用理解，事实上我确实也不知道）。ANSI/ISO SQL 92 标准定义了 4 个等级的事务隔离级别，如下表所示：\r\n\r\n| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 第一类丢失更新 | 第二类丢失更新 |\r\n| :--: | :--: | :--: | :--: | :--: | :--: |\r\n| READ UNCOMMITED | 允许 | 允许 | 允许 | 不允许 | 允许 |\r\n| READ COMMITTED | 不允许 | 允许 | 允许 | 不允许 | 允许 |\r\n| REPEATABLE READ | 不允许 | 不允许 | 允许 | 不允许 | 不允许 |\r\n| SERIALIZABLE | 不允许 | 不允许 | 不允许 | 不允许 | 不允许 |\r\n\r\n需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没有万能的原则。\r\n\r\n**81、JDBC 中如何进行事务处理？**\r\n答：Connection 提供了事务处理的方法，通过调用 setAutoCommit(false) 可以设置手动提交事务；当事务完成后用 commit() 显式提交事务；如果在事务处理过程中发生异常则通过 rollback() 进行事务回滚。除此之外，从 JDBC 3.0 中还引入了 Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。\r\n![](https://img-blog.csdn.net/20150408174308284)\r\n\r\n**82、JDBC 能否处理 Blob 和 Clob？**\r\n答： Blob 是指二进制大对象（Binary Large Object），而 Clob 是指大字符对象（Character Large Objec），因此其中 Blob 是为存储大的二进制数据而设计的，而 Clob 是为存储大的文本数据而设计的。JDBC 的 PreparedStatement 和 ResultSet 都提供了相应的方法来支持 Blob 和 Clob 操作。下面的代码展示了如何使用 JDBC 操作 LOB：\r\n下面以 MySQL 数据库为例，创建一个张有三个字段的用户表，包括编号（id）、姓名（name）和照片（photo），建表语句如下：\r\n\r\n```\r\ncreate table tb_user\r\n(\r\nid int primary key auto_increment,\r\nname varchar(20) unique not null,\r\nphoto longblob\r\n);\r\n```\r\n\r\n下面的 Java 代码向数据库中插入一条记录：\r\n\r\n```\r\nimport java.io.FileInputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.sql.Connection;\r\nimport java.sql.DriverManager;\r\nimport java.sql.PreparedStatement;\r\nimport java.sql.SQLException;\r\n\r\nclass JdbcLobTest {\r\n\r\n    public static void main(String[] args) {\r\n        Connection con = null;\r\n        try {\r\n            // 1\\. 加载驱动（Java6以上版本可以省略）\r\n            Class.forName(\"com.mysql.jdbc.Driver\");\r\n            // 2\\. 建立连接\r\n            con = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/test\", \"root\", \"123456\");\r\n            // 3\\. 创建语句对象\r\n            PreparedStatement ps = con.prepareStatement(\"insert into tb_user values (default, ?, ?)\");\r\n            ps.setString(1, \"骆昊\");              // 将SQL语句中第一个占位符换成字符串\r\n            try (InputStream in = new FileInputStream(\"test.jpg\")) {    // Java 7的TWR\r\n                ps.setBinaryStream(2, in);      // 将SQL语句中第二个占位符换成二进制流\r\n                // 4\\. 发出SQL语句获得受影响行数\r\n                System.out.println(ps.executeUpdate() == 1 ? \"插入成功\" : \"插入失败\");\r\n            } catch(IOException e) {\r\n                System.out.println(\"读取照片失败!\");\r\n            }\r\n        } catch (ClassNotFoundException | SQLException e) {     // Java 7的多异常捕获\r\n            e.printStackTrace();\r\n        } finally { // 释放外部资源的代码都应当放在finally中保证其能够得到执行\r\n            try {\r\n                if(con != null && !con.isClosed()) {\r\n                    con.close();    // 5\\. 释放数据库连接 \r\n                    con = null;     // 指示垃圾回收器可以回收该对象\r\n                }\r\n            } catch (SQLException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**83、简述正则表达式及其用途。**\r\n答：在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。\r\n\r\n> **说明：**计算机诞生初期处理的信息几乎都是数值，但是时过境迁，今天我们使用计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大的工具，绝大多数语言都提供了对正则表达式的支持。\r\n\r\n**84、Java 中是如何支持正则表达式操作的？**\r\n答：Java 中的 String 类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java 中可以用 Pattern 类表示正则表达式对象，它提供了丰富的 API 进行各种正则表达式操作，请参考下面面试题的代码。\r\n\r\n> **面试题：** - 如果要从字符串中截取第一个英文左括号之前的字符串，例如：北京市 (朝阳区)(西城区)(海淀区)，截取结果为：北京市，那么正则表达式怎么写？\r\n\r\n```\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\nclass RegExpTest {\r\n\r\n    public static void main(String[] args) {\r\n        String str = \"北京市(朝阳区)(西城区)(海淀区)\";\r\n        Pattern p = Pattern.compile(\".*?(?=\\\\()\");\r\n        Matcher m = p.matcher(str);\r\n        if(m.find()) {\r\n            System.out.println(m.group());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n> **说明：**上面的正则表达式中使用了懒惰匹配和前瞻，如果不清楚这些内容，推荐读一下网上很有名的[《正则表达式 30 分钟入门教程》](http://www.jb51.net/tools/zhengze.html)。\r\n\r\n**85、获得一个类的类对象有哪些方式？**\r\n答：\r\n- 方法 1：类型. class，例如：String.class\r\n- 方法 2：对象. getClass()，例如：\"hello\".getClass()\r\n- 方法 3：Class.forName()，例如：Class.forName(\"java.lang.String\")\r\n\r\n**86、如何通过反射创建对象？**\r\n答：\r\n- 方法 1：通过类对象调用 newInstance() 方法，例如：String.class.newInstance()\r\n- 方法 2：通过类对象的 getConstructor() 或 getDeclaredConstructor() 方法获得构造器（Constructor）对象并调用其 newInstance() 方法创建对象，例如：String.class.getConstructor(String.class).newInstance(\"Hello\");\r\n\r\n**87、如何通过反射获取和设置对象私有字段的值？**\r\n答：可以通过类对象的 getDeclaredField() 方法字段（Field）对象，然后再通过字段对象的 setAccessible(true) 将其设置为可以访问，接下来就可以通过 get/set 方法来获取 / 设置字段的值了。下面的代码实现了一个反射的工具类，其中的两个静态方法分别用于获取和设置私有字段的值，字段可以是基本类型也可以是对象类型且支持多级对象操作，例如 ReflectionUtil.get(dog, \"owner.car.engine.id\"); 可以获得 dog 对象的主人的汽车的引擎的 ID 号。\r\n\r\n```\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.Modifier;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * 反射工具类\r\n * @author 骆昊\r\n *\r\n */\r\npublic class ReflectionUtil {\r\n\r\n    private ReflectionUtil() {\r\n        throw new AssertionError();\r\n    }\r\n\r\n    /**\r\n     * 通过反射取对象指定字段(属性)的值\r\n     * @param target 目标对象\r\n     * @param fieldName 字段的名字\r\n     * @throws 如果取不到对象指定字段的值则抛出异常\r\n     * @return 字段的值\r\n     */\r\n    public static Object getValue(Object target, String fieldName) {\r\n        Class<?> clazz = target.getClass();\r\n        String[] fs = fieldName.split(\"\\\\.\");\r\n\r\n        try {\r\n            for(int i = 0; i < fs.length - 1; i++) {\r\n                Field f = clazz.getDeclaredField(fs[i]);\r\n                f.setAccessible(true);\r\n                target = f.get(target);\r\n                clazz = target.getClass();\r\n            }\r\n\r\n            Field f = clazz.getDeclaredField(fs[fs.length - 1]);\r\n            f.setAccessible(true);\r\n            return f.get(target);\r\n        }\r\n        catch (Exception e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 通过反射给对象的指定字段赋值\r\n     * @param target 目标对象\r\n     * @param fieldName 字段的名称\r\n     * @param value 值\r\n     */\r\n    public static void setValue(Object target, String fieldName, Object value) {\r\n        Class<?> clazz = target.getClass();\r\n        String[] fs = fieldName.split(\"\\\\.\");\r\n        try {\r\n            for(int i = 0; i < fs.length - 1; i++) {\r\n                Field f = clazz.getDeclaredField(fs[i]);\r\n                f.setAccessible(true);\r\n                Object val = f.get(target);\r\n                if(val == null) {\r\n                    Constructor<?> c = f.getType().getDeclaredConstructor();\r\n                    c.setAccessible(true);\r\n                    val = c.newInstance();\r\n                    f.set(target, val);\r\n                }\r\n                target = val;\r\n                clazz = target.getClass();\r\n            }\r\n\r\n            Field f = clazz.getDeclaredField(fs[fs.length - 1]);\r\n            f.setAccessible(true);\r\n            f.set(target, value);\r\n        }\r\n        catch (Exception e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n**88、如何通过反射调用对象的方法？**\r\n答：请看下面的代码：\r\n\r\n```\r\nimport java.lang.reflect.Method;\r\n\r\nclass MethodInvokeTest {\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        String str = \"hello\";\r\n        Method m = str.getClass().getMethod(\"toUpperCase\");\r\n        System.out.println(m.invoke(str));  // HELLO\r\n    }\r\n}\r\n```\r\n\r\n**89、简述一下面向对象的 \"六原则一法则\"。**\r\n答：\r\n- 单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是 \"高内聚\"，写代码最终极的原则只有六个字 \"高内聚、低耦合\"，就如同葵花宝典或辟邪剑谱的中心思想就八个字 \"欲练此功必先自宫\"，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。我们都知道一句话叫 \"因为专注，所以专业\"，一个对象如果承担太多的职责，那么注定它什么都做不好。这个世界上任何好的东西都有两个特征，一个是功能单一，好的相机绝对不是电视购物里面卖的那种一个机器有一百多种功能的，它基本上只能照相；另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。）\r\n- 开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）\r\n- 依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）\r\n里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov 女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）\r\n- 接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java 中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）\r\n- 合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A 关系、Has-A 关系、Use-A 关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是 Has-A 关系，合成聚合复用原则想表达的是优先考虑 Has-A 关系而不是 Is-A 关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在 Java 的 API 中也有不少滥用继承的例子，例如 Properties 类继承了 Hashtable 类，Stack 类继承了 Vector 类，这些继承明显就是错误的，更好的做法是在 Properties 类中放置一个 Hashtable 类型的成员并且将其键和值都设置为字符串来存储数据，而 Stack 类的设计也应该是在 Stack 类中放一个 Vector 对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）\r\n- 迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。（迪米特法则简单的说就是如何做到 \"低耦合\"，门面模式和调停者模式就是对迪米特法则的践行。对于门面模式可以举一个简单的例子，你去一家公司洽谈业务，你不需要了解这个公司内部是如何运作的，你甚至可以对这个公司一无所知，去的时候只需要找到公司入口处的前台美女，告诉她们你要做什么，她们会找到合适的人跟你接洽，前台的美女就是公司这个系统的门面。再复杂的系统都可以为用户提供一个简单的门面，Java Web 开发中作为前端控制器的 Servlet 或 Filter 不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度，如下图所示。迪米特法则用通俗的话来将就是不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。）\r\n\r\n![](https://img-blog.csdn.net/20150408153246930)\r\n![](https://img-blog.csdn.net/20150408153213362)\r\n\r\n**90、简述一下你了解的设计模式。**\r\n答：所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一个解决方案）。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。\r\n在 GoF 的《Design Patterns: Elements of Reusable Object-Oriented Software》中给出了三类（创建型 [对类的实例化过程的抽象化]、结构型 [描述如何将类或对象结合在一起形成更大的结构]、行为型 [对在不同的对象之间划分责任和算法的抽象化]）共 23 种设计模式，包括：Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibility（责任链模式）。\r\n面试被问到关于设计模式的知识时，可以拣最常用的作答，例如：\r\n- 工厂模式：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。\r\n- 代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可以分为：远程代理、虚拟代理、保护代理、Cache 代理、防火墙代理、同步化代理、智能引用代理。\r\n- 适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。\r\n- 模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。\r\n除此之外，还可以讲讲上面提到的门面模式、桥梁模式、单例模式、装潢模式（Collections 工具类和 I/O 系统中都使用装潢模式）等，反正基本原则就是拣自己最熟悉的、用得最多的作答，以免言多必失。\r\n\r\n**91、用 Java 写一个单例类。**\r\n答：\r\n- 饿汉式单例\r\n\r\n```\r\npublic class Singleton {\r\n    private Singleton(){}\r\n    private static Singleton instance = new Singleton();\r\n    public static Singleton getInstance(){\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n*   懒汉式单例\r\n\r\n```\r\npublic class Singleton {\r\n    private static Singleton instance = null;\r\n    private Singleton() {}\r\n    public static synchronized Singleton getInstance(){\r\n        if (instance == null) instance ＝ new Singleton();\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n> **注意：**实现一个单例有两点注意事项，①将构造器私有，不允许外界通过构造器创建对象；②通过公开的静态方法向外界返回类的唯一实例。这里有一个问题可以思考：Spring 的 IoC 容器可以为普通的类创建单例，它是怎么做到的呢？\r\n\r\n**92、什么是 UML？**\r\n答：UML 是统一建模语言（Unified Modeling Language）的缩写，它发表于 1997 年，综合了当时已经存在的面向对象的建模语言、方法和过程，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。使用 UML 可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为。\r\n\r\n**93、UML 中有哪些常用的图？**\r\n答：UML 定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等。在这些图形化符号中，有三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。\r\n用例图：\r\n![](https://img-blog.csdn.net/20150408151744237)\r\n类图：\r\n![](https://img-blog.csdn.net/20150408151843748)\r\n时序图：\r\n![](https://img-blog.csdn.net/20150408153230144)\r\n\r\n**94、用 Java 写一个冒泡排序。**\r\n答：冒泡排序几乎是个程序员都写得出来，但是面试的时候如何写一个逼格高的冒泡排序却不是每个人都能做到，下面提供一个参考代码：\r\n\r\n```\r\nimport java.util.Comparator;\r\n\r\n/**\r\n * 排序器接口(策略模式: 将算法封装到具有共同接口的独立的类中使得它们可以相互替换)\r\n * @author骆昊\r\n *\r\n */\r\npublic interface Sorter {\r\n\r\n   /**\r\n    * 排序\r\n    * @param list 待排序的数组\r\n    */\r\n   public <T extends Comparable<T>> void sort(T[] list);\r\n\r\n   /**\r\n    * 排序\r\n    * @param list 待排序的数组\r\n    * @param comp 比较两个对象的比较器\r\n    */\r\n   public <T> void sort(T[] list, Comparator<T> comp);\r\n}\r\n```\r\n\r\n```\r\nimport java.util.Comparator;\r\n\r\n/**\r\n * 冒泡排序\r\n * \r\n * @author骆昊\r\n *\r\n */\r\npublic class BubbleSorter implements Sorter {\r\n\r\n    @Override\r\n    public <T extends Comparable<T>> void sort(T[] list) {\r\n        boolean swapped = true;\r\n        for (int i = 1, len = list.length; i < len && swapped; ++i) {\r\n            swapped = false;\r\n            for (int j = 0; j < len - i; ++j) {\r\n                if (list[j].compareTo(list[j + 1]) > 0) {\r\n                    T temp = list[j];\r\n                    list[j] = list[j + 1];\r\n                    list[j + 1] = temp;\r\n                    swapped = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public <T> void sort(T[] list, Comparator<T> comp) {\r\n        boolean swapped = true;\r\n        for (int i = 1, len = list.length; i < len && swapped; ++i) {\r\n            swapped = false;\r\n            for (int j = 0; j < len - i; ++j) {\r\n                if (comp.compare(list[j], list[j + 1]) > 0) {\r\n                    T temp = list[j];\r\n                    list[j] = list[j + 1];\r\n                    list[j + 1] = temp;\r\n                    swapped = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**95、用 Java 写一个折半查找。**\r\n答：折半查找，也称二分查找、二分搜索，是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组已经为空，则表示找不到指定的元素。这种搜索算法每一次比较都使搜索范围缩小一半，其时间复杂度是 O(logN)。\r\n\r\n```\r\nimport java.util.Comparator;\r\n\r\npublic class MyUtil {\r\n\r\n   public static <T extends Comparable<T>> int binarySearch(T[] x, T key) {\r\n      return binarySearch(x, 0, x.length- 1, key);\r\n   }\r\n\r\n   // 使用循环实现的二分查找\r\n   public static <T> int binarySearch(T[] x, T key, Comparator<T> comp) {\r\n      int low = 0;\r\n      int high = x.length - 1;\r\n      while (low <= high) {\r\n          int mid = (low + high) >>> 1;\r\n          int cmp = comp.compare(x[mid], key);\r\n          if (cmp < 0) {\r\n            low= mid + 1;\r\n          }\r\n          else if (cmp > 0) {\r\n            high= mid - 1;\r\n          }\r\n          else {\r\n            return mid;\r\n          }\r\n      }\r\n      return -1;\r\n   }\r\n\r\n   // 使用递归实现的二分查找\r\n   private static<T extends Comparable<T>> int binarySearch(T[] x, int low, int high, T key) {\r\n      if(low <= high) {\r\n        int mid = low + ((high -low) >> 1);\r\n        if(key.compareTo(x[mid])== 0) {\r\n           return mid;\r\n        }\r\n        else if(key.compareTo(x[mid])< 0) {\r\n           return binarySearch(x,low, mid - 1, key);\r\n        }\r\n        else {\r\n           return binarySearch(x,mid + 1, high, key);\r\n        }\r\n      }\r\n      return -1;\r\n   }\r\n}\r\n```\r\n\r\n> **说明：**上面的代码中给出了折半查找的两个版本，一个用递归实现，一个用循环实现。需要注意的是计算中间位置时不应该使用 (high+ low) / 2 的方式，因为加法运算可能导致整数越界，这里应该使用以下三种方式之一：low + (high - low) / 2 或 low + (high – low) >> 1 或(low + high) >>> 1（>>> 是逻辑右移，是不带符号位的右移）\r\n\r\n<link href=\"https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7b4cdcb592.css\" rel=\"stylesheet\"> <sr-plugin-count>共计：80481 个字</sr-plugin-count>',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,2),(28,'effective-java 第三章：对于所有对象都通用的方法','28',1550648400,1550651462,'<!--markdown-->## [](#覆盖-equals-时请遵守通用约定 \"覆盖 equals 时请遵守通用约定\")覆盖 equals 时请遵守通用约定\r\n\r\n1.  类的每个实例本质上都是唯一的。\r\n2.  不关心类是否提供了 “逻辑相等” 的测试功能。\r\n3.  超类以及覆盖了 equals，从超类继承过来的行为对于子类也是合适的。\r\n4.  雷蛇私有的或是包级私有的，可以确定它的 equals 方法永远不会被调用。\r\n\r\n### [](#equals-的通用规定 \"equals 的通用规定\")equals 的通用规定\r\n\r\n*   自反性 `x.equals(x) == true`\r\n*   对称性 `x.equals(y) = true -> y.equals(x)`\r\n*   传递性 `x.equals(y) & y.equals(z) -> x.equals(z)`\r\n*   一致性 `x，y没修改时，x.equals(y) 一直成立`\r\n*   非 null `x != null -> x.equals(null) = false`\r\n\r\n## [](#覆盖-equals-时总要覆盖-hashCode \"覆盖 equals 时总要覆盖 hashCode\")覆盖 equals 时总要覆盖 hashCode\r\n\r\n不然该列所有基于散列的集合（HashMap,HashSet,HashTable）将无法正常工作\r\n\r\n*   相同的对象 hashCode 必须要相等\r\n*   不同的对象 hashCode 不一定得不相同（不相同也许可以提高散列表 hash table 的性能）\r\n\r\n## [](#始终要覆盖-toString \"始终要覆盖 toString\")始终要覆盖 toString\r\n\r\n*   toString 会在使用 printf，字符串相加，assert 或者调试器时被自动调用。提高良好的 toString 实现跨越使类使用起来更舒服。\r\n*   toString 应该包含所有值得关注的值。\r\n*   可以给 toString 设定一种格式，但设定好后一定要严格遵守并在文档中写清楚。\r\n\r\n## [](#谨慎的覆盖-clone \"谨慎的覆盖 clone\")谨慎的覆盖 clone\r\n\r\n## [](#考虑实现-Comparable-接口 \"考虑实现 Comparable 接口\")考虑实现 Comparable 接口\r\n\r\n<sr-plugin-count>共计：704 个字</sr-plugin-count>',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,0),(29,'effective-java 第二章：创建和销毁对象','29',1550648460,1550651455,'<!--markdown-->## [](#使用静态工厂方法代替构造器 \"使用静态工厂方法代替构造器\")使用静态工厂方法代替构造器\r\n\r\n### [](#好处： \"好处：\")好处：\r\n\r\n*   静态工厂有名字。\r\n    静态工厂的名字可以更清晰的描述返回的对象，比较构造器参数\r\n    例如:`BigInteger.probablePrime(int bitLength,Random rnd)返回一个素数`\r\n    需要多个构造器返回多个类型时，只能靠参数识别，开发人员难以记住。而静态工厂方法靠函数名就知道返回的大概内容了。\r\n\r\n*   静态工厂方法不必每次调用都创建一个新对象。\r\n    可以重复利用对象，免去创建多个相同对象的资源消耗（内存和时间）。\r\n    可以保证单例。\r\n    可使不可变类不存在两个相同的实例，使当且仅当 `a==b` 才存在 `a.equals(b) == true` ，例如，两个 String 必须要指向同一个，他们才能内容相同。这样做能使用 == 代替 equals() , 直接通过 HashCode 来判断是否相同，提高性能。枚举类（enum）就是这么做的。\r\n\r\n*   静态工厂方法可以返回任意子类型的对象。\r\n    API 可以返回对象，同时又不会使对象的类变为公有的。这种方式可以隐藏实现类。例如 Java 的集合类（Collections）。\r\n    客户端通过接口来使用实现类，可以隐藏具体的实现类，API 变更时用户不受任何影响。\r\n\r\n*   创建对象时代码可以更简洁。\r\n\r\n### [](#缺点： \"缺点：\")缺点：\r\n\r\n*   类如果不含公有的或者受保护的构造器，就不能子类化。\r\n\r\n*   与其他静态方法没任何区别，在 API 文档中查找比较困难。\r\n\r\n## [](#遇到多个构造器参数时要考虑使用构建器 \"遇到多个构造器参数时要考虑使用构建器\")遇到多个构造器参数时要考虑使用构建器\r\n\r\n### [](#反模式Antipattern \"反模式Antipattern\")反模式 Antipattern\r\n\r\n*   层叠构造器\r\n    缺点：参数多时难以编写和阅读\r\n    [![](https://lh3.googleusercontent.com/-ig3L5v8MEXQ/W-vryP6XSqI/AAAAAAAAEBc/P-zBaAnuumoqaArhX2IkBiVkxGkzkQzAwCHMYCw/I/%255BUNSET%255D)](https://lh3.googleusercontent.com/-ig3L5v8MEXQ/W-vryP6XSqI/AAAAAAAAEBc/P-zBaAnuumoqaArhX2IkBiVkxGkzkQzAwCHMYCw/I/%255BUNSET%255D)\r\n\r\n*   setter() 方法设置参数\r\n    麻烦，而且暴露了 setter() 参数不安全。\r\n\r\n### [](#解决方法 \"解决方法\")解决方法\r\n\r\n*   Builder 模式\r\n    不直接生成对象，而是利用所有提供的参数来调用对应的静态工厂，得到一个 builder 对象，然后调用对象的 sette\r\n    r 来设置参数。\r\n\r\n实现：\r\n[![](https://lh3.googleusercontent.com/-nBzQNLiGmLE/W-vsjw4N5PI/AAAAAAAAEB4/AVHH8BIfe4YIsooymuPLkVdYawytBVrIgCHMYCw/I/15421881717779.jpg)](https://lh3.googleusercontent.com/-nBzQNLiGmLE/W-vsjw4N5PI/AAAAAAAAEB4/AVHH8BIfe4YIsooymuPLkVdYawytBVrIgCHMYCw/I/15421881717779.jpg)\r\n[![](https://lh3.googleusercontent.com/-oNoJlX9Eztg/W-vrsGdKlXI/AAAAAAAAEBU/PEI_4UyOua0CtegOZgI1baSyZmQgPbe1wCHMYCw/I/15421153532567.jpg)](https://lh3.googleusercontent.com/-oNoJlX9Eztg/W-vrsGdKlXI/AAAAAAAAEBU/PEI_4UyOua0CtegOZgI1baSyZmQgPbe1wCHMYCw/I/15421153532567.jpg)\r\n调用：\r\n[![](https://lh3.googleusercontent.com/-FsOuvvIsXEk/W-vrsfqaI1I/AAAAAAAAEBY/PqWx0YzmDnEcOu3ssqlQnbzjbIeu9tiSwCHMYCw/I/15421153995393.jpg)](https://lh3.googleusercontent.com/-FsOuvvIsXEk/W-vrsfqaI1I/AAAAAAAAEBY/PqWx0YzmDnEcOu3ssqlQnbzjbIeu9tiSwCHMYCw/I/15421153995393.jpg)\r\n\r\n### [](#不足： \"不足：\")不足：\r\n\r\n*   创建对象必须先创建它的构建起，需要一定的开销。\r\n*   代码多。\r\n\r\n### [](#总结： \"总结：\")总结：\r\n\r\n如果类的构造器或静态工厂具有多个参数时（4 个以上），设计这种类使用 Builder 模式更好，它比重叠构造器更易于阅读编写，比 setter 更安全。\r\n\r\n## [](#使用私有构造器或枚举类型强化-Singleton-属性 \"使用私有构造器或枚举类型强化 Singleton 属性\")使用私有构造器或枚举类型强化 Singleton 属性\r\n\r\n### [](#公有静态成员是个-final-域 \"公有静态成员是个 final 域\")公有静态成员是个 final 域\r\n\r\n<pre>// Singleton with public final field\r\npublic class Elvis {\r\n    public static final Elvis INSTANCE = new Elvis();\r\n    private Elvis(){...}\r\n    public void leaveTheBuilding(){...}\r\n}\r\n</pre>\r\n\r\nINSTANCE 实例全局唯一，但通过反射机制仍可调用私有构造函数生成新实例。\r\n\r\n### [](#公有成员是静态工厂方法（类似于设计模式-——-单例模式） \"公有成员是静态工厂方法（类似于设计模式 —— 单例模式）\")公有成员是静态工厂方法（类似于设计模式 —— 单例模式）\r\n\r\n<pre>// Singleton with static factory\r\npublic class Elvis {\r\n    private static final Elvis INSTANCE = new Elvis();\r\n    private Elvis(){...}\r\n    public static Elvis getInstance() { return INSTANCE; }\r\n    public void leaveTheBuilding(){...}\r\n}\r\n</pre>\r\n\r\n该方法提供了灵活性，可以在不改变 API 的情况下，控制是否单例。第二个是可以返回到一个泛型。\r\n但在序列化和反序列化时会存在一些问题。\r\n\r\n### [](#编写一个包含单个元素的枚举类（最佳实现） \"编写一个包含单个元素的枚举类（最佳实现）\")编写一个包含单个元素的枚举类（最佳实现）\r\n\r\n<pre>// Enum singleton - the preferred approach\r\npublic enum Elvis {\r\n    INSTANCE;\r\n    public void leaveTheBuilding(){...}\r\n}\r\n</pre>\r\n\r\n该方法和 final 域相似，但是自带了序列化，绝对防止多次实例化，即便是反序列或者使用发射机制攻击。\r\n\r\n## [](#对工具类设置私有构造函数 \"对工具类设置私有构造函数\")对工具类设置私有构造函数\r\n\r\n## [](#避免创建不必要的对象 \"避免创建不必要的对象\")避免创建不必要的对象\r\n\r\n如使用 `String s = “aaa”;` 代替 `String s = new String(“aaa”);`，后者每次都会生成一个新实例。\r\n\r\n## [](#消除过期对象引用 \"消除过期对象引用\")消除过期对象引用\r\n\r\n过期对象引用会导致内存泄漏。\r\n\r\n### [](#三个常见的内存泄漏 \"三个常见的内存泄漏\")三个常见的内存泄漏\r\n\r\n1.  类管理自己的内存\r\n2.  缓存\r\n3.  监听器和其他回调\r\n\r\n### [](#详细内容（书本引用-21页-23页）： \"详细内容（书本引用 21页-23页）：\")详细内容（书本引用 21 页 - 23 页）：\r\n\r\n[![](https://lh3.googleusercontent.com/-VuQtiZn9EzM/W-vjU5BbgJI/AAAAAAAAEAY/t9sN-h5MXOcIz_pgQ8njGcdnxSWuZQQqQCHMYCw/I/%255BUNSET%255D)](https://lh3.googleusercontent.com/-VuQtiZn9EzM/W-vjU5BbgJI/AAAAAAAAEAY/t9sN-h5MXOcIz_pgQ8njGcdnxSWuZQQqQCHMYCw/I/%255BUNSET%255D)\r\n[![](https://lh3.googleusercontent.com/-qjH0-kqNm2Y/W-vja6eYJCI/AAAAAAAAEAc/-KZPbmN5gMEpVNQNVcWck9Ymz1eYa3DAACHMYCw/I/%255BUNSET%255D)](https://lh3.googleusercontent.com/-qjH0-kqNm2Y/W-vja6eYJCI/AAAAAAAAEAc/-KZPbmN5gMEpVNQNVcWck9Ymz1eYa3DAACHMYCw/I/%255BUNSET%255D)\r\n[![](https://lh3.googleusercontent.com/-BAwsu0lCPXg/W-vjelYCR0I/AAAAAAAAEAg/9ZfMX2i4JAMQciQl4ZmEDctVEQxFep9lQCHMYCw/I/%255BUNSET%255D)](https://lh3.googleusercontent.com/-BAwsu0lCPXg/W-vjelYCR0I/AAAAAAAAEAg/9ZfMX2i4JAMQciQl4ZmEDctVEQxFep9lQCHMYCw/I/%255BUNSET%255D)\r\n\r\n## [](#避免使用终结方法（finalizer） \"避免使用终结方法（finalizer）\")避免使用终结方法（finalizer）\r\n\r\njava 规范不保证终结方法的及时运行，甚至不保证它的运行。可能程序结束时还有终结方法未执行。\r\n\r\n终结方法影响性能，使用终结方法创建和销毁对象大概慢了 430 倍（作者的测试）。\r\n\r\n对于一些资源的释放，最好显式的释放\r\n\r\n### [](#原文引用（感觉无法归纳，orz） \"原文引用（感觉无法归纳，orz）\")原文引用（感觉无法归纳，orz）\r\n\r\n[![](https://lh3.googleusercontent.com/-ekYLE9xkzKc/W-vop4dVmlI/AAAAAAAAEA0/Oydu-uheHsosOkjQ3R7XxknBZWGIs5heQCHMYCw/I/%255BUNSET%255D)](https://lh3.googleusercontent.com/-ekYLE9xkzKc/W-vop4dVmlI/AAAAAAAAEA0/Oydu-uheHsosOkjQ3R7XxknBZWGIs5heQCHMYCw/I/%255BUNSET%255D)\r\n[![](https://lh3.googleusercontent.com/-ZzsTLiRYfSw/W-vovkUlXpI/AAAAAAAAEBA/h92HlRG-0Agy2BX2YtP-Z3xXM-BDNDdoQCHMYCw/I/%255BUNSET%255D)](https://lh3.googleusercontent.com/-ZzsTLiRYfSw/W-vovkUlXpI/AAAAAAAAEBA/h92HlRG-0Agy2BX2YtP-Z3xXM-BDNDdoQCHMYCw/I/%255BUNSET%255D)\r\n[![](https://lh3.googleusercontent.com/-A-qJEuF4vqk/W-vos9tki1I/AAAAAAAAEA4/mFDiehJ7ayoIa5f3oCuOuMzg91svtcEfQCHMYCw/I/%255BUNSET%255D)](https://lh3.googleusercontent.com/-A-qJEuF4vqk/W-vos9tki1I/AAAAAAAAEA4/mFDiehJ7ayoIa5f3oCuOuMzg91svtcEfQCHMYCw/I/%255BUNSET%255D)\r\n[![](https://lh3.googleusercontent.com/-LVZLR6fAubI/W-vovXXgeWI/AAAAAAAAEA8/Ee6E7eXr--c5TPv0XFJUIqleSN5bmsd9gCHMYCw/I/%255BUNSET%255D)](https://lh3.googleusercontent.com/-LVZLR6fAubI/W-vovXXgeWI/AAAAAAAAEA8/Ee6E7eXr--c5TPv0XFJUIqleSN5bmsd9gCHMYCw/I/%255BUNSET%255D)\r\n\r\n<sr-plugin-count>共计：2036 个字</sr-plugin-count>',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,0),(32,'maven 知识积累','32',1550648749,1550648749,'<!--markdown-->\r\n## [](#基本命令 \"基本命令\")基本命令\r\n\r\n1.  创建 maven 的普通 java 项目：\r\n    `mvn archetype:create\r\n    -DgroupId=packageName\r\n    -DartifactId=projectName`\r\n\r\n2.  创建 maven 的 web 项目：\r\n    `mvn archetype:create\r\n    -DgroupId=packageName\r\n    -DactifactId=webappName -DarchtypeArtifactId=maven-archetype-webapp`\r\n\r\n## [](#常用命令 \"常用命令\")常用命令\r\n\r\n| 命令 | 含义 |\r\n| --- | --- |\r\n| mvn compile | 编译源码 |\r\n| mvn test-compile | 编译测试源码 |\r\n| mvn test | 运行测试 |\r\n| mvn package | 打包项目，在 target 下生成已经压缩的包 |\r\n| mvn jar:jar | 打包成 jar 包 |\r\n| mvn install | 安装源码到本地仓库 |\r\n| mvn deply | 部署到私服仓库，上传部署构建，会把 target 目录下的文件上传，包括源码 |\r\n\r\n## [](#常用参数 \"常用参数\")常用参数\r\n\r\n| 参数 | 含义 |\r\n| --- | --- |\r\n| -x | debug 模式 |\r\n| -Dmaven.test.skip=true | 跳过运行单元测试 |\r\n\r\n<sr-plugin-count>共计：560 个字</sr-plugin-count>',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,0),(33,'创建简单的 Scripy 项目','33',1550648820,1550648904,'<!--markdown-->在爬虫项目的根目录中输入如下命令：\r\n\r\n1.  创建项目\r\n\r\n* * *\r\n\r\n<pre>scrapy startproject demoName\r\n</pre>\r\n\r\n\r\n创建一个名为 **demoName** 的 文件夹.\r\n该文件夹即为 **scrapy** 项目的根目录, 文件夹中包含以下文件：\r\n\r\n> scrapy.cfg: 项目的配置文件\r\n> tutorial/: 该项目的 python 模块。之后您将在此加入代码。\r\n> tutorial/items.py: 项目中的 item 文件.\r\n> tutorial/pipelines.py: 项目中的 pipelines 文件.\r\n> tutorial/settings.py: 项目的设置文件.\r\n> tutorial/spiders/: 放置 spider 代码的目录.\r\n\r\n1.  定义数据项 **Item**\r\n\r\n* * *\r\n\r\n**Item** 即爬取到的单个网页的数据容器，如果把数据保存到数据库的话， **Item** 即为数据库的行。\r\n创建一个 **Item** 类必须继承 `scrapy.item`\r\n实例:\r\n\r\n<pre>import scrapy\r\n\r\nclass TestItem(scrapy.Item):\r\n    title = scrapy.Field()\r\n    link = scrapy.Field()\r\n    desc = scrapy.Field()\r\n</pre>\r\n\r\n## 3\\. 编写爬虫\r\n\r\n在一个 **scrapy** 项目中可以包括多个爬虫，但是默认配置下只能运行一个。如果想启动多个爬虫请参考 —— [Scrapy 之 “并行” 爬虫](https://juejin.im/post/5a1e2a4f6fb9a0451d413a14-)\r\n创建 **scrapy** 爬虫必须继承 `scrapy.Spider` 类，且定义以下三个属性：\r\n- `name` : 爬虫的 唯一标识 , 启动爬虫时就必须传递该参数\r\n- `start_urls` : 包含了 Spider 启动时爬取的 url 列表。因此，第一个被爬取到的页面将是其中之一。后续的 URL 将从初始页面的数据中提取。\r\n- `parse()` : **spider** 的一个方法。被调用时，每个初始 URL 完成下载后生成的 `Response` 对象将会作为唯一的参数传递给该函数。。该方法负责解析返回的数据（response data），提前数据——生成 **Item** 以及生成进一步处理的 URL 的 `Request` 对象。\r\n示例：\r\n\r\n<pre>import scrapy\r\n\r\nclass TestSpider(scrapy.Spider):\r\n    name = \"test\"\r\n    allowed_domains = [\"w3school.com.cn\"]\r\n    start_urls = [\r\n        \"http://www.w3school.com.cn/html/index.asp\",\r\n        \"http://www.w3school.com.cn/js/index.asp\"\r\n    ]\r\n    def parse(self, response):\r\n        filename = response.url.split(\"/\")[-2]\r\n        with open(filename, \'wb\') as f:\r\n            f.write(response.body)\r\n</pre>\r\n\r\n\r\n## 4\\. 启动爬虫\r\n\r\n\r\n<pre>scrapy crawl test\r\n</pre>\r\n\r\n\r\n运行该命令时，`scrapy` 将会为 `start_url` 中的每个 URL 创建一个 `scrapy.Request` 对象，并将执行生成的 `scrapy.http.Response` 作为参数传递给 `parse()` 方法处理。\r\n\r\n> 虽然 `scrapy` 启动时会创建十个进程，但是只有一个线程会用于下载网页内容，其他内容都是作 dns 解析之类的工作。\r\n> 那么如何实现 `scrapy` 的并发呢，有两个方法：\r\n> \r\n> 1.  创建 **docker** 容器，运行多个容器来实现并发，可以通过 **redis** 来控制请求 url 防止重复请求。\r\n> 2.  设置 `settings.DOWNOAD_DELAY=0` 该参数控制网页下载的间隔（单位秒），设置为零可以实现伪并发，但可能会被反爬，但是即便如此设置理论上仍旧只能使用一个 cpu 核心。\r\n\r\n<sr-plugin-count>共计：1730 个字</sr-plugin-count>',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,0),(35,'dubbox','35',1550648940,1551342644,'<!--markdown-->一个分布式的远程调用框架\r\n\r\n由 阿里 dobbo 改进而来，当当维护\r\n\r\n## [](#应用场景： \"应用场景：\")应用场景：\r\n\r\n大型的 web 项目中，多模块之间的远程调用（ RPC ——调用方知道并拥有接口，但实现 在服务端）。\r\n\r\n## [](#概念 \"概念\")概念\r\n\r\n分布式架构。\r\n提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA ——面向服务服务架构的解决方案。\r\n\r\n### [](#特点 \"特点\")特点\r\n\r\n1.  远程通讯: 提供对多种基于长连接的 NIO 框架抽象封装，包括多种线程模型，序列化，以及 “请求 - 响应” 模式的信息交换方式。\r\n2.  集群容错: 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。\r\n3.  自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。\r\n\r\n## [](#构件： \"构件：\")构件：\r\n\r\n[![](https://lh3.googleusercontent.com/O9axdFXDbtFuArlo9O8DjNYusC5ynTmqrDxuP7F2dtwGlOtFy6UTTh7N-uuHvd01VZKuOtFQvVKD)](https://lh3.googleusercontent.com/O9axdFXDbtFuArlo9O8DjNYusC5ynTmqrDxuP7F2dtwGlOtFy6UTTh7N-uuHvd01VZKuOtFQvVKD \"dubbox 组件图\")\r\n\r\n[dubbox 组件图](https://lh3.googleusercontent.com/O9axdFXDbtFuArlo9O8DjNYusC5ynTmqrDxuP7F2dtwGlOtFy6UTTh7N-uuHvd01VZKuOtFQvVKD \"dubbox 组件图\")\r\n\r\n1.  注册中心（Registry）\r\n2.  服务提供方 (Provider)\r\n3.  服务消费方 (comsumer)\r\n4.  监控中心 （Monitor）\r\n5.  服务运行容器 （Container）\r\n\r\n## [](#运行： \"运行：\")运行：\r\n\r\n1.  服务日期负责启动，加载，运行服务提供方\r\n2.  提供方向注册中心注册自己提供的服务\r\n3.  消费者启动时，向注册中心订阅自己所需的服务\r\n4.  注册中心返回地址列表给消费者。如果有变动，注册中心使用长连接推送新数据（http:keep-alive）\r\n5.  消费者从地址列表中，基于软负载均衡算法，选择一台提供者进行调用。如果失败，再选一台调用。\r\n6.  消费者和提供者，在内存中累计调用次数和时间，每分钟定时发送一次统计数据到监控中心。\r\n\r\n### 注册中心————Zookeeper （官方推荐，hadoop 组件）\r\n\r\n## 备注：\r\n当当并没有上传 dobbox 代码到 maven 仓库中，所以不能直接在 maven 中引用，可以使用 jar 包，或者 maven install 到本地仓库\r\n\r\n<sr-plugin-count>共计：812 个字</sr-plugin-count>',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,0),(36,'vpnsetup_centos.zip','vpnsetup_centos-zip',1550798409,1550798409,'a:5:{s:4:\"name\";s:19:\"vpnsetup_centos.zip\";s:4:\"path\";s:35:\"/usr/uploads/2019/02/3768048974.zip\";s:4:\"size\";i:5602;s:4:\"type\";s:3:\"zip\";s:4:\"mime\";s:15:\"application/zip\";}',2,1,NULL,'attachment','publish',NULL,0,'1','0','1',6,0),(37,'epel-release-latest-7.noarch.rpm','epel-release-latest-7-noarch-rpm',1550802264,1550802264,'a:5:{s:4:\"name\";s:32:\"epel-release-latest-7.noarch.rpm\";s:4:\"path\";s:35:\"/usr/uploads/2019/02/2136510359.rpm\";s:4:\"size\";i:15080;s:4:\"type\";s:3:\"rpm\";s:4:\"mime\";s:27:\"audio/x-pn-realaudio-plugin\";}',3,1,NULL,'attachment','publish',NULL,0,'1','0','1',6,0),(38,'未命名文档','38',0,1551342212,'<!--markdown-->123',0,1,NULL,'post_draft','publish',NULL,0,'1','1','1',0,0),(23,'sleuth 入门','23',1550559201,1550559201,'<!--markdown-->> [Spring Cloud Sleuth][1] implements a distributed tracing solution for Spring Cloud, borrowing heavily from [Dapper][2], [Zipkin][3] and HTrace. For most users Sleuth should be invisible, and all your interactions with external systems should be instrumented automatically. You can capture data simply in logs, or by sending it to a remote collector service.\r\n> \r\n> 译文：Spring Cloud Sleuth 为 Spring Cloud 实现了一个分布式跟踪解决方案，大量借鉴了 Dapper、Zipkin 和 Htrace。对于大多数用户来说，Sleuth 应该是不可见的，并且您与外部系统的所有交互都应该是自动检测的。您可以简单地在日志中捕获数据，或者将其发送到远程收集器服务。\r\n\r\n### 为什么需要 Sleuth\r\n\r\n在微服务系统中，往往有着许多服务单元。一个业务请求可能需要调用多个服务单元，而这些单元有可能依赖着许多其他单元，如果其中一个单元出现了错误，我们将难以定位问题。所以在微服务架构中，必须实现服务的链路跟踪，跟进每一个请求的调用链路，记录调用顺序，确保每个步骤都是可见的，这样出现问题时才容易定位解决。\r\n而 Sleuth 就是这样一个实现调用链路监控的框架，也是 Spring Cloud 体系中最通用的链路监控框架。\r\n\r\n### 基本术语\r\n\r\nSpring Cloud Sleuth 采用的是 Google 的开源项目 Dapper 的专业术语。\r\n\r\n- Span：基本工作单元，发送一个远程调度任务 就会产生一个 Span，Span 是一个 64 位 ID 唯一标识的，Trace 是用另一个 64 位 ID 唯一标识的，Span 还有其他数据信息，比如摘要、时间戳事件、Span 的 ID、以及进度 ID。\r\n- Trace：一系列 Span 组成的一个树状结构。请求一个微服务系统的 API 接口，这个 API 接口，需要调用多个微服务，调用每个微服务都会产生一个新的 Span，所有由这个请求产生的 Span 组成了这个 Trace。\r\n- Annotation：用来及时记录一个事件的，一些核心注解用来定义一个请求的开始和结束 。这些注解包括以下： \r\n  - cs - Client Sent - 客户端发送一个请求，这个注解描述了这个 Span 的开始。\r\n  - sr - Server Received - 服务端获得请求并准备开始处理它，如果将其sr减去cs时间戳便可得到网络传输的时间。\r\n  - ss - Server Sent – 该注解表明请求处理的完成 (当请求返回客户端)，如果 ss 的时间戳减去 sr 时间戳，就可以得到服务器请求的时间。\r\n  - cr - Client Received - 此时 Span 的结束，如果 cr 的时间戳减去 cs 时间戳便可以得到整个请求所消耗的时间。\r\n\r\n  [1]: http://spring.io/projects/spring-cloud-sleuth\r\n  [2]: http://research.google.com/pubs/pub36356.html\r\n  [3]: https://github.com/openzipkin/zipkin',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,0),(24,'sleuth 入门','@23',1550559180,1550560402,'<!--markdown-->> [Spring Cloud Sleuth][1] implements a distributed tracing solution for Spring Cloud, borrowing heavily from [Dapper][2], [Zipkin][3] and HTrace. For most users Sleuth should be invisible, and all your interactions with external systems should be instrumented automatically. You can capture data simply in logs, or by sending it to a remote collector service.\r\n> \r\n> 译文：Spring Cloud Sleuth 为 Spring Cloud 实现了一个分布式跟踪解决方案，大量借鉴了 Dapper、Zipkin 和 Htrace。对于大多数用户来说，Sleuth 应该是不可见的，并且您与外部系统的所有交互都应该是自动检测的。您可以简单地在日志中捕获数据，或者将其发送到远程收集器服务。\r\n\r\n### 为什么需要 Sleuth\r\n\r\n在微服务系统中，往往有着许多服务单元。一个业务请求可能需要调用多个服务单元，而这些单元有可能依赖着许多其他单元，如果其中一个单元出现了错误，我们将难以定位问题。所以在微服务架构中，必须实现服务的链路跟踪，跟进每一个请求的调用链路，记录调用顺序，确保每个步骤都是可见的，这样出现问题时才容易定位解决。\r\n而 Sleuth 就是这样一个实现调用链路监控的框架，也是 Spring Cloud 体系中最通用的链路监控框架。\r\n\r\n### 基本术语\r\n\r\nSpring Cloud Sleuth 采用的是 Google 的开源项目 Dapper 的专业术语。\r\n\r\n- Span：基本工作单元，发送一个远程调度任务 就会产生一个 Span，Span 是一个 64 位 ID 唯一标识的，Trace 是用另一个 64 位 ID 唯一标识的，Span 还有其他数据信息，比如摘要、时间戳事件、Span 的 ID、以及进度 ID。\r\n- Trace：一系列 Span 组成的一个树状结构。请求一个微服务系统的 API 接口，这个 API 接口，需要调用多个微服务，调用每个微服务都会产生一个新的 Span，所有由这个请求产生的 Span 组成了这个 Trace。\r\n- Annotation：用来及时记录一个事件的，一些核心注解用来定义一个请求的开始和结束 。这些注解包括以下： \r\n  - cs - Client Sent - 客户端发送一个请求，这个注解描述了这个 Span 的开始。\r\n  - sr - Server Received - 服务端获得请求并准备开始处理它，如果将其sr减去cs时间戳便可得到网络传输的时间。\r\n  - ss - Server Sent – 该注解表明请求处理的完成 (当请求返回客户端)，如果 ss 的时间戳减去 sr 时间戳，就可以得到服务器请求的时间。\r\n  - cr - Client Received - 此时 Span 的结束，如果 cr 的时间戳减去 cs 时间戳便可以得到整个请求所消耗的时间。\r\n\r\n![sleuth示例图][4]\r\n\r\n### 案例实战\r\n\r\n\r\n  [1]: http://spring.io/projects/spring-cloud-sleuth\r\n  [2]: http://research.google.com/pubs/pub36356.html\r\n  [3]: https://github.com/openzipkin/zipkin\r\n  [4]: http://118.126.105.229/usr/uploads/2019/02/3742335678.png',0,1,NULL,'post_draft','publish',NULL,0,'1','1','1',23,0),(26,' Java面试题全集（下）','26',1550562854,1550562854,'<!--markdown-->> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 https://blog.csdn.net/jackfrued/article/details/44931161 版权声明：本文为博主原创文章，请在转载时说明出处。 https://blog.csdn.net/jackfrued/article/details/44931161\r\n\r\n  这部分主要是开源 Java EE 框架方面的内容，包括 Hibernate、MyBatis、Spring、Spring MVC 等，由于 Struts 2 已经是明日黄花，在这里就不讨论 Struts 2 的面试题，如果需要了解相关内容，可以参考我的另一篇文章[《Java 面试题集（86-115）》](http://blog.csdn.net/jackfrued/article/details/17596171)。此外，这篇文章还对企业应用架构、大型网站架构和应用服务器优化等内容进行了简单的探讨，这些内容相信对面试会很有帮助。\r\n\r\n**126、什么是 ORM？**\r\n答：对象关系映射（Object-Relational Mapping，简称 ORM）是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术；简单的说，ORM 是通过使用描述对象和数据库之间映射的元数据（在 Java 中可以用 XML 或者是注解），将程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转换成 Java 对象，其本质上就是将数据从一种形式转换到另外一种形式。\r\n\r\n**127、持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？**\r\n答：所谓 \"持久\" 就是将数据保存到可掉电式存储设备中以便今后使用，简单的说，就是将内存中的数据保存到关系型数据库、文件系统、消息队列等提供持久化支持的设备中。持久层就是系统中专注于实现数据持久化的相对独立的层面。\r\n\r\n持久层设计的目标包括：\r\n- 数据存储逻辑的分离，提供抽象化的数据访问接口。\r\n- 数据访问底层实现的分离，可以在不修改代码的情况下切换底层实现。\r\n- 资源管理和调度的分离，在数据访问层实现统一的资源调度（如缓存机制）。\r\n- 数据抽象，提供更面向对象的数据操作。\r\n\r\n持久层框架有：\r\n- [Hibernate](http://hibernate.org)\r\n- [MyBatis](http://blog.mybatis.org)\r\n- [TopLink](http://www.oracle.com/technetwork/cn/middleware/toplink/overview/index.html)\r\n- [Guzz](https://code.google.com/p/guzz/)\r\n- [jOOQ](http://www.jooq.org)\r\n- [Spring Data](http://projects.spring.io/spring-data/)\r\n- [ActiveJDBC](https://code.google.com/p/activejdbc/)\r\n\r\n**128、Hibernate 中 SessionFactory 是线程安全的吗？Session 是线程安全的吗（两个线程能够共享同一个 Session 吗）？**\r\n答：SessionFactory 对应 Hibernate 的一个数据存储的概念，它是线程安全的，可以被多个线程并发访问。SessionFactory 一般只会在启动的时候构建。对于应用程序，最好将 SessionFactory 通过单例模式进行封装以便于访问。Session 是一个轻量级非线程安全的对象（线程间不能共享 session），它表示与数据库进行交互的一个工作单元。Session 是由 SessionFactory 创建的，在任务完成之后它会被关闭。Session 是持久层服务对外提供的主要接口。Session 会延迟获取数据库连接（也就是在需要的时候才会获取）。为了避免创建太多的 session，可以使用 ThreadLocal 将 session 和当前线程绑定在一起，这样可以让同一个线程获得的总是同一个 session。Hibernate 3 中 SessionFactory 的 getCurrentSession() 方法就可以做到。\r\n\r\n**129、Hibernate 中 Session 的 load 和 get 方法的区别是什么？**\r\n答：主要有以下三项区别：\r\n① 如果没有找到符合条件的记录，get 方法返回 null，load 方法抛出异常。\r\n② get 方法直接返回实体类对象，load 方法返回实体类对象的代理。\r\n③ 在 Hibernate 3 之前，get 方法只在一级缓存中进行数据查找，如果没有找到对应的数据则越过二级缓存，直接发出 SQL 语句完成数据读取；load 方法则可以从二级缓存中获取数据；从 Hibernate 3 开始，get 方法不再是对二级缓存只写不读，它也是可以访问二级缓存的。\r\n\r\n> **说明：**对于 load() 方法 Hibernate 认为该数据在数据库中一定存在可以放心的使用代理来实现延迟加载，如果没有数据就抛出异常，而通过 get() 方法获取的数据可以不存在。\r\n\r\n**130、Session 的 save()、update()、merge()、lock()、saveOrUpdate() 和 persist() 方法分别是做什么的？有什么区别？**\r\n答：Hibernate 的对象有三种状态：瞬时态（transient）、持久态（persistent）和游离态（detached），如第 135 题中的图所示。瞬时态的实例可以通过调用 save()、persist() 或者 saveOrUpdate() 方法变成持久态；游离态的实例可以通过调用 update()、saveOrUpdate()、lock() 或者 replicate() 变成持久态。save() 和 persist() 将会引发 SQL 的 INSERT 语句，而 update() 或 merge() 会引发 UPDATE 语句。save() 和 update() 的区别在于一个是将瞬时态对象变成持久态，一个是将游离态对象变为持久态。merge() 方法可以完成 save() 和 update() 方法的功能，它的意图是将新的状态合并到已有的持久化对象上或创建新的持久化对象。对于 persist() 方法，按照官方文档的说明：① persist() 方法把一个瞬时态的实例持久化，但是并不保证标识符被立刻填入到持久化实例中，标识符的填入可能被推迟到 flush 的时间；② persist() 方法保证当它在一个事务外部被调用的时候并不触发一个 INSERT 语句，当需要封装一个长会话流程的时候，persist() 方法是很有必要的；③ save() 方法不保证第②条，它要返回标识符，所以它会立即执行 INSERT 语句，不管是在事务内部还是外部。至于 lock() 方法和 update() 方法的区别，update() 方法是把一个已经更改过的脱管状态的对象变成持久状态；lock() 方法是把一个没有更改过的脱管状态的对象变成持久状态。\r\n\r\n**131、阐述 Session 加载实体对象的过程。**\r\n答：Session 加载实体对象的步骤是：\r\n① Session 在调用数据库查询功能之前，首先会在一级缓存中通过实体类型和主键进行查找，如果一级缓存查找命中且数据状态合法，则直接返回；\r\n② 如果一级缓存没有命中，接下来 Session 会在当前 NonExists 记录（相当于一个查询黑名单，如果出现重复的无效查询可以迅速做出判断，从而提升性能）中进行查找，如果 NonExists 中存在同样的查询条件，则返回 null；\r\n③ 如果一级缓存查询失败则查询二级缓存，如果二级缓存命中则直接返回；\r\n④ 如果之前的查询都未命中，则发出 SQL 语句，如果查询未发现对应记录则将此次查询添加到 Session 的 NonExists 中加以记录，并返回 null；\r\n⑤ 根据映射配置和 SQL 语句得到 ResultSet，并创建对应的实体对象；\r\n⑥ 将对象纳入 Session（一级缓存）的管理；\r\n⑦ 如果有对应的拦截器，则执行拦截器的 onLoad 方法；\r\n⑧ 如果开启并设置了要使用二级缓存，则将数据对象纳入二级缓存；\r\n⑨ 返回数据对象。\r\n\r\n**132、Query 接口的 list 方法和 iterate 方法有什么区别？**\r\n答：\r\n① list() 方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate() 方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用 iterate() 方法可以减少性能开销。\r\n② list() 方法不会引起 N+1 查询问题，而 iterate() 方法可能引起 N+1 查询问题\r\n\r\n> **说明：**关于 N+1 查询问题，可以参考 CSDN 上的一篇文章[《什么是 N+1 查询》](http://blog.csdn.net/xtayhicbladwin/article/details/4739852)\r\n\r\n**133、Hibernate 如何实现分页查询？**\r\n答：通过 Hibernate 实现分页查询，开发人员只需要提供 HQL 语句（调用 Session 的 createQuery() 方法）或查询条件（调用 Session 的 createCriteria() 方法）、设置查询起始行数（调用 Query 或 Criteria 接口的 setFirstResult() 方法）和最大查询行数（调用 Query 或 Criteria 接口的 setMaxResults() 方法），并调用 Query 或 Criteria 接口的 list() 方法，Hibernate 会自动生成分页查询的 SQL 语句。\r\n\r\n**134、锁机制有什么用？简述 Hibernate 的悲观锁和乐观锁机制。**\r\n答：有些业务逻辑在执行过程中要求对数据进行排他性的访问，于是需要通过一些机制保证在此过程中数据被锁住不会被外界修改，这就是所谓的锁机制。\r\nHibernate 支持悲观锁和乐观锁两种锁机制。悲观锁，顾名思义悲观的认为在数据处理过程中极有可能存在修改数据的并发事务（包括本系统的其他事务或来自外部系统的事务），于是将处理的数据设置为锁定状态。悲观锁必须依赖数据库本身的锁机制才能真正保证数据访问的排他性，关于数据库的锁机制和事务隔离级别在[《Java 面试题大全（上）》](http://blog.csdn.net/jackfrued/article/details/44921941)中已经讨论过了。乐观锁，顾名思义，对并发事务持乐观态度（认为对数据的并发操作不会经常性的发生），通过更加宽松的锁机制来解决由于悲观锁排他性的数据访问对系统性能造成的严重影响。最常见的乐观锁是通过数据版本标识来实现的，读取数据时获得数据的版本号，更新数据时将此版本号加 1，然后和数据库表对应记录的当前版本号进行比较，如果提交的数据版本号大于数据库中此记录的当前版本号则更新数据，否则认为是过期数据无法更新。Hibernate 中通过 Session 的 get() 和 load() 方法从数据库中加载对象时可以通过参数指定使用悲观锁；而乐观锁可以通过给实体类加整型的版本字段再通过 XML 或 @Version 注解进行配置。\r\n\r\n> **提示：**使用乐观锁会增加了一个版本字段，很明显这需要额外的空间来存储这个版本字段，浪费了空间，但是乐观锁会让系统具有更好的并发性，这是对时间的节省。因此乐观锁也是典型的空间换时间的策略。\r\n\r\n**135、阐述实体对象的三种状态以及转换关系。**\r\n答：最新的 Hibernate 文档中为 Hibernate 对象定义了四种状态（原来是三种状态，面试的时候基本上问的也是三种状态），分别是：瞬时态（new, or transient）、持久态（managed, or persistent）、游状态（detached）和移除态（removed，以前 Hibernate 文档中定义的三种状态中没有移除态），如下图所示，就以前的 Hibernate 文档中移除态被视为是瞬时态。\r\n\r\n*   瞬时态：当 new 一个实体对象后，这个对象处于瞬时态，即这个对象只是一个保存临时数据的内存区域，如果没有变量引用这个对象，则会被 JVM 的垃圾回收机制回收。这个对象所保存的数据与数据库没有任何关系，除非通过 Session 的 save()、saveOrUpdate()、persist()、merge() 方法把瞬时态对象与数据库关联，并把数据插入或者更新到数据库，这个对象才转换为持久态对象。\r\n*   持久态：持久态对象的实例在数据库中有对应的记录，并拥有一个持久化标识（ID）。对持久态对象进行 delete 操作后，数据库中对应的记录将被删除，那么持久态对象与数据库记录不再存在对应关系，持久态对象变成移除态（可以视为瞬时态）。持久态对象被修改变更后，不会马上同步到数据库，直到数据库事务提交。\r\n*   游离态：当 Session 进行了 close()、clear()、evict() 或 flush() 后，实体对象从持久态变成游离态，对象虽然拥有持久和与数据库对应记录一致的标识值，但是因为对象已经从会话中清除掉，对象不在持久化管理之内，所以处于游离态（也叫脱管态）。游离态的对象与临时状态对象是十分相似的，只是它还含有持久化标识。\r\n\r\n> **提示：**关于这个问题，在 [Hibernate 的官方文档](http://docs.jboss.org/hibernate/orm/4.3/devguide/en-US/html_single/#d5e874)中有更为详细的解读。\r\n\r\n**136、如何理解 Hibernate 的延迟加载机制？在实际应用中，延迟加载与 Session 关闭的矛盾是如何处理的？**\r\n答：延迟加载就是并不是在读取的时候就把数据加载进来，而是等到使用时再加载。Hibernate 使用了虚拟代理机制实现延迟加载，我们使用 Session 的 load() 方法加载数据或者一对多关联映射在使用延迟加载的情况下从一的一方加载多的一方，得到的都是虚拟代理，简单的说返回给用户的并不是实体本身，而是实体对象的代理。代理对象在用户调用 getter 方法时才会去数据库加载数据。但加载数据就需要数据库连接。而当我们把会话关闭时，数据库连接就同时关闭了。\r\n\r\n延迟加载与 session 关闭的矛盾一般可以这样处理：\r\n① 关闭延迟加载特性。这种方式操作起来比较简单，因为 Hibernate 的延迟加载特性是可以通过映射文件或者注解进行配置的，但这种解决方案存在明显的缺陷。首先，出现 \"no session or session was closed\" 通常说明系统中已经存在主外键关联，如果去掉延迟加载的话，每次查询的开销都会变得很大。\r\n② 在 session 关闭之前先获取需要查询的数据，可以使用工具方法 Hibernate.isInitialized() 判断对象是否被加载，如果没有被加载则可以使用 Hibernate.initialize() 方法加载对象。\r\n③ 使用拦截器或过滤器延长 Session 的生命周期直到视图获得数据。Spring 整合 Hibernate 提供的 OpenSessionInViewFilter 和 OpenSessionInViewInterceptor 就是这种做法。\r\n\r\n**137、举一个多对多关联的例子，并说明如何实现多对多关联映射。**\r\n答：例如：商品和订单、学生和课程都是典型的多对多关系。可以在实体类上通过 @ManyToMany 注解配置多对多关联或者通过映射文件中的和标签配置多对多关联，但是实际项目开发中，很多时候都是将多对多关联映射转换成两个多对一关联映射来实现的。\r\n\r\n**138、谈一下你对继承映射的理解。**\r\n答：继承关系的映射策略有三种：\r\n① 每个继承结构一张表（table per class hierarchy），不管多少个子类都用一张表。\r\n② 每个子类一张表（table per subclass），公共信息放一张表，特有信息放单独的表。\r\n③ 每个具体类一张表（table per concrete class），有多少个子类就有多少张表。\r\n第一种方式属于单表策略，其优点在于查询子类对象的时候无需表连接，查询速度快，适合多态查询；缺点是可能导致表很大。后两种方式属于多表策略，其优点在于数据存储紧凑，其缺点是需要进行连接查询，不适合多态查询。\r\n\r\n**139、简述 Hibernate 常见优化策略。**\r\n答：这个问题应当挑自己使用过的优化策略回答，常用的有：\r\n① 制定合理的缓存策略（二级缓存、查询缓存）。\r\n② 采用合理的 Session 管理机制。\r\n③ 尽量使用延迟加载特性。\r\n④ 设定合理的批处理参数。\r\n⑤ 如果可以，选用 UUID 作为主键生成器。\r\n⑥ 如果可以，选用基于版本号的乐观锁替代悲观锁。\r\n⑦ 在开发过程中, 开启 hibernate.show_sql 选项查看生成的 SQL，从而了解底层的状况；开发完成后关闭此选项。\r\n⑧ 考虑数据库本身的优化，合理的索引、恰当的数据分区策略等都会对持久层的性能带来可观的提升，但这些需要专业的 DBA（数据库管理员）提供支持。\r\n\r\n**140、谈一谈 Hibernate 的一级缓存、二级缓存和查询缓存。**\r\n答：Hibernate 的 Session 提供了一级缓存的功能，默认总是有效的，当应用程序保存持久化实体、修改持久化实体时，Session 并不会立即把这种改变提交到数据库，而是缓存在当前的 Session 中，除非显示调用了 Session 的 flush() 方法或通过 close() 方法关闭 Session。通过一级缓存，可以减少程序与数据库的交互，从而提高数据库访问性能。\r\nSessionFactory 级别的二级缓存是全局性的，所有的 Session 可以共享这个二级缓存。不过二级缓存默认是关闭的，需要显示开启并指定需要使用哪种二级缓存实现类（可以使用第三方提供的实现）。一旦开启了二级缓存并设置了需要使用二级缓存的实体类，SessionFactory 就会缓存访问过的该实体类的每个对象，除非缓存的数据超出了指定的缓存空间。\r\n一级缓存和二级缓存都是对整个实体进行缓存，不会缓存普通属性，如果希望对普通属性进行缓存，可以使用查询缓存。查询缓存是将 HQL 或 SQL 语句以及它们的查询结果作为键值对进行缓存，对于同样的查询可以直接从缓存中获取数据。查询缓存默认也是关闭的，需要显示开启。\r\n\r\n**141、Hibernate 中 DetachedCriteria 类是做什么的？**\r\n答：DetachedCriteria 和 Criteria 的用法基本上是一致的，但 Criteria 是由 Session 的 createCriteria() 方法创建的，也就意味着离开创建它的 Session，Criteria 就无法使用了。DetachedCriteria 不需要 Session 就可以创建（使用 DetachedCriteria.forClass() 方法创建），所以通常也称其为离线的 Criteria，在需要进行查询操作的时候再和 Session 绑定（调用其 getExecutableCriteria(Session) 方法），这也就意味着一个 DetachedCriteria 可以在需要的时候和不同的 Session 进行绑定。\r\n\r\n**142、@OneToMany 注解的 mappedBy 属性有什么作用？**\r\n答：@OneToMany 用来配置一对多关联映射，但通常情况下，一对多关联映射都由多的一方来维护关联关系，例如学生和班级，应该在学生类中添加班级属性来维持学生和班级的关联关系（在数据库中是由学生表中的外键班级编号来维护学生表和班级表的多对一关系），如果要使用双向关联，在班级类中添加一个容器属性来存放学生，并使用 @OneToMany 注解进行映射，此时 mappedBy 属性就非常重要。如果使用 XML 进行配置，可以用 <set> 标签的 inverse=\"true\" 设置来达到同样的效果。\r\n\r\n**143、MyBatis 中使用`#`和`$`书写占位符有什么区别？**\r\n答：`#`将传入的数据都当成一个字符串，会对传入的数据自动加上引号；`$`将传入的数据直接显示生成在 SQL 中。注意：使用`$`占位符可能会导致 SQL 注射攻击，能用`#`的地方就不要使用`$`，写 order by 子句的时候应该用`$`而不是`#`。\r\n\r\n**144、解释一下 MyBatis 中命名空间（namespace）的作用。**\r\n答：在大型项目中，可能存在大量的 SQL 语句，这时候为每个 SQL 语句起一个唯一的标识（ID）就变得并不容易了。为了解决这个问题，在 MyBatis 中，可以为每个映射文件起一个唯一的命名空间，这样定义在这个映射文件中的每个 SQL 语句就成了定义在这个命名空间中的一个 ID。只要我们能够保证每个命名空间中这个 ID 是唯一的，即使在不同映射文件中的语句 ID 相同，也不会再产生冲突了。\r\n\r\n**145、MyBatis 中的动态 SQL 是什么意思？**\r\n答：对于一些复杂的查询，我们可能会指定多个查询条件，但是这些条件可能存在也可能不存在，例如在 58 同城上面找房子，我们可能会指定面积、楼层和所在位置来查找房源，也可能会指定面积、价格、户型和所在位置来查找房源，此时就需要根据用户指定的条件动态生成 SQL 语句。如果不使用持久层框架我们可能需要自己拼装 SQL 语句，还好 MyBatis 提供了动态 SQL 的功能来解决这个问题。MyBatis 中用于实现动态 SQL 的元素主要有：\r\n- if\r\n- choose / when / otherwise\r\n- trim\r\n- where\r\n- set\r\n- foreach\r\n\r\n下面是映射文件的片段。\r\n\r\n```\r\n    <select id=\"foo\" parameterType=\"Blog\" resultType=\"Blog\">\r\n        select * from t_blog where 1 = 1\r\n        <if test=\"title != null\">\r\n            and title = #{title}\r\n        </if>\r\n        <if test=\"content != null\">\r\n            and content = #{content}\r\n        </if>\r\n        <if test=\"owner != null\">\r\n            and owner = #{owner}\r\n        </if>\r\n   </select>\r\n```\r\n\r\n当然也可以像下面这些书写。\r\n\r\n```\r\n    <select id=\"foo\" parameterType=\"Blog\" resultType=\"Blog\">\r\n        select * from t_blog where 1 = 1 \r\n        <choose>\r\n            <when test=\"title != null\">\r\n                and title = #{title}\r\n            </when>\r\n            <when test=\"content != null\">\r\n                and content = #{content}\r\n            </when>\r\n            <otherwise>\r\n                and owner = \"owner1\"\r\n            </otherwise>\r\n        </choose>\r\n    </select>\r\n```\r\n\r\n再看看下面这个例子。\r\n\r\n```\r\n    <select id=\"bar\" resultType=\"Blog\">\r\n        select * from t_blog where id in\r\n        <foreach collection=\"array\" index=\"index\" \r\n            item=\"item\" open=\"(\" separator=\",\" close=\")\">\r\n            #{item}\r\n        </foreach>\r\n    </select>\r\n```\r\n\r\n**146、什么是 IoC 和 DI？DI 是如何实现的？**\r\n答：IoC 叫控制反转，是 Inversion of Control 的缩写，DI（Dependency Injection）叫依赖注入，是对 IoC 更简单的诠释。控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的 \"控制反转\" 就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。IoC 体现了好莱坞原则 - \"Don’t call me, we will call you\"。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI 是对 IoC 更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。\r\n\r\n举个例子：一个类 A 需要用到接口 B 中的方法，那么就需要为类 A 和接口 B 建立关联或依赖关系，最原始的方法是在类 A 中创建一个接口 B 的实现类 C 的实例，但这种方法需要开发人员自行维护二者的依赖关系，也就是说当依赖关系发生变动的时候需要修改代码并重新构建整个系统。如果通过一个容器来管理这些对象以及对象的依赖关系，则只需要在类 A 中定义好用于关联接口 B 的方法（构造器或 setter 方法），将类 A 和接口 B 的实现类 C 放入容器中，通过对容器的配置来实现二者的关联。\r\n\r\n依赖注入可以通过 setter 方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring 支持 setter 注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则 setter 注入是更好的选择，setter 注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。\r\n\r\n**147、Spring 中 Bean 的作用域有哪些？**\r\n答：在 Spring 的早期版本中，仅有两个作用域：singleton 和 prototype，前者表示 Bean 以单例的方式存在；后者表示每次从容器中调用 Bean 时，都会返回一个新的实例，prototype 通常翻译为原型。\r\n\r\n> **补充：**设计模式中的创建型模式中也有一个原型模式，原型模式也是一个常用的模式，例如做一个室内设计软件，所有的素材都在工具箱中，而每次从工具箱中取出的都是素材对象的一个原型，可以通过对象克隆来实现原型模式。\r\n\r\nSpring 2.x 中针对 WebApplicationContext 新增了 3 个作用域，分别是：request（每次 HTTP 请求都会创建一个新的 Bean）、session（同一个 HttpSession 共享同一个 Bean，不同的 HttpSession 使用不同的 Bean）和 globalSession（同一个全局 Session 共享一个 Bean）。\r\n\r\n> **说明：**单例模式和原型模式都是重要的设计模式。一般情况下，无状态或状态不可变的类适合使用单例模式。在传统开发中，由于 DAO 持有 Connection 这个非线程安全对象因而没有使用单例模式；但在 Spring 环境下，所有 DAO 类对可以采用单例模式，因为 Spring 利用 AOP 和 Java API 中的 ThreadLocal 对非线程安全的对象进行了特殊处理。\r\n\r\nThreadLocal 为解决多线程程序的并发问题提供了一种新的思路。ThreadLocal，顾名思义是线程的一个本地化对象，当工作于多线程中的对象使用 ThreadLocal 维护变量时，ThreadLocal 为每个使用该变量的线程分配一个独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不影响其他线程所对应的副本。从线程的角度看，这个变量就像是线程的本地变量。\r\n\r\nThreadLocal 类非常简单好用，只有四个方法，能用上的也就是下面三个方法：\r\n- void set(T value)：设置当前线程的线程局部变量的值。\r\n- T get()：获得当前线程所对应的线程局部变量的值。\r\n- void remove()：删除当前线程中线程局部变量的值。\r\n\r\nThreadLocal 是如何做到为每一个线程维护一份独立的变量副本的呢？在 ThreadLocal 类中有一个 Map，键为线程对象，值是其线程对应的变量的副本，自己要模拟实现一个 ThreadLocal 类其实并不困难，代码如下所示：\r\n\r\n```\r\nimport java.util.Collections;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\npublic class MyThreadLocal<T> {\r\n    private Map<Thread, T> map = Collections.synchronizedMap(new HashMap<Thread, T>());\r\n\r\n    public void set(T newValue) {\r\n        map.put(Thread.currentThread(), newValue);\r\n    }\r\n\r\n    public T get() {\r\n        return map.get(Thread.currentThread());\r\n    }\r\n\r\n    public void remove() {\r\n        map.remove(Thread.currentThread());\r\n    }\r\n}\r\n```\r\n\r\n**148、解释一下什么叫 AOP（面向切面编程）？**\r\n答：AOP（Aspect-Oriented Programming）指一种程序设计范型，该范型以一种称为切面（aspect）的语言构造为基础，切面是一种新的模块化机制，用来描述分散在对象、类或方法中的横切关注点（crosscutting concern）。\r\n\r\n**149、你是如何理解 \"横切关注\" 这个概念的？**\r\n答：\"横切关注\" 是会影响到整个应用程序的关注功能，它跟正常的业务逻辑是正交的，没有必然的联系，但是几乎所有的业务逻辑都会涉及到这些关注功能。通常，事务、日志、安全性等关注就是应用中的横切关注功能。\r\n\r\n**150、你如何理解 AOP 中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？**\r\n答：\r\na. 连接点（Joinpoint）：程序执行的某个特定位置（如：某个方法调用前、调用后，方法抛出异常后）。一个类或一段程序代码拥有一些具有边界性质的特定点，这些代码中的特定点就是连接点。Spring 仅支持方法的连接点。\r\nb. 切点（Pointcut）：如果连接点相当于数据中的记录，那么切点相当于查询条件，一个切点可以匹配多个连接点。Spring AOP 的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。\r\nc. 增强（Advice）：增强是织入到目标类连接点上的一段程序代码。Spring 提供的增强接口都是带方位名的，如：BeforeAdvice、AfterReturningAdvice、ThrowsAdvice 等。很多资料上将增强译为 “通知”，这明显是个词不达意的翻译，让很多程序员困惑了许久。\r\n\r\n> **说明：** Advice 在国内的很多书面资料中都被翻译成 \"通知\"，但是很显然这个翻译无法表达其本质，有少量的读物上将这个词翻译为 \"增强\"，这个翻译是对 Advice 较为准确的诠释，我们通过 AOP 将横切关注功能加到原有的业务逻辑上，这就是对原有业务逻辑的一种增强，这种增强可以是前置增强、后置增强、返回后增强、抛异常时增强和包围型增强。\r\n\r\nd. 引介（Introduction）：引介是一种特殊的增强，它为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过引介功能，可以动态的未该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。\r\ne. 织入（Weaving）：织入是将增强添加到目标类具体连接点上的过程，AOP 有三种织入方式：①编译期织入：需要特殊的 Java 编译期（例如 AspectJ 的 ajc）；②装载期织入：要求使用特殊的类加载器，在装载类的时候对类进行增强；③运行时织入：在运行时为目标类生成代理实现增强。Spring 采用了动态代理的方式实现了运行时织入，而 AspectJ 采用了编译期织入和装载期织入的方式。\r\nf. 切面（Aspect）：切面是由切点和增强（引介）组成的，它包括了对横切关注功能的定义，也包括了对连接点的定义。\r\n\r\n> **补充：**代理模式是 GoF 提出的 23 种设计模式中最为经典的模式之一，代理模式是对象的结构模式，它给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。简单的说，代理对象可以完成比原对象更多的职责，当需要为原对象添加横切关注功能时，就可以使用原对象的代理对象。我们在打开 Office 系列的 Word 文档时，如果文档中有插图，当文档刚加载时，文档中的插图都只是一个虚框占位符，等用户真正翻到某页要查看该图片时，才会真正加载这张图，这其实就是对代理模式的使用，代替真正图片的虚框就是一个虚拟代理；Hibernate 的 load 方法也是返回一个虚拟代理对象，等用户真正需要访问对象的属性时，才向数据库发出 SQL 语句获得真实对象。\r\n\r\n下面用一个找枪手代考的例子演示代理模式的使用：\r\n\r\n```\r\n/**\r\n * 参考人员接口\r\n * @author 骆昊\r\n *\r\n */\r\npublic interface Candidate {\r\n\r\n    /**\r\n     * 答题\r\n     */\r\n    public void answerTheQuestions();\r\n}\r\n```\r\n\r\n```\r\n/**\r\n * 懒学生\r\n * @author 骆昊\r\n *\r\n */\r\npublic class LazyStudent implements Candidate {\r\n    private String name;        // 姓名\r\n\r\n    public LazyStudent(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    @Override\r\n    public void answerTheQuestions() {\r\n        // 懒学生只能写出自己的名字不会答题\r\n        System.out.println(\"姓名: \" + name);\r\n    }\r\n\r\n}\r\n```\r\n\r\n```\r\n/**\r\n * 枪手\r\n * @author 骆昊\r\n *\r\n */\r\npublic class Gunman implements Candidate {\r\n    private Candidate target;   // 被代理对象\r\n\r\n    public Gunman(Candidate target) {\r\n        this.target = target;\r\n    }\r\n\r\n    @Override\r\n    public void answerTheQuestions() {\r\n        // 枪手要写上代考的学生的姓名\r\n        target.answerTheQuestions();\r\n        // 枪手要帮助懒学生答题并交卷\r\n        System.out.println(\"奋笔疾书正确答案\");\r\n        System.out.println(\"交卷\");\r\n    }\r\n\r\n}\r\n```\r\n\r\n```\r\npublic class ProxyTest1 {\r\n\r\n    public static void main(String[] args) {\r\n        Candidate c = new Gunman(new LazyStudent(\"王小二\"));\r\n        c.answerTheQuestions();\r\n    }\r\n}\r\n```\r\n\r\n> **说明：**从 JDK 1.3 开始，Java 提供了动态代理技术，允许开发者在运行时创建接口的代理实例，主要包括 Proxy 类和 InvocationHandler 接口。下面的例子使用动态代理为 ArrayList 编写一个代理，在添加和删除元素时，在控制台打印添加或删除的元素以及 ArrayList 的大小：\r\n\r\n```\r\nimport java.lang.reflect.InvocationHandler;\r\nimport java.lang.reflect.Method;\r\nimport java.util.List;\r\n\r\npublic class ListProxy<T> implements InvocationHandler {\r\n    private List<T> target;\r\n\r\n    public ListProxy(List<T> target) {\r\n        this.target = target;\r\n    }\r\n\r\n    @Override\r\n    public Object invoke(Object proxy, Method method, Object[] args)\r\n            throws Throwable {\r\n        Object retVal = null;\r\n        System.out.println(\"[\" + method.getName() + \": \" + args[0] + \"]\");\r\n        retVal = method.invoke(target, args);\r\n        System.out.println(\"[size=\" + target.size() + \"]\");\r\n        return retVal;\r\n    }\r\n\r\n}\r\n```\r\n\r\n```\r\nimport java.lang.reflect.Proxy;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class ProxyTest2 {\r\n\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static void main(String[] args) {\r\n        List<String> list = new ArrayList<String>();\r\n        Class<?> clazz = list.getClass();\r\n        ListProxy<String> myProxy = new ListProxy<String>(list);\r\n        List<String> newList = (List<String>) \r\n                Proxy.newProxyInstance(clazz.getClassLoader(), \r\n                clazz.getInterfaces(), myProxy);\r\n        newList.add(\"apple\");\r\n        newList.add(\"banana\");\r\n        newList.add(\"orange\");\r\n        newList.remove(\"banana\");\r\n    }\r\n}\r\n```\r\n\r\n> **说明：**使用 Java 的动态代理有一个局限性就是代理的类必须要实现接口，虽然面向接口编程是每个优秀的 Java 程序都知道的规则，但现实往往不尽如人意，对于没有实现接口的类如何为其生成代理呢？继承！继承是最经典的扩展已有代码能力的手段，虽然继承常常被初学者滥用，但继承也常常被进阶的程序员忽视。CGLib 采用非常底层的字节码生成技术，通过为一个类创建子类来生成代理，它弥补了 Java 动态代理的不足，因此 Spring 中动态代理和 CGLib 都是创建代理的重要手段，对于实现了接口的类就用动态代理为其生成代理类，而没有实现接口的类就用 CGLib 通过继承的方式为其创建代理。\r\n\r\n**151、Spring 中自动装配的方式有哪些？**\r\n答：\r\n- no：不进行自动装配，手动设置 Bean 的依赖关系。\r\n- byName：根据 Bean 的名字进行自动装配。\r\n- byType：根据 Bean 的类型进行自动装配。\r\n- constructor：类似于 byType，不过是应用于构造器的参数，如果正好有一个 Bean 与构造器的参数类型相同则可以自动装配，否则会导致错误。\r\n- autodetect：如果有默认的构造器，则通过 constructor 的方式进行自动装配，否则使用 byType 的方式进行自动装配。\r\n\r\n> **说明：**自动装配没有自定义装配方式那么精确，而且不能自动装配简单属性（基本类型、字符串等），在使用时应注意。\r\n\r\n**152、Spring 中如何使用注解来配置 Bean？有哪些相关的注解？**\r\n答：首先需要在 Spring 配置文件中增加如下配置：\r\n\r\n```\r\n<context:component-scan base-package=\"org.example\"/>\r\n```\r\n\r\n然后可以用 @Component、@Controller、@Service、@Repository 注解来标注需要由 Spring IoC 容器进行对象托管的类。这几个注解没有本质区别，只不过 @Controller 通常用于控制器，@Service 通常用于业务逻辑类，@Repository 通常用于仓储类（例如我们的 DAO 实现类），普通的类用 @Component 来标注。\r\n\r\n**153、Spring 支持的事务管理类型有哪些？你在项目中使用哪种方式？**\r\n答：Spring 支持编程式事务管理和声明式事务管理。许多 Spring 框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理，因为编程式事务允许你通过代码控制业务。\r\n\r\n事务分为全局事务和局部事务。全局事务由应用服务器管理，需要底层服务器 JTA 支持（如 WebLogic、WildFly 等）。局部事务和底层采用的持久化方案有关，例如使用 JDBC 进行持久化时，需要使用 Connetion 对象来操作事务；而采用 Hibernate 进行持久化时，需要使用 Session 对象来操作事务。\r\n\r\nSpring 提供了如下所示的事务管理器。\r\n\r\n| 事务管理器实现类 | 目标对象 |\r\n| :-: | :-: |\r\n| DataSourceTransactionManager | 注入 DataSource |\r\n| HibernateTransactionManager | 注入 SessionFactory |\r\n| JdoTransactionManager | 管理 JDO 事务 |\r\n| JtaTransactionManager | 使用 JTA 管理事务 |\r\n| PersistenceBrokerTransactionManager | 管理 Apache 的 OJB 事务 |\r\n\r\n这些事务的父接口都是 PlatformTransactionManager。Spring 的事务管理机制是一种典型的策略模式，PlatformTransactionManager 代表事务管理接口，该接口定义了三个方法，该接口并不知道底层如何管理事务，但是它的实现类必须提供 getTransaction() 方法（开启事务）、commit() 方法（提交事务）、rollback() 方法（回滚事务）的多态实现，这样就可以用不同的实现类代表不同的事务管理策略。使用 JTA 全局事务策略时，需要底层应用服务器支持，而不同的应用服务器所提供的 JTA 全局事务可能存在细节上的差异，因此实际配置全局事务管理器是可能需要使用 JtaTransactionManager 的子类，如：WebLogicJtaTransactionManager（Oracle 的 WebLogic 服务器提供）、UowJtaTransactionManager（IBM 的 WebSphere 服务器提供）等。\r\n\r\n编程式事务管理如下所示。\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n <beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:p=\"http://www.springframework.org/schema/context\"\r\n     xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\n     http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\r\n\r\n     <context:component-scan base-package=\"com.jackfrued\"/>\r\n\r\n     <bean id=\"propertyConfig\"\r\n         class=\"org.springframework.beans.factory.config.\r\n  PropertyPlaceholderConfigurer\">\r\n         <property >\r\n             <value>jdbc.properties</value>\r\n         </property>\r\n     </bean>\r\n\r\n     <bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\">\r\n         <property >\r\n             <value>${db.driver}</value>\r\n         </property>\r\n         <property >\r\n             <value>${db.url}</value>\r\n         </property>\r\n         <property >\r\n             <value>${db.username}</value>\r\n         </property>\r\n         <property >\r\n             <value>${db.password}</value>\r\n         </property>\r\n     </bean>\r\n\r\n     <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\r\n         <property >\r\n             <ref bean=\"dataSource\" />\r\n         </property>\r\n     </bean>\r\n\r\n     <!-- JDBC事务管理器 -->\r\n     <bean id=\"transactionManager\"\r\n         class=\"org.springframework.jdbc.datasource.\r\n       DataSourceTransactionManager\"　scope=\"singleton\">\r\n         <property >\r\n             <ref bean=\"dataSource\" />\r\n         </property>\r\n     </bean>\r\n\r\n     <!-- 声明事务模板 -->\r\n     <bean id=\"transactionTemplate\"\r\n         class=\"org.springframework.transaction.support.\r\n   TransactionTemplate\">\r\n         <property >\r\n             <ref bean=\"transactionManager\" />\r\n         </property>\r\n     </bean>\r\n\r\n</beans>\r\n```\r\n\r\n```\r\npackage com.jackfrued.dao.impl;\r\n\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.jdbc.core.JdbcTemplate;\r\n\r\nimport com.jackfrued.dao.EmpDao;\r\nimport com.jackfrued.entity.Emp;\r\n\r\n@Repository\r\npublic class EmpDaoImpl implements EmpDao {\r\n    @Autowired\r\n    private JdbcTemplate jdbcTemplate;\r\n\r\n    @Override\r\n    public boolean save(Emp emp) {\r\n        String sql = \"insert into emp values (?,?,?)\";\r\n        return jdbcTemplate.update(sql, emp.getId(), emp.getName(), emp.getBirthday()) == 1;\r\n    }\r\n\r\n}\r\n```\r\n\r\n```\r\npackage com.jackfrued.biz.impl;\r\n\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.TransactionStatus;\r\nimport org.springframework.transaction.support.TransactionCallbackWithoutResult;\r\nimport org.springframework.transaction.support.TransactionTemplate;\r\n\r\nimport com.jackfrued.biz.EmpService;\r\nimport com.jackfrued.dao.EmpDao;\r\nimport com.jackfrued.entity.Emp;\r\n\r\n@Service\r\npublic class EmpServiceImpl implements EmpService {\r\n    @Autowired\r\n    private TransactionTemplate txTemplate;\r\n    @Autowired\r\n    private EmpDao empDao;\r\n\r\n    @Override\r\n    public void addEmp(final Emp emp) {\r\n        txTemplate.execute(new TransactionCallbackWithoutResult() {\r\n\r\n            @Override\r\n            protected void doInTransactionWithoutResult(TransactionStatus txStatus) {\r\n                empDao.save(emp);\r\n            }\r\n        });\r\n    }\r\n\r\n}\r\n```\r\n\r\n声明式事务如下图所示，以 Spring 整合 Hibernate 3 为例，包括完整的 DAO 和业务逻辑代码。\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:aop=\"http://www.springframework.org/schema/aop\" \r\n    xmlns:tx=\"http://www.springframework.org/schema/tx\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n           http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\r\n           http://www.springframework.org/schema/context\r\n           http://www.springframework.org/schema/context/spring-context-3.2.xsd\r\n           http://www.springframework.org/schema/aop\r\n           http://www.springframework.org/schema/aop/spring-aop-3.2.xsd\r\n           http://www.springframework.org/schema/tx\r\n           http://www.springframework.org/schema/tx/spring-tx-3.2.xsd\">\r\n\r\n    <!-- 配置由Spring IoC容器托管的对象对应的被注解的类所在的包 -->\r\n    <context:component-scan base-package=\"com.jackfrued\" />\r\n\r\n    <!-- 配置通过自动生成代理实现AOP功能 -->\r\n    <aop:aspectj-autoproxy />\r\n\r\n    <!-- 配置数据库连接池 (DBCP) -->\r\n    <bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"\r\n        destroy-method=\"close\">\r\n        <!-- 配置驱动程序类 -->\r\n        <property  />\r\n        <!-- 配置连接数据库的URL -->\r\n        <property  />\r\n        <!-- 配置访问数据库的用户名 -->\r\n        <property  />\r\n        <!-- 配置访问数据库的口令 -->\r\n        <property  />\r\n        <!-- 配置最大连接数 -->\r\n        <property  />\r\n        <!-- 配置最小空闲连接数 -->\r\n        <property  />\r\n        <!-- 配置最大空闲连接数 -->\r\n        <property  />\r\n        <!-- 配置初始连接数 -->\r\n        <property  />\r\n        <!-- 配置连接被泄露时是否生成日志 -->\r\n        <property  />\r\n        <!-- 配置是否删除超时连接 -->\r\n        <property  />\r\n        <!-- 配置删除超时连接的超时门限值(以秒为单位) -->\r\n        <property  />\r\n        <!-- 配置超时等待时间(以毫秒为单位) -->\r\n        <property  />\r\n        <!-- 配置空闲连接回收器线程运行的时间间隔(以毫秒为单位) -->\r\n        <property  />\r\n        <!-- 配置连接空闲多长时间后(以毫秒为单位)被断开连接 -->\r\n        <property  />\r\n    </bean>\r\n\r\n    <!-- 配置Spring提供的支持注解ORM映射的Hibernate会话工厂 -->\r\n    <bean id=\"sessionFactory\"\r\n        class=\"org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean\">\r\n        <!-- 通过setter注入数据源属性 -->\r\n        <property  />\r\n        <!-- 配置实体类所在的包 -->\r\n        <property  />\r\n        <!-- 配置Hibernate的相关属性 -->\r\n        <property >\r\n            <!-- 在项目调试完成后要删除show_sql和format_sql属性否则对性能有显著影响 -->\r\n            <value>\r\n                hibernate.dialect=org.hibernate.dialect.MySQL5Dialect\r\n            </value>\r\n        </property>\r\n    </bean>\r\n\r\n    <!-- 配置Spring提供的Hibernate事务管理器 -->\r\n    <bean id=\"transactionManager\"\r\n        class=\"org.springframework.orm.hibernate3.HibernateTransactionManager\">\r\n        <!-- 通过setter注入Hibernate会话工厂 -->\r\n        <property  />\r\n    </bean>\r\n\r\n    <!-- 配置基于注解配置声明式事务 -->\r\n    <tx:annotation-driven />\r\n\r\n</beans>\r\n```\r\n\r\n```\r\npackage com.jackfrued.dao;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.List;\r\n\r\nimport com.jackfrued.comm.QueryBean;\r\nimport com.jackfrued.comm.QueryResult;\r\n\r\n/**\r\n * 数据访问对象接口(以对象为单位封装CRUD操作)\r\n * @author 骆昊\r\n *\r\n * @param <E> 实体类型\r\n * @param <K> 实体标识字段的类型\r\n */\r\npublic interface BaseDao <E, K extends Serializable> {\r\n\r\n    /**\r\n     * 新增\r\n     * @param entity 业务实体对象\r\n     * @return 增加成功返回实体对象的标识\r\n     */\r\n    public K save(E entity);\r\n\r\n    /**\r\n     * 删除\r\n     * @param entity 业务实体对象\r\n     */\r\n    public void delete(E entity);\r\n\r\n    /**\r\n     * 根据ID删除\r\n     * @param id 业务实体对象的标识\r\n     * @return 删除成功返回true否则返回false\r\n     */\r\n    public boolean deleteById(K id);\r\n\r\n    /**\r\n     * 修改\r\n     * @param entity 业务实体对象\r\n     * @return 修改成功返回true否则返回false\r\n     */\r\n    public void update(E entity);\r\n\r\n    /**\r\n     * 根据ID查找业务实体对象\r\n     * @param id 业务实体对象的标识\r\n     * @return 业务实体对象对象或null\r\n     */\r\n    public E findById(K id);\r\n\r\n    /**\r\n     * 根据ID查找业务实体对象\r\n     * @param id 业务实体对象的标识\r\n     * @param lazy 是否使用延迟加载\r\n     * @return 业务实体对象对象\r\n     */\r\n    public E findById(K id, boolean lazy);\r\n\r\n    /**\r\n     * 查找所有业务实体对象\r\n     * @return 装所有业务实体对象的列表容器\r\n     */\r\n    public List<E> findAll();\r\n\r\n    /**\r\n     * 分页查找业务实体对象\r\n     * @param page 页码\r\n     * @param size 页面大小\r\n     * @return 查询结果对象\r\n     */\r\n    public QueryResult<E> findByPage(int page, int size);\r\n\r\n    /**\r\n     * 分页查找业务实体对象\r\n     * @param queryBean 查询条件对象\r\n     * @param page 页码\r\n     * @param size 页面大小\r\n     * @return 查询结果对象\r\n     */\r\n    public QueryResult<E> findByPage(QueryBean queryBean, int page, int size);\r\n\r\n}\r\n```\r\n\r\n```\r\npackage com.jackfrued.dao;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.List;\r\n\r\nimport com.jackfrued.comm.QueryBean;\r\nimport com.jackfrued.comm.QueryResult;\r\n\r\n/**\r\n * BaseDao的缺省适配器\r\n * @author 骆昊\r\n *\r\n * @param <E> 实体类型\r\n * @param <K> 实体标识字段的类型\r\n */\r\npublic abstract class BaseDaoAdapter<E, K extends Serializable> implements\r\n        BaseDao<E, K> {\r\n\r\n    @Override\r\n    public K save(E entity) {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public void delete(E entity) {\r\n    }\r\n\r\n    @Override\r\n    public boolean deleteById(K id) {\r\n        E entity = findById(id);\r\n        if(entity != null) {\r\n            delete(entity);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public void update(E entity) {\r\n    }\r\n\r\n    @Override\r\n    public E findById(K id) {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public E findById(K id, boolean lazy) {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public List<E> findAll() {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public QueryResult<E> findByPage(int page, int size) {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public QueryResult<E> findByPage(QueryBean queryBean, int page, int size) {\r\n        return null;\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n```\r\npackage com.jackfrued.dao;\r\n\r\nimport java.io.Serializable;\r\nimport java.lang.reflect.ParameterizedType;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n\r\nimport org.hibernate.Query;\r\nimport org.hibernate.Session;\r\nimport org.hibernate.SessionFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\n\r\nimport com.jackfrued.comm.HQLQueryBean;\r\nimport com.jackfrued.comm.QueryBean;\r\nimport com.jackfrued.comm.QueryResult;\r\n\r\n/**\r\n * 基于Hibernate的BaseDao实现类\r\n * @author 骆昊\r\n *\r\n * @param <E> 实体类型\r\n * @param <K> 主键类型\r\n */\r\n@SuppressWarnings(value = {\"unchecked\"})\r\npublic abstract class BaseDaoHibernateImpl<E, K extends Serializable> extends BaseDaoAdapter<E, K> {\r\n    @Autowired\r\n    protected SessionFactory sessionFactory;\r\n\r\n    private Class<?> entityClass;       // 业务实体的类对象\r\n    private String entityName;          // 业务实体的名字\r\n\r\n    public BaseDaoHibernateImpl() {\r\n        ParameterizedType pt = (ParameterizedType) this.getClass().getGenericSuperclass();\r\n        entityClass = (Class<?>) pt.getActualTypeArguments()[0];\r\n        entityName = entityClass.getSimpleName();\r\n    }\r\n\r\n    @Override\r\n    public K save(E entity) {\r\n        return (K) sessionFactory.getCurrentSession().save(entity);\r\n    }\r\n\r\n    @Override\r\n    public void delete(E entity) {\r\n        sessionFactory.getCurrentSession().delete(entity);\r\n    }\r\n\r\n    @Override\r\n    public void update(E entity) {\r\n        sessionFactory.getCurrentSession().update(entity);\r\n    }\r\n\r\n    @Override\r\n    public E findById(K id) {\r\n        return findById(id, false);\r\n    }\r\n\r\n    @Override\r\n    public E findById(K id, boolean lazy) {\r\n        Session session = sessionFactory.getCurrentSession();\r\n        return (E) (lazy? session.load(entityClass, id) : session.get(entityClass, id));\r\n    }\r\n\r\n    @Override\r\n    public List<E> findAll() {\r\n        return sessionFactory.getCurrentSession().createCriteria(entityClass).list();\r\n    }\r\n\r\n    @Override\r\n    public QueryResult<E> findByPage(int page, int size) {\r\n        return new QueryResult<E>(\r\n            findByHQLAndPage(\"from \" + entityName , page, size),\r\n            getCountByHQL(\"select count(*) from \" + entityName)\r\n        );\r\n    }\r\n\r\n    @Override\r\n    public QueryResult<E> findByPage(QueryBean queryBean, int page, int size) {\r\n        if(queryBean instanceof HQLQueryBean) {\r\n            HQLQueryBean hqlQueryBean = (HQLQueryBean) queryBean;\r\n            return new QueryResult<E>(\r\n                findByHQLAndPage(hqlQueryBean.getQueryString(), page, size, hqlQueryBean.getParameters()),\r\n                getCountByHQL(hqlQueryBean.getCountString(), hqlQueryBean.getParameters())\r\n            );\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * 根据HQL和可变参数列表进行查询\r\n     * @param hql 基于HQL的查询语句\r\n     * @param params 可变参数列表\r\n     * @return 持有查询结果的列表容器或空列表容器\r\n     */\r\n    protected List<E> findByHQL(String hql, Object... params) {\r\n        return this.findByHQL(hql, getParamList(params));\r\n    }\r\n\r\n    /**\r\n     * 根据HQL和参数列表进行查询\r\n     * @param hql 基于HQL的查询语句\r\n     * @param params 查询参数列表\r\n     * @return 持有查询结果的列表容器或空列表容器\r\n     */\r\n    protected List<E> findByHQL(String hql, List<Object> params) {\r\n        List<E> list = createQuery(hql, params).list();\r\n        return list != null && list.size() > 0 ? list : Collections.EMPTY_LIST;\r\n    }\r\n\r\n    /**\r\n     * 根据HQL和参数列表进行分页查询\r\n     * @param hql 基于HQL的查询语句\r\n     * @page 页码\r\n     * @size 页面大小\r\n     * @param params 可变参数列表\r\n     * @return 持有查询结果的列表容器或空列表容器\r\n     */\r\n    protected List<E> findByHQLAndPage(String hql, int page, int size, Object... params) {\r\n        return this.findByHQLAndPage(hql, page, size, getParamList(params));\r\n    }\r\n\r\n    /**\r\n     * 根据HQL和参数列表进行分页查询\r\n     * @param hql 基于HQL的查询语句\r\n     * @page 页码\r\n     * @size 页面大小\r\n     * @param params 查询参数列表\r\n     * @return 持有查询结果的列表容器或空列表容器\r\n     */\r\n    protected List<E> findByHQLAndPage(String hql, int page, int size, List<Object> params) {\r\n        List<E> list = createQuery(hql, params)\r\n                .setFirstResult((page - 1) * size)\r\n                .setMaxResults(size)\r\n                .list();\r\n        return list != null && list.size() > 0 ? list : Collections.EMPTY_LIST;\r\n    }\r\n\r\n    /**\r\n     * 查询满足条件的记录数\r\n     * @param hql 基于HQL的查询语句\r\n     * @param params 可变参数列表\r\n     * @return 满足查询条件的总记录数\r\n     */\r\n    protected long getCountByHQL(String hql, Object... params) {\r\n        return this.getCountByHQL(hql, getParamList(params));\r\n    }\r\n\r\n    /**\r\n     * 查询满足条件的记录数\r\n     * @param hql 基于HQL的查询语句\r\n     * @param params 参数列表容器\r\n     * @return 满足查询条件的总记录数\r\n     */\r\n    protected long getCountByHQL(String hql, List<Object> params) {\r\n        return (Long) createQuery(hql, params).uniqueResult();\r\n    }\r\n\r\n    // 创建Hibernate查询对象(Query)\r\n    private Query createQuery(String hql, List<Object> params) {\r\n        Query query = sessionFactory.getCurrentSession().createQuery(hql);\r\n        for(int i = 0; i < params.size(); i++) {\r\n            query.setParameter(i, params.get(i));\r\n        }\r\n        return query;\r\n    }\r\n\r\n    // 将可变参数列表组装成列表容器\r\n    private List<Object> getParamList(Object... params) {\r\n        List<Object> paramList = new ArrayList<>();\r\n        if(params != null) {\r\n            for(int i = 0; i < params.length; i++) {\r\n                paramList.add(params[i]);\r\n            }\r\n        }\r\n        return paramList.size() == 0? Collections.EMPTY_LIST : paramList;\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n```\r\npackage com.jackfrued.comm;\r\n\r\nimport java.util.List;\r\n\r\n/**\r\n * 查询条件的接口\r\n * @author 骆昊\r\n *\r\n */\r\npublic interface QueryBean {\r\n\r\n    /**\r\n     * 添加排序字段\r\n     * @param fieldName 用于排序的字段\r\n     * @param asc 升序还是降序\r\n     * @return 查询条件对象自身(方便级联编程)\r\n     */\r\n    public QueryBean addOrder(String fieldName, boolean asc);\r\n\r\n    /**\r\n     * 添加排序字段\r\n     * @param available 是否添加此排序字段\r\n     * @param fieldName 用于排序的字段\r\n     * @param asc 升序还是降序\r\n     * @return 查询条件对象自身(方便级联编程)\r\n     */\r\n    public QueryBean addOrder(boolean available, String fieldName, boolean asc);\r\n\r\n    /**\r\n     * 添加查询条件\r\n     * @param condition 条件\r\n     * @param params 替换掉条件中参数占位符的参数\r\n     * @return 查询条件对象自身(方便级联编程)\r\n     */\r\n    public QueryBean addCondition(String condition, Object... params);\r\n\r\n    /**\r\n     * 添加查询条件\r\n     * @param available 是否需要添加此条件\r\n     * @param condition 条件\r\n     * @param params 替换掉条件中参数占位符的参数\r\n     * @return 查询条件对象自身(方便级联编程)\r\n     */\r\n    public QueryBean addCondition(boolean available, String condition, Object... params);\r\n\r\n    /**\r\n     * 获得查询语句\r\n     * @return 查询语句\r\n     */\r\n    public String getQueryString();\r\n\r\n    /**\r\n     * 获取查询记录数的查询语句\r\n     * @return 查询记录数的查询语句\r\n     */\r\n    public String getCountString();\r\n\r\n    /**\r\n     * 获得查询参数\r\n     * @return 查询参数的列表容器\r\n     */\r\n    public List<Object> getParameters();\r\n}\r\n```\r\n\r\n```\r\npackage com.jackfrued.comm;\r\n\r\nimport java.util.List;\r\n\r\n/**\r\n * 查询结果\r\n * @author 骆昊\r\n *\r\n * @param <T> 泛型参数\r\n */\r\npublic class QueryResult<T> {\r\n    private List<T> result;     // 持有查询结果的列表容器\r\n    private long totalRecords;  // 查询到的总记录数\r\n\r\n    /**\r\n     * 构造器\r\n     */\r\n    public QueryResult() {\r\n    }\r\n\r\n    /**\r\n     * 构造器\r\n     * @param result 持有查询结果的列表容器\r\n     * @param totalRecords 查询到的总记录数\r\n     */\r\n    public QueryResult(List<T> result, long totalRecords) {\r\n        this.result = result;\r\n        this.totalRecords = totalRecords;\r\n    }\r\n\r\n    public List<T> getResult() {\r\n        return result;\r\n    }\r\n\r\n    public void setResult(List<T> result) {\r\n        this.result = result;\r\n    }\r\n\r\n    public long getTotalRecords() {\r\n        return totalRecords;\r\n    }\r\n\r\n    public void setTotalRecords(long totalRecords) {\r\n        this.totalRecords = totalRecords;\r\n    }\r\n}\r\n```\r\n\r\n```\r\npackage com.jackfrued.dao;\r\n\r\nimport com.jackfrued.comm.QueryResult;\r\nimport com.jackfrued.entity.Dept;\r\n\r\n/**\r\n * 部门数据访问对象接口\r\n * @author 骆昊\r\n *\r\n */\r\npublic interface DeptDao extends BaseDao<Dept, Integer> {\r\n\r\n    /**\r\n     * 分页查询顶级部门\r\n     * @param page 页码\r\n     * @param size 页码大小\r\n     * @return 查询结果对象\r\n     */\r\n    public QueryResult<Dept> findTopDeptByPage(int page, int size);\r\n\r\n}\r\n```\r\n\r\n```\r\npackage com.jackfrued.dao.impl;\r\n\r\nimport java.util.List;\r\n\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport com.jackfrued.comm.QueryResult;\r\nimport com.jackfrued.dao.BaseDaoHibernateImpl;\r\nimport com.jackfrued.dao.DeptDao;\r\nimport com.jackfrued.entity.Dept;\r\n\r\n@Repository\r\npublic class DeptDaoImpl extends BaseDaoHibernateImpl<Dept, Integer> implements DeptDao {\r\n    private static final String HQL_FIND_TOP_DEPT = \" from Dept as d where d.superiorDept is null \";\r\n\r\n    @Override\r\n    public QueryResult<Dept> findTopDeptByPage(int page, int size) {\r\n        List<Dept> list = findByHQLAndPage(HQL_FIND_TOP_DEPT, page, size);\r\n        long totalRecords = getCountByHQL(\" select count(*) \" + HQL_FIND_TOP_DEPT);\r\n        return new QueryResult<>(list, totalRecords);\r\n    }\r\n\r\n}\r\n```\r\n\r\n```\r\npackage com.jackfrued.comm;\r\n\r\nimport java.util.List;\r\n\r\n/**\r\n * 分页器\r\n * @author 骆昊\r\n *\r\n * @param <T> 分页数据对象的类型\r\n */\r\npublic class PageBean<T> {\r\n    private static final int DEFAUL_INIT_PAGE = 1;\r\n    private static final int DEFAULT_PAGE_SIZE = 10;\r\n    private static final int DEFAULT_PAGE_COUNT = 5;\r\n\r\n    private List<T> data;           // 分页数据\r\n    private PageRange pageRange;    // 页码范围\r\n    private int totalPage;          // 总页数\r\n    private int size;               // 页面大小\r\n    private int currentPage;        // 当前页码\r\n    private int pageCount;          // 页码数量\r\n\r\n    /**\r\n     * 构造器\r\n     * @param currentPage 当前页码\r\n     * @param size 页码大小\r\n     * @param pageCount 页码数量\r\n     */\r\n    public PageBean(int currentPage, int size, int pageCount) {\r\n        this.currentPage = currentPage > 0 ? currentPage : 1;\r\n        this.size = size > 0 ? size : DEFAULT_PAGE_SIZE;\r\n        this.pageCount = pageCount > 0 ? size : DEFAULT_PAGE_COUNT;\r\n    }\r\n\r\n    /**\r\n     * 构造器\r\n     * @param currentPage 当前页码\r\n     * @param size 页码大小\r\n     */\r\n    public PageBean(int currentPage, int size) {\r\n        this(currentPage, size, DEFAULT_PAGE_COUNT);\r\n    }\r\n\r\n    /**\r\n     * 构造器\r\n     * @param currentPage 当前页码\r\n     */\r\n    public PageBean(int currentPage) {\r\n        this(currentPage, DEFAULT_PAGE_SIZE, DEFAULT_PAGE_COUNT);\r\n    }\r\n\r\n    /**\r\n     * 构造器\r\n     */\r\n    public PageBean() {\r\n        this(DEFAUL_INIT_PAGE, DEFAULT_PAGE_SIZE, DEFAULT_PAGE_COUNT);\r\n    }\r\n\r\n    public List<T> getData() {\r\n        return data;\r\n    }\r\n\r\n    public int getStartPage() {\r\n        return pageRange != null ? pageRange.getStartPage() : 1;\r\n    }\r\n\r\n    public int getEndPage() {\r\n        return pageRange != null ? pageRange.getEndPage() : 1;\r\n    }\r\n\r\n    public long getTotalPage() {\r\n        return totalPage;\r\n    }\r\n\r\n    public int getSize() {\r\n        return size;\r\n    }\r\n\r\n    public int getCurrentPage() {\r\n        return currentPage;\r\n    }\r\n\r\n    /**\r\n     * 将查询结果转换为分页数据\r\n     * @param queryResult 查询结果对象\r\n     */\r\n    public void transferQueryResult(QueryResult<T> queryResult) {\r\n        long totalRecords = queryResult.getTotalRecords();\r\n\r\n        data = queryResult.getResult();\r\n        totalPage = (int) ((totalRecords + size - 1) / size); \r\n        totalPage = totalPage >= 0 ? totalPage : Integer.MAX_VALUE;\r\n        this.pageRange = new PageRange(pageCount, currentPage, totalPage);\r\n    }\r\n\r\n}\r\n```\r\n\r\n```\r\npackage com.jackfrued.comm;\r\n\r\n/**\r\n * 页码范围\r\n * @author 骆昊\r\n *\r\n */\r\npublic class PageRange {\r\n    private int startPage;  // 起始页码\r\n    private int endPage;    // 终止页码\r\n\r\n    /**\r\n     * 构造器\r\n     * @param pageCount 总共显示几个页码\r\n     * @param currentPage 当前页码\r\n     * @param totalPage 总页数\r\n     */\r\n    public PageRange(int pageCount, int currentPage, int totalPage) {\r\n        startPage = currentPage - (pageCount - 1) / 2;\r\n        endPage = currentPage + pageCount / 2;\r\n        if(startPage < 1) {\r\n            startPage = 1;\r\n            endPage = totalPage > pageCount ? pageCount : totalPage;\r\n        }\r\n        if (endPage > totalPage) {\r\n            endPage = totalPage;\r\n            startPage = (endPage - pageCount > 0) ? endPage - pageCount + 1 : 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获得起始页页码\r\n     * @return 起始页页码\r\n     */\r\n    public int getStartPage() {\r\n        return startPage;\r\n    }\r\n\r\n    /**\r\n     * 获得终止页页码\r\n     * @return 终止页页码\r\n     */\r\n    public int getEndPage() {\r\n        return endPage;\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n```\r\npackage com.jackfrued.biz;\r\n\r\nimport com.jackfrued.comm.PageBean;\r\nimport com.jackfrued.entity.Dept;\r\n\r\n/**\r\n * 部门业务逻辑接口\r\n * @author 骆昊\r\n *\r\n */\r\npublic interface DeptService {\r\n\r\n    /**\r\n     * 创建新的部门\r\n     * @param department 部门对象\r\n     * @return 创建成功返回true否则返回false\r\n     */\r\n    public boolean createNewDepartment(Dept department);\r\n\r\n    /**\r\n     * 删除指定部门\r\n     * @param id 要删除的部门的编号\r\n     * @return 删除成功返回true否则返回false\r\n     */\r\n    public boolean deleteDepartment(Integer id);\r\n\r\n    /**\r\n     * 分页获取顶级部门\r\n     * @param page 页码\r\n     * @param size 页码大小\r\n     * @return 部门对象的分页器对象\r\n     */\r\n    public PageBean<Dept> getTopDeptByPage(int page, int size);\r\n\r\n}\r\n```\r\n\r\n```\r\npackage com.jackfrued.biz.impl;\r\n\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.annotation.Transactional;\r\n\r\nimport com.jackfrued.biz.DeptService;\r\nimport com.jackfrued.comm.PageBean;\r\nimport com.jackfrued.comm.QueryResult;\r\nimport com.jackfrued.dao.DeptDao;\r\nimport com.jackfrued.entity.Dept;\r\n\r\n@Service\r\n@Transactional  // 声明式事务的注解\r\npublic class DeptServiceImpl implements DeptService {\r\n    @Autowired\r\n    private DeptDao deptDao;\r\n\r\n    @Override\r\n    public boolean createNewDepartment(Dept department) {\r\n        return deptDao.save(department) != null;\r\n    }\r\n\r\n    @Override\r\n    public boolean deleteDepartment(Integer id) {\r\n        return deptDao.deleteById(id);\r\n    }\r\n\r\n    @Override\r\n    public PageBean<Dept> getTopDeptByPage(int page, int size) {\r\n        QueryResult<Dept> queryResult = deptDao.findTopDeptByPage(page, size);\r\n        PageBean<Dept> pageBean = new PageBean<>(page, size);\r\n        pageBean.transferQueryResult(queryResult);\r\n        return pageBean;\r\n    }\r\n\r\n}\r\n```\r\n\r\n**154、如何在 Web 项目中配置 Spring 的 IoC 容器？**\r\n答：如果需要在 Web 项目中使用 Spring 的 IoC 容器，可以在 Web 项目配置文件 web.xml 中做出如下配置：\r\n\r\n```\r\n<context-param>\r\n    <param-name>contextConfigLocation</param-name>\r\n    <param-value>classpath:applicationContext.xml</param-value>\r\n</context-param>\r\n\r\n<listener>\r\n    <listener-class>\r\n        org.springframework.web.context.ContextLoaderListener\r\n    </listener-class>\r\n</listener>\r\n```\r\n\r\n**155、如何在 Web 项目中配置 Spring MVC？**\r\n答：要使用 Spring MVC 需要在 Web 项目配置文件中配置其前端控制器 DispatcherServlet，如下所示：\r\n\r\n```\r\n<web-app>\r\n\r\n    <servlet>\r\n        <servlet-name>example</servlet-name>\r\n        <servlet-class>\r\n            org.springframework.web.servlet.DispatcherServlet\r\n        </servlet-class>\r\n        <load-on-startup>1</load-on-startup>\r\n    </servlet>\r\n\r\n    <servlet-mapping>\r\n        <servlet-name>example</servlet-name>\r\n        <url-pattern>*.html</url-pattern>\r\n    </servlet-mapping>\r\n\r\n</web-app>\r\n```\r\n\r\n> **说明：**上面的配置中使用了 *.html 的后缀映射，这样做一方面不能够通过 URL 推断采用了何种服务器端的技术，另一方面可以欺骗搜索引擎，因为搜索引擎不会搜索动态页面，这种做法称为伪静态化。\r\n\r\n**156、Spring MVC 的工作原理是怎样的？**\r\n答：Spring MVC 的工作原理如下图所示：\r\n\r\n① 客户端的所有请求都交给前端控制器 DispatcherServlet 来处理，它会负责调用系统的其他模块来真正处理用户的请求。\r\n② DispatcherServlet 收到请求后，将根据请求的信息（包括 URL、HTTP 协议方法、请求头、请求参数、Cookie 等）以及 HandlerMapping 的配置找到处理该请求的 Handler（任何一个对象都可以作为请求的 Handler）。\r\n③在这个地方 Spring 会通过 HandlerAdapter 对该处理器进行封装。\r\n④ HandlerAdapter 是一个适配器，它用统一的接口对各种 Handler 中的方法进行调用。\r\n⑤ Handler 完成对用户请求的处理后，会返回一个 ModelAndView 对象给 DispatcherServlet，ModelAndView 顾名思义，包含了数据模型以及相应的视图的信息。\r\n⑥ ModelAndView 的视图是逻辑视图，DispatcherServlet 还要借助 ViewResolver 完成从逻辑视图到真实视图对象的解析工作。\r\n⑦ 当得到真正的视图对象后，DispatcherServlet 会利用视图对象对模型数据进行渲染。\r\n⑧ 客户端得到响应，可能是一个普通的 HTML 页面，也可以是 XML 或 JSON 字符串，还可以是一张图片或者一个 PDF 文件。\r\n\r\n**157、如何在 Spring IoC 容器中配置数据源？**\r\n答：\r\nDBCP 配置：\r\n\r\n```\r\n<bean id=\"dataSource\"\r\n        class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\r\n    <property ${jdbc.driverClassName}\"/>\r\n    <property ${jdbc.url}\"/>\r\n    <property ${jdbc.username}\"/>\r\n    <property ${jdbc.password}\"/>\r\n</bean>\r\n\r\n<context:property-placeholder location=\"jdbc.properties\"/>\r\n```\r\n\r\nC3P0 配置：\r\n\r\n```\r\n<bean id=\"dataSource\"\r\n        class=\"com.mchange.v2.c3p0.ComboPooledDataSource\" destroy-method=\"close\">\r\n    <property ${jdbc.driverClassName}\"/>\r\n    <property ${jdbc.url}\"/>\r\n    <property ${jdbc.username}\"/>\r\n    <property ${jdbc.password}\"/>\r\n</bean>\r\n\r\n<context:property-placeholder location=\"jdbc.properties\"/>\r\n```\r\n\r\n> **提示：** DBCP 的详细配置在第 153 题中已经完整的展示过了。\r\n\r\n**158、如何配置配置事务增强？**\r\n答：\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n     xmlns:aop=\"http://www.springframework.org/schema/aop\"\r\n     xmlns:tx=\"http://www.springframework.org/schema/tx\"\r\n     xsi:schemaLocation=\"\r\n     http://www.springframework.org/schema/beans\r\n     http://www.springframework.org/schema/beans/spring-beans.xsd\r\n     http://www.springframework.org/schema/tx\r\n     http://www.springframework.org/schema/tx/spring-tx.xsd\r\n     http://www.springframework.org/schema/aop\r\n     http://www.springframework.org/schema/aop/spring-aop.xsd\">\r\n\r\n  <!-- this is the service object that we want to make transactional -->\r\n  <bean id=\"fooService\" class=\"x.y.service.DefaultFooService\"/>\r\n\r\n  <!-- the transactional advice -->\r\n  <tx:advice id=\"txAdvice\" transaction-manager=\"txManager\">\r\n  <!-- the transactional semantics... -->\r\n  <tx:attributes>\r\n    <!-- all methods starting with \'get\' are read-only -->\r\n    <tx:method />\r\n    <!-- other methods use the default transaction settings (see below) -->\r\n    <tx:method />\r\n  </tx:attributes>\r\n  </tx:advice>\r\n\r\n  <!-- ensure that the above transactional advice runs for any execution\r\n    of an operation defined by the FooService interface -->\r\n  <aop:config>\r\n  <aop:pointcut id=\"fooServiceOperation\" \r\n    expression=\"execution(* x.y.service.FooService.*(..))\"/>\r\n  <aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"fooServiceOperation\"/>\r\n  </aop:config>\r\n\r\n  <!-- don\'t forget the DataSource -->\r\n  <bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" \r\n    destroy-method=\"close\">\r\n  <property />\r\n  <property jdbc:oracle:thin:@localhost:1521:orcl\"/>\r\n  <property />\r\n  <property />\r\n  </bean>\r\n\r\n  <!-- similarly, don\'t forget the PlatformTransactionManager -->\r\n  <bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\r\n  <property />\r\n  </bean>\r\n\r\n  <!-- other <bean/> definitions here -->\r\n\r\n</beans>\r\n```\r\n\r\n**159、选择使用 Spring 框架的原因（Spring 框架为企业级开发带来的好处有哪些）？**\r\n答：可以从以下几个方面作答：\r\n- 非侵入式：支持基于 POJO 的编程模式，不强制性的要求实现 Spring 框架中的接口或继承 Spring 框架中的类。\r\n- IoC 容器：IoC 容器帮助应用程序管理对象以及对象之间的依赖关系，对象之间的依赖关系如果发生了改变只需要修改配置文件而不是修改代码，因为代码的修改可能意味着项目的重新构建和完整的回归测试。有了 IoC 容器，程序员再也不需要自己编写工厂、单例，这一点特别符合 Spring 的精神 \"不要重复的发明轮子\"。\r\n- AOP（面向切面编程）：将所有的横切关注功能封装到切面（aspect）中，通过配置的方式将横切关注功能动态添加到目标代码上，进一步实现了业务逻辑和系统服务之间的分离。另一方面，有了 AOP 程序员可以省去很多自己写代理类的工作。\r\n- MVC：Spring 的 MVC 框架是非常优秀的，从各个方面都可以甩 Struts 2 几条街，为 Web 表示层提供了更好的解决方案。\r\n- 事务管理：Spring 以宽广的胸怀接纳多种持久层技术，并且为其提供了声明式的事务管理，在不需要任何一行代码的情况下就能够完成事务管理。\r\n- 其他：选择 Spring 框架的原因还远不止于此，Spring 为 Java 企业级开发提供了一站式选择，你可以在需要的时候使用它的部分和全部，更重要的是，你甚至可以在感觉不到 Spring 存在的情况下，在你的项目中使用 Spring 提供的各种优秀的功能。\r\n\r\n**160、Spring IoC 容器配置 Bean 的方式？**\r\n答：\r\n- 基于 XML 文件进行配置。\r\n- 基于注解进行配置。\r\n- 基于 Java 程序进行配置（Spring 3+）\r\n\r\n```\r\npackage com.jackfrued.bean;\r\n\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Component\r\npublic class Person {\r\n    private String name;\r\n    private int age;\r\n    @Autowired\r\n    private Car car;\r\n\r\n    public Person(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    public void setCar(Car car) {\r\n        this.car = car;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Person []\";\r\n    }\r\n\r\n}\r\n```\r\n\r\n```\r\npackage com.jackfrued.bean;\r\n\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Component\r\npublic class Car {\r\n    private String brand;\r\n    private int maxSpeed;\r\n\r\n    public Car(String brand, int maxSpeed) {\r\n        this.brand = brand;\r\n        this.maxSpeed = maxSpeed;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Car [brand=\" + brand + \", maxSpeed=\" + maxSpeed + \"]\";\r\n    }\r\n\r\n}\r\n```\r\n\r\n```\r\npackage com.jackfrued.config;\r\n\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\n\r\nimport com.jackfrued.bean.Car;\r\nimport com.jackfrued.bean.Person;\r\n\r\n@Configuration\r\npublic class AppConfig {\r\n\r\n    @Bean\r\n    public Car car() {\r\n        return new Car(\"Benz\", 320);\r\n    }\r\n\r\n    @Bean\r\n    public Person person() {\r\n        return new Person(\"骆昊\", 34);\r\n    }\r\n}\r\n```\r\n\r\n```\r\npackage com.jackfrued.test;\r\n\r\nimport org.springframework.context.ConfigurableApplicationContext;\r\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\r\n\r\nimport com.jackfrued.bean.Person;\r\nimport com.jackfrued.config.AppConfig;\r\n\r\nclass Test {\r\n\r\n    public static void main(String[] args) {\r\n        // TWR (Java 7+)\r\n        try(ConfigurableApplicationContext factory = new AnnotationConfigApplicationContext(AppConfig.class)) {\r\n            Person person = factory.getBean(Person.class);\r\n            System.out.println(person);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**161、阐述 Spring 框架中 Bean 的生命周期？**\r\n答：\r\n① Spring IoC 容器找到关于 Bean 的定义并实例化该 Bean。\r\n② Spring IoC 容器对 Bean 进行依赖注入。\r\n③ 如果 Bean 实现了 BeanNameAware 接口，则将该 Bean 的 id 传给 setBeanName 方法。\r\n④ 如果 Bean 实现了 BeanFactoryAware 接口，则将 BeanFactory 对象传给 setBeanFactory 方法。\r\n⑤ 如果 Bean 实现了 BeanPostProcessor 接口，则调用其 postProcessBeforeInitialization 方法。\r\n⑥ 如果 Bean 实现了 InitializingBean 接口，则调用其 afterPropertySet 方法。\r\n⑦ 如果有和 Bean 关联的 BeanPostProcessors 对象，则这些对象的 postProcessAfterInitialization 方法被调用。\r\n⑧ 当销毁 Bean 实例时，如果 Bean 实现了 DisposableBean 接口，则调用其 destroy 方法。\r\n\r\n**162、依赖注入时如何注入集合属性？**\r\n答：可以在定义 Bean 属性时，通过 <list> / <set> / <map> / <props > 分别为其注入列表、集合、映射和键值都是字符串的映射属性。\r\n\r\n**163、Spring 中的自动装配有哪些限制？**\r\n答：\r\n- 如果使用了构造器注入或者 setter 注入，那么将覆盖自动装配的依赖关系。\r\n- 基本数据类型的值、字符串字面量、类字面量无法使用自动装配来注入。\r\n- 优先考虑使用显式的装配来进行更精确的依赖注入而不是使用自动装配。\r\n\r\n**164、在 Web 项目中如何获得 Spring 的 IoC 容器？**\r\n答：\r\n\r\n```\r\nWebApplicationContext ctx = \r\nWebApplicationContextUtils.getWebApplicationContext(servletContext);\r\n```\r\n\r\n**165\\. 大型网站在架构上应当考虑哪些问题？**\r\n答：\r\n- 分层：分层是处理任何复杂系统最常见的手段之一，将系统横向切分成若干个层面，每个层面只承担单一的职责，然后通过下层为上层提供的基础设施和服务以及上层对下层的调用来形成一个完整的复杂的系统。计算机网络的开放系统互联参考模型（OSI/RM）和 Internet 的 TCP/IP 模型都是分层结构，大型网站的软件系统也可以使用分层的理念将其分为持久层（提供数据存储和访问服务）、业务层（处理业务逻辑，系统中最核心的部分）和表示层（系统交互、视图展示）。需要指出的是：（1）分层是逻辑上的划分，在物理上可以位于同一设备上也可以在不同的设备上部署不同的功能模块，这样可以使用更多的计算资源来应对用户的并发访问；（2）层与层之间应当有清晰的边界，这样分层才有意义，才更利于软件的开发和维护。\r\n- 分割：分割是对软件的纵向切分。我们可以将大型网站的不同功能和服务分割开，形成高内聚低耦合的功能模块（单元）。在设计初期可以做一个粗粒度的分割，将网站分割为若干个功能模块，后期还可以进一步对每个模块进行细粒度的分割，这样一方面有助于软件的开发和维护，另一方面有助于分布式的部署，提供网站的并发处理能力和功能的扩展。\r\n- 分布式：除了上面提到的内容，网站的静态资源（JavaScript、CSS、图片等）也可以采用独立分布式部署并采用独立的域名，这样可以减轻应用服务器的负载压力，也使得浏览器对资源的加载更快。数据的存取也应该是分布式的，传统的商业级关系型数据库产品基本上都支持分布式部署，而新生的 NoSQL 产品几乎都是分布式的。当然，网站后台的业务处理也要使用分布式技术，例如查询索引的构建、数据分析等，这些业务计算规模庞大，可以使用 Hadoop 以及 MapReduce 分布式计算框架来处理。\r\n- 集群：集群使得有更多的服务器提供相同的服务，可以更好的提供对并发的支持。\r\n- 缓存：所谓缓存就是用空间换取时间的技术，将数据尽可能放在距离计算最近的位置。使用缓存是网站优化的第一定律。我们通常说的 CDN、反向代理、热点数据都是对缓存技术的使用。\r\n- 异步：异步是实现软件实体之间解耦合的又一重要手段。异步架构是典型的生产者消费者模式，二者之间没有直接的调用关系，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站的扩展非常有利。使用异步处理还可以提高系统可用性，加快网站的响应速度（用 Ajax 加载数据就是一种异步技术），同时还可以起到削峰作用（应对瞬时高并发）。&quot；能推迟处理的都要推迟处理 \" 是网站优化的第二定律，而异步是践行网站优化第二定律的重要手段。\r\n- 冗余：各种服务器都要提供相应的冗余服务器以便在某台或某些服务器宕机时还能保证网站可以正常工作，同时也提供了灾难恢复的可能性。冗余是网站高可用性的重要保证。\r\n\r\n**166、你用过的网站前端优化的技术有哪些？**\r\n答：\r\n① 浏览器访问优化：\r\n- 减少 HTTP 请求数量：合并 CSS、合并 JavaScript、合并图片（CSS Sprite）\r\n- 使用浏览器缓存：通过设置 HTTP 响应头中的 Cache-Control 和 Expires 属性，将 CSS、JavaScript、图片等在浏览器中缓存，当这些静态资源需要更新时，可以更新 HTML 文件中的引用来让浏览器重新请求新的资源\r\n- 启用压缩\r\n- CSS 前置，JavaScript 后置\r\n- 减少 Cookie 传输\r\n② CDN 加速：CDN（Content Distribute Network）的本质仍然是缓存，将数据缓存在离用户最近的地方，CDN 通常部署在网络运营商的机房，不仅可以提升响应速度，还可以减少应用服务器的压力。当然，CDN 缓存的通常都是静态资源。\r\n③ 反向代理：反向代理相当于应用服务器的一个门面，可以保护网站的安全性，也可以实现负载均衡的功能，当然最重要的是它缓存了用户访问的热点资源，可以直接从反向代理将某些内容返回给用户浏览器。\r\n\r\n**167、你使用过的应用服务器优化技术有哪些？**\r\n答：\r\n① 分布式缓存：缓存的本质就是内存中的哈希表，如果设计一个优质的哈希函数，那么理论上哈希表读写的渐近时间复杂度为 O(1)。缓存主要用来存放那些读写比很高、变化很少的数据，这样应用程序读取数据时先到缓存中读取，如果没有或者数据已经失效再去访问数据库或文件系统，并根据拟定的规则将数据写入缓存。对网站数据的访问也符合二八定律（Pareto 分布，幂律分布），即 80% 的访问都集中在 20% 的数据上，如果能够将这 20% 的数据缓存起来，那么系统的性能将得到显著的改善。当然，使用缓存需要解决以下几个问题：\r\n- 频繁修改的数据；\r\n- 数据不一致与脏读；\r\n- 缓存雪崩（可以采用分布式缓存服务器集群加以解决，[memcached](http://memcached.org) 是广泛采用的解决方案）；\r\n- 缓存预热；\r\n- 缓存穿透（恶意持续请求不存在的数据）。\r\n② 异步操作：可以使用消息队列将调用异步化，通过异步处理将短时间高并发产生的事件消息存储在消息队列中，从而起到削峰作用。电商网站在进行促销活动时，可以将用户的订单请求存入消息队列，这样可以抵御大量的并发订单请求对系统和数据库的冲击。目前，绝大多数的电商网站即便不进行促销活动，订单系统都采用了消息队列来处理。\r\n③ 使用集群。\r\n④ 代码优化：\r\n- 多线程：基于 Java 的 Web 开发基本上都通过多线程的方式响应用户的并发请求，使用多线程技术在编程上要解决线程安全问题，主要可以考虑以下几个方面：A. 将对象设计为无状态对象（这和面向对象的编程观点是矛盾的，在面向对象的世界中被视为不良设计），这样就不会存在并发访问时对象状态不一致的问题。B. 在方法内部创建对象，这样对象由进入方法的线程创建，不会出现多个线程访问同一对象的问题。使用 ThreadLocal 将对象与线程绑定也是很好的做法，这一点在前面已经探讨过了。C. 对资源进行并发访问时应当使用合理的锁机制。\r\n- 非阻塞 I/O： 使用单线程和非阻塞 I/O 是目前公认的比多线程的方式更能充分发挥服务器性能的应用模式，基于 Node.js 构建的服务器就采用了这样的方式。Java 在 JDK 1.4 中就引入了 NIO（Non-blocking I/O）, 在 Servlet 3 规范中又引入了异步 Servlet 的概念，这些都为在服务器端采用非阻塞 I/O 提供了必要的基础。\r\n- 资源复用：资源复用主要有两种方式，一是单例，二是对象池，我们使用的数据库连接池、线程池都是对象池化技术，这是典型的用空间换取时间的策略，另一方面也实现对资源的复用，从而避免了不必要的创建和释放资源所带来的开销。\r\n\r\n**168、什么是 XSS 攻击？什么是 SQL 注入攻击？什么是 CSRF 攻击？**\r\n答：\r\n- XSS（Cross Site Script，跨站脚本攻击）是向网页中注入恶意脚本在用户浏览网页时在用户浏览器中执行恶意脚本的攻击方式。跨站脚本攻击分有两种形式：反射型攻击（诱使用户点击一个嵌入恶意脚本的链接以达到攻击的目标，目前有很多攻击者利用论坛、微博发布含有恶意脚本的 URL 就属于这种方式）和持久型攻击（将恶意脚本提交到被攻击网站的数据库中，用户浏览网页时，恶意脚本从数据库中被加载到页面执行，QQ 邮箱的早期版本就曾经被利用作为持久型跨站脚本攻击的平台）。XSS 虽然不是什么新鲜玩意，但是攻击的手法却不断翻新，防范 XSS 主要有两方面：消毒（对危险字符进行转义）和 HttpOnly（防范 XSS 攻击者窃取 Cookie 数据）。\r\n- SQL 注入攻击是注入攻击最常见的形式（此外还有 OS 注入攻击（Struts 2 的高危漏洞就是通过 OGNL 实施 OS 注入攻击导致的）），当服务器使用请求参数构造 SQL 语句时，恶意的 SQL 被嵌入到 SQL 中交给数据库执行。SQL 注入攻击需要攻击者对数据库结构有所了解才能进行，攻击者想要获得表结构有多种方式：（1）如果使用开源系统搭建网站，数据库结构也是公开的（目前有很多现成的系统可以直接搭建论坛，电商网站，虽然方便快捷但是风险是必须要认真评估的）；（2）错误回显（如果将服务器的错误信息直接显示在页面上，攻击者可以通过非法参数引发页面错误从而通过错误信息了解数据库结构，Web 应用应当设置友好的错误页，一方面符合最小惊讶原则，一方面屏蔽掉可能给系统带来危险的错误回显信息）；（3）盲注。防范 SQL 注入攻击也可以采用消毒的方式，通过正则表达式对请求参数进行验证，此外，参数绑定也是很好的手段，这样恶意的 SQL 会被当做 SQL 的参数而不是命令被执行，JDBC 中的 PreparedStatement 就是支持参数绑定的语句对象，从性能和安全性上都明显优于 Statement。\r\n- CSRF 攻击（Cross Site Request Forgery，跨站请求伪造）是攻击者通过跨站请求，以合法的用户身份进行非法操作（如转账或发帖等）。CSRF 的原理是利用浏览器的 Cookie 或服务器的 Session，盗取用户身份，其原理如下图所示。防范 CSRF 的主要手段是识别请求者的身份，主要有以下几种方式：（1）在表单中添加令牌（token）；（2）验证码；（3）检查请求头中的 Referer（前面提到防图片盗链接也是用的这种方式）。令牌和验证都具有一次消费性的特征，因此在原理上一致的，但是验证码是一种糟糕的用户体验，不是必要的情况下不要轻易使用验证码，目前很多网站的做法是如果在短时间内多次提交一个表单未获得成功后才要求提供验证码，这样会获得较好的用户体验。\r\n\r\n> **补充：**防火墙的架设是 Web 安全的重要保障，[ModSecurity](http://www.modsecurity.org/) 是开源的 Web 防火墙中的佼佼者。企业级防火墙的架设应当有两级防火墙，Web 服务器和部分应用服务器可以架设在两级防火墙之间的 DMZ，而数据和资源服务器应当架设在第二级防火墙之后。\r\n\r\n**169\\. 什么是领域模型 (domain model)？贫血模型(anaemic domain model) 和充血模型 (rich domain model) 有什么区别？**\r\n答：领域模型是领域内的概念类或现实世界中对象的可视化表示，又称为概念模型或分析对象模型，它专注于分析问题领域本身，发掘重要的业务领域概念，并建立业务领域概念之间的关系。贫血模型是指使用的领域对象中只有 setter 和 getter 方法（POJO），所有的业务逻辑都不包含在领域对象中而是放在业务逻辑层。有人将我们这里说的贫血模型进一步划分成失血模型（领域对象完全没有业务逻辑）和贫血模型（领域对象有少量的业务逻辑），我们这里就不对此加以区分了。充血模型将大多数业务逻辑和持久化放在领域对象中，业务逻辑（业务门面）只是完成对业务逻辑的封装、事务和权限等的处理。下面两张图分别展示了贫血模型和充血模型的分层架构。\r\n\r\n贫血模型\r\n\r\n充血模型\r\n\r\n贫血模型下组织领域逻辑通常使用事务脚本模式，让每个过程对应用户可能要做的一个动作，每个动作由一个过程来驱动。也就是说在设计业务逻辑接口的时候，每个方法对应着用户的一个操作，这种模式有以下几个有点：\r\n- 它是一个大多数开发者都能够理解的简单过程模型（适合国内的绝大多数开发者）。\r\n- 它能够与一个使用行数据入口或表数据入口的简单数据访问层很好的协作。\r\n- 事务边界的显而易见，一个事务开始于脚本的开始，终止于脚本的结束，很容易通过代理（或切面）实现声明式事务。\r\n然而，事务脚本模式的缺点也是很多的，随着领域逻辑复杂性的增加，系统的复杂性将迅速增加，程序结构将变得极度混乱。开源中国社区上有一篇很好的译文[《贫血领域模型是如何导致糟糕的软件产生》](http://www.oschina.net/translate/how-anaemic-domain-models-cause-bad-software)对这个问题做了比较细致的阐述。\r\n\r\n**170\\. 谈一谈测试驱动开发（TDD）的好处以及你的理解。**\r\n答：TDD 是指在编写真正的功能实现代码之前先写测试代码，然后根据需要重构实现代码。在 JUnit 的作者 Kent Beck 的大作《测试驱动开发：实战与模式解析》（Test-Driven Development: by Example）一书中有这么一段内容：“消除恐惧和不确定性是编写测试驱动代码的重要原因”。因为编写代码时的恐惧会让你小心试探，让你回避沟通，让你羞于得到反馈，让你变得焦躁不安，而 TDD 是消除恐惧、让 Java 开发者更加自信更加乐于沟通的重要手段。TDD 会带来的好处可能不会马上呈现，但是你在某个时候一定会发现，这些好处包括：\r\n- 更清晰的代码 — 只写需要的代码\r\n- 更好的设计\r\n- 更出色的灵活性 — 鼓励程序员面向接口编程\r\n- 更快速的反馈 — 不会到系统上线时才知道 bug 的存在\r\n\r\n> **补充：**敏捷软件开发的概念已经有很多年了，而且也部分的改变了软件开发这个行业，TDD 也是敏捷开发所倡导的。\r\n\r\nTDD 可以在多个层级上应用，包括单元测试（测试一个类中的代码）、集成测试（测试类之间的交互）、系统测试（测试运行的系统）和系统集成测试（测试运行的系统包括使用的第三方组件）。TDD 的实施步骤是：红（失败测试）- 绿（通过测试） - 重构。关于实施 TDD 的详细步骤请参考另一篇文章[《测试驱动开发之初窥门径》](http://blog.csdn.net/jackfrued/article/details/44433249)。\r\n在使用 TDD 开发时，经常会遇到需要被测对象需要依赖其他子系统的情况，但是你希望将测试代码跟依赖项隔离，以保证测试代码仅仅针对当前被测对象或方法展开，这时候你需要的是测试替身。测试替身可以分为四类：\r\n- 虚设替身：只传递但是不会使用到的对象，一般用于填充方法的参数列表\r\n- 存根替身：总是返回相同的预设响应，其中可能包括一些虚设状态\r\n- 伪装替身：可以取代真实版本的可用版本（比真实版本还是会差很多）\r\n- 模拟替身：可以表示一系列期望值的对象，并且可以提供预设响应\r\nJava 世界中实现模拟替身的第三方工具非常多，包括 EasyMock、Mockito、jMock 等。\r\n\r\n<link href=\"https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7b4cdcb592.css\" rel=\"stylesheet\"> <sr-plugin-count>共计：55910 个字</sr-plugin-count>',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,0),(25,'1509036440_117_what-is-spring-cloud-and-how-to-prepare-it-an-interview-with-yevgeny-borisov-and-kirill-tolkachov.png','1509036440_117_what-is-spring-cloud-and-how-to-prepare-it-an-interview-with-yevgeny-borisov-and-kirill-tolkachov-png',1550560283,1550560283,'a:5:{s:4:\"name\";s:116:\"1509036440_117_what-is-spring-cloud-and-how-to-prepare-it-an-interview-with-yevgeny-borisov-and-kirill-tolkachov.png\";s:4:\"path\";s:35:\"/usr/uploads/2019/02/3742335678.png\";s:4:\"size\";i:421467;s:4:\"type\";s:3:\"png\";s:4:\"mime\";s:9:\"image/png\";}',1,1,NULL,'attachment','publish',NULL,0,'1','0','1',23,0),(27,'Java 面试题全集（中）','27',1550642097,1550642097,'<!--markdown-->> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 https://blog.csdn.net/jackfrued/article/details/44931137 版权声明：本文为博主原创文章，请在转载时说明出处。 https://blog.csdn.net/jackfrued/article/details/44931137\r\n\r\n这部分主要是与 Java Web 和 Web Service 相关的面试题。\r\n\r\n**96、阐述 Servlet 和 CGI 的区别?**\r\n答：Servlet 与 CGI 的区别在于 Servlet 处于服务器进程中，它通过多线程方式运行其 service() 方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而 CGI 对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于 Servlet。\r\n\r\n> 补充：Sun Microsystems 公司在 1996 年发布 Servlet 技术就是为了和 CGI 进行竞争，Servlet 是一个特殊的 Java 程序，一个基于 Java 的 Web 应用通常包含一个或多个 Servlet 类。Servlet 不能够自行创建并执行，它是在 Servlet 容器中运行的，容器将用户的请求传递给 Servlet 程序，并将 Servlet 的响应回传给用户。通常一个 Servlet 会关联一个或多个 JSP 页面。以前 CGI 经常因为性能开销上的问题被诟病，然而 Fast CGI 早就已经解决了 CGI 效率上的问题，所以面试的时候大可不必信口开河的诟病 CGI，事实上有很多你熟悉的网站都使用了 CGI 技术。\r\n\r\n**97、Servlet 接口中有哪些方法？**\r\n答：Servlet 接口定义了 5 个方法，其中前三个方法与 Servlet 生命周期相关：\r\n- void init(ServletConfig config) throws ServletException\r\n- void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException\r\n- void destory()\r\n- java.lang.String getServletInfo()\r\n- ServletConfig getServletConfig()\r\n\r\nWeb 容器加载 Servlet 并将其实例化后，Servlet 生命周期开始，容器运行其 init() 方法进行 Servlet 的初始化；请求到达时调用 Servlet 的 service() 方法，service() 方法会根据需要调用与请求对应的 doGet 或 doPost 等方法；当服务器关闭或项目被卸载时服务器会将 Servlet 实例销毁，此时会调用 Servlet 的 destroy() 方法。\r\n\r\n**98、转发（forward）和重定向（redirect）的区别？**\r\n答：forward 是容器中控制权的转向，是服务器请求资源，服务器直接访问目标地址的 URL，把那个 URL 的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。redirect 就是服务器端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址，因此从浏览器的地址栏中可以看到跳转后的链接地址，很明显 redirect 无法访问到服务器保护起来资源，但是可以从一个网站 redirect 到其他网站。forward 更加高效，所以在满足需要时尽量使用 forward（通过调用 RequestDispatcher 对象的 forward() 方法，该对象可以通过 ServletRequest 对象的 getRequestDispatcher() 方法获得），并且这样也有助于隐藏实际的链接；在有些情况下，比如需要访问一个其它服务器上的资源，则必须使用重定向（通过 HttpServletResponse 对象调用其 sendRedirect() 方法实现）。\r\n\r\n**99、JSP 有哪些内置对象？作用分别是什么？**\r\n答：JSP 有 9 个内置对象：\r\n- request：封装客户端的请求，其中包含来自 GET 或 POST 请求的参数；\r\n- response：封装服务器对客户端的响应；\r\n- pageContext：通过该对象可以获取其他对象；\r\n- session：封装用户会话的对象；\r\n- application：封装服务器运行环境的对象；\r\n- out：输出服务器响应的输出流对象；\r\n- config：Web 应用的配置对象；\r\n- page：JSP 页面本身（相当于 Java 程序中的 this）；\r\n- exception：封装页面抛出异常的对象。\r\n\r\n> **补充：**如果用 Servlet 来生成网页中的动态内容无疑是非常繁琐的工作，另一方面，所有的文本和 HTML 标签都是硬编码，即使做出微小的修改，都需要进行重新编译。JSP 解决了 Servlet 的这些问题，它是 Servlet 很好的补充，可以专门用作为用户呈现视图（View），而 Servlet 作为控制器（Controller）专门负责处理用户请求并转发或重定向到某个页面。基于 Java 的 Web 开发很多都同时使用了 Servlet 和 JSP。JSP 页面其实是一个 Servlet，能够运行 Servlet 的服务器（Servlet 容器）通常也是 JSP 容器，可以提供 JSP 页面的运行环境，Tomcat 就是一个 Servlet/JSP 容器。第一次请求一个 JSP 页面时，Servlet/JSP 容器首先将 JSP 页面转换成一个 JSP 页面的实现类，这是一个实现了 JspPage 接口或其子接口 HttpJspPage 的 Java 类。JspPage 接口是 Servlet 的子接口，因此每个 JSP 页面都是一个 Servlet。转换成功后，容器会编译 Servlet 类，之后容器加载和实例化 Java 字节码，并执行它通常对 Servlet 所做的生命周期操作。对同一个 JSP 页面的后续请求，容器会查看这个 JSP 页面是否被修改过，如果修改过就会重新转换并重新编译并执行。如果没有则执行内存中已经存在的 Servlet 实例。我们可以看一段 JSP 代码对应的 Java 程序就知道一切了，而且 9 个内置对象的神秘面纱也会被揭开。\r\n\r\nJSP 页面：\r\n\r\n```\r\n<%@ page pageEncoding=\"UTF-8\"%>\r\n<%\r\nString path = request.getContextPath();\r\nString basePath = request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort() + path + \"/\";\r\n%>\r\n\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <base href=\"<%=basePath%>\">\r\n    <title>首页</title>\r\n    <style type=\"text/css\">\r\n        * { font-family: \"Arial\"; }\r\n    </style>\r\n  </head>\r\n\r\n  <body>\r\n    <h1>Hello, World!</h1>\r\n    <hr/>\r\n    <h2>Current time is: <%= new java.util.Date().toString() %></h2>\r\n  </body>\r\n</html>\r\n```\r\n\r\n对应的 Java 代码：\r\n\r\n```\r\n/*\r\n * Generated by the Jasper component of Apache Tomcat\r\n * Version: Apache Tomcat/7.0.52\r\n * Generated at: 2014-10-13 13:28:38 UTC\r\n * Note: The last modified time of this file was set to\r\n *       the last modified time of the source file after\r\n *       generation to assist with modification tracking.\r\n */\r\npackage org.apache.jsp;\r\n\r\nimport javax.servlet.*;\r\nimport javax.servlet.http.*;\r\nimport javax.servlet.jsp.*;\r\n\r\npublic final class index_jsp extends org.apache.jasper.runtime.HttpJspBase\r\n        implements org.apache.jasper.runtime.JspSourceDependent {\r\n\r\n    private static final javax.servlet.jsp.JspFactory _jspxFactory = javax.servlet.jsp.JspFactory\r\n            .getDefaultFactory();\r\n\r\n    private static java.util.Map<java.lang.String, java.lang.Long> _jspx_dependants;\r\n\r\n    private javax.el.ExpressionFactory _el_expressionfactory;\r\n    private org.apache.tomcat.InstanceManager _jsp_instancemanager;\r\n\r\n    public java.util.Map<java.lang.String, java.lang.Long> getDependants() {\r\n        return _jspx_dependants;\r\n    }\r\n\r\n    public void _jspInit() {\r\n        _el_expressionfactory = _jspxFactory.getJspApplicationContext(\r\n                getServletConfig().getServletContext()).getExpressionFactory();\r\n        _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory\r\n                .getInstanceManager(getServletConfig());\r\n    }\r\n\r\n    public void _jspDestroy() {\r\n    }\r\n\r\n    public void _jspService(\r\n            final javax.servlet.http.HttpServletRequest request,\r\n            final javax.servlet.http.HttpServletResponse response)\r\n            throws java.io.IOException, javax.servlet.ServletException {\r\n        // 内置对象就是在这里定义的\r\n        final javax.servlet.jsp.PageContext pageContext;\r\n        javax.servlet.http.HttpSession session = null;\r\n        final javax.servlet.ServletContext application;\r\n        final javax.servlet.ServletConfig config;\r\n        javax.servlet.jsp.JspWriter out = null;\r\n        final java.lang.Object page = this;\r\n        javax.servlet.jsp.JspWriter _jspx_out = null;\r\n        javax.servlet.jsp.PageContext _jspx_page_context = null;\r\n\r\n        try {\r\n            response.setContentType(\"text/html;charset=UTF-8\");\r\n            pageContext = _jspxFactory.getPageContext(this, request, response,\r\n                    null, true, 8192, true);\r\n            _jspx_page_context = pageContext;\r\n            application = pageContext.getServletContext();\r\n            config = pageContext.getServletConfig();\r\n            session = pageContext.getSession();\r\n            out = pageContext.getOut();\r\n            _jspx_out = out;\r\n\r\n            out.write(\'\\r\');\r\n            out.write(\'\\n\');\r\n\r\n            String path = request.getContextPath();\r\n            String basePath = request.getScheme() + \"://\"\r\n                    + request.getServerName() + \":\" + request.getServerPort()\r\n                    + path + \"/\";\r\n// 以下代码通过输出流将HTML标签输出到浏览器中\r\n            out.write(\"\\r\\n\");\r\n            out.write(\"\\r\\n\");\r\n            out.write(\"<!DOCTYPE html>\\r\\n\");\r\n            out.write(\"<html>\\r\\n\");\r\n            out.write(\"  <head>\\r\\n\");\r\n            out.write(\"    <base href=\\\"\");\r\n            out.print(basePath);\r\n            out.write(\"\\\">\\r\\n\");\r\n            out.write(\"    <title>首页</title>\\r\\n\");\r\n            out.write(\"    <style type=\\\"text/css\\\">\\r\\n\");\r\n            out.write(\"    \\t* { font-family: \\\"Arial\\\"; }\\r\\n\");\r\n            out.write(\"    </style>\\r\\n\");\r\n            out.write(\"  </head>\\r\\n\");\r\n            out.write(\"  \\r\\n\");\r\n            out.write(\"  <body>\\r\\n\");\r\n            out.write(\"    <h1>Hello, World!</h1>\\r\\n\");\r\n            out.write(\"    <hr/>\\r\\n\");\r\n            out.write(\"    <h2>Current time is: \");\r\n            out.print(new java.util.Date().toString());\r\n            out.write(\"</h2>\\r\\n\");\r\n            out.write(\"  </body>\\r\\n\");\r\n            out.write(\"</html>\\r\\n\");\r\n        } catch (java.lang.Throwable t) {\r\n            if (!(t instanceof javax.servlet.jsp.SkipPageException)) {\r\n                out = _jspx_out;\r\n                if (out != null && out.getBufferSize() != 0)\r\n                    try {\r\n                        out.clearBuffer();\r\n                    } catch (java.io.IOException e) {\r\n                    }\r\n                if (_jspx_page_context != null)\r\n                    _jspx_page_context.handlePageException(t);\r\n                else\r\n                    throw new ServletException(t);\r\n            }\r\n        } finally {\r\n            _jspxFactory.releasePageContext(_jspx_page_context);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**100、get 和 post 请求的区别？**\r\n答：\r\n①get 请求用来从服务器上获得资源，而 post 是用来向服务器提交数据；\r\n②get 将表单中数据按照 name=value 的形式，添加到 action 所指向的 URL 后面，并且两者使用 \"?\" 连接，而各个变量之间使用 \"&\" 连接；post 是将表单中的数据放在 HTTP 协议的请求头或消息体中，传递到 action 所指向 URL；\r\n③get 传输的数据要受到 URL 长度限制（1024 字节）；而 post 可以传输大量的数据，上传文件通常要使用 post 方式；\r\n④使用 get 时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用 get；对于敏感数据还是应用使用 post；\r\n⑤get 使用 MIME 类型 application/x-www-form-urlencoded 的 URL 编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是 \"%20\"。\r\n\r\n**101、常用的 Web 服务器有哪些？**\r\n答：Unix 和 Linux 平台下使用最广泛的免费 HTTP 服务器是 Apache 服务器，而 Windows 平台的服务器通常使用 IIS 作为 Web 服务器。选择 Web 服务器应考虑的因素有：性能、安全性、日志和统计、虚拟主机、代理服务器、缓冲服务和集成应用程序等。下面是对常见服务器的简介：\r\n- IIS：Microsoft 的 Web 服务器产品，全称是 Internet Information Services。IIS 是允许在公共 Intranet 或 Internet 上发布信息的 Web 服务器。IIS 是目前最流行的 Web 服务器产品之一，很多著名的网站都是建立在 IIS 的平台上。IIS 提供了一个图形界面的管理工具，称为 Internet 服务管理器，可用于监视配置和控制 Internet 服务。IIS 是一种 Web 服务组件，其中包括 Web 服务器、FTP 服务器、NNTP 服务器和 SMTP 服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。它提供 ISAPI(Intranet Server API）作为扩展 Web 服务器功能的编程接口；同时，它还提供一个 Internet 数据库连接器，可以实现对数据库的查询和更新。\r\n- Kangle：Kangle Web 服务器是一款跨平台、功能强大、安全稳定、易操作的高性能 Web 服务器和反向代理服务器软件。此外，Kangle 也是一款专为做虚拟主机研发的 Web 服务器。实现虚拟主机独立进程、独立身份运行。用户之间安全隔离，一个用户出问题不影响其他用户。支持 PHP、ASP、ASP.NET、Java、Ruby 等多种动态开发语言。\r\n- WebSphere：WebSphere Application Server 是功能完善、开放的 Web 应用程序服务器，是 IBM 电子商务计划的核心部分，它是基于 Java 的应用环境，用于建立、部署和管理 Internet 和 Intranet Web 应用程序，适应各种 Web 应用程序服务器的需要。\r\n- WebLogic：WebLogic Server 是一款多功能、基于标准的 Web 应用服务器，为企业构建企业应用提供了坚实的基础。针对各种应用开发、关键性任务的部署，各种系统和数据库的集成、跨 Internet 协作等 Weblogic 都提供了相应的支持。由于它具有全面的功能、对开放标准的遵从性、多层架构、支持基于组件的开发等优势，很多公司的企业级应用都选择它来作为开发和部署的环境。WebLogic Server 在使应用服务器成为企业应用架构的基础方面一直处于领先地位，为构建集成化的企业级应用提供了稳固的基础。\r\n- Apache：目前 Apache 仍然是世界上用得最多的 Web 服务器，其市场占有率很长时间都保持在 60% 以上（目前的市场份额约 40% 左右）。世界上很多著名的网站都是 Apache 的产物，它的成功之处主要在于它的源代码开放、有一支强大的开发团队、支持跨平台的应用（可以运行在几乎所有的 Unix、Windows、Linux 系统平台上）以及它的可移植性等方面。\r\n- Tomcat：Tomcat 是一个开放源代码、运行 Servlet 和 JSP 的容器。Tomcat 实现了 Servlet 和 JSP 规范。此外，Tomcat 还实现了 Apache-Jakarta 规范而且比绝大多数商业应用软件服务器要好，因此目前也有不少的 Web 服务器都选择了 Tomcat。\r\n- Nginx：读作 \"engine x\"，是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP/POP3/SMTP 代理服务器。 Nginx 是由 Igor Sysoev 为俄罗斯访问量第二的 [Rambler](http://www.rambler.ru) 站点开发的，第一个公开版本 0.1.0 发布于 2004 年 10 月 4 日。其将源代码以类 BSD 许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。在 2014 年下半年，Nginx 的市场份额达到了 14%。\r\n\r\n**102、JSP 和 Servlet 是什么关系？**\r\n答：其实这个问题在上面已经阐述过了，Servlet 是一个特殊的 Java 程序，它运行于服务器的 JVM 中，能够依靠服务器的支持向浏览器提供显示内容。JSP 本质上是 Servlet 的一种简易形式，JSP 会被服务器处理成一个类似于 Servlet 的 Java 程序，可以简化页面内容的生成。Servlet 和 JSP 最主要的不同点在于，Servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 HTML 分离开来。而 JSP 的情况是 Java 和 HTML 可以组合成一个扩展名为. jsp 的文件。有人说，Servlet 就是在 Java 中写 HTML，而 JSP 就是在 HTML 中写 Java 代码，当然这个说法是很片面且不够准确的。JSP 侧重于视图，Servlet 更侧重于控制逻辑，在 MVC 架构模式中，JSP 适合充当视图（view）而 Servlet 适合充当控制器（controller）。\r\n\r\n**103、讲解 JSP 中的四种作用域。**\r\n答：JSP 中的四种作用域包括 page、request、session 和 application，具体来说：\r\n- page 代表与一个页面相关的对象和属性。\r\n- request 代表与 Web 客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。\r\n- session 代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中。\r\n- application 代表与整个 Web 应用程序相关的对象和属性，它实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。\r\n\r\n**104、如何实现 JSP 或 Servlet 的单线程模式？**\r\n答：\r\n对于 JSP 页面，可以通过 page 指令进行设置。\r\n\r\n```\r\n<%@page isThreadSafe=”false”%>\r\n```\r\n\r\n对于 Servlet，可以让自定义的 Servlet 实现 SingleThreadModel 标识接口。\r\n\r\n> **说明：**如果将 JSP 或 Servlet 设置成单线程工作模式，会导致每个请求创建一个 Servlet 实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。\r\n\r\n**105、实现会话跟踪的技术有哪些？**\r\n答：由于 HTTP 协议本身是无状态的，服务器为了区分不同的用户，就需要对用户会话进行跟踪，简单的说就是为用户进行登记，为用户分配唯一的 ID，下一次用户在请求中包含此 ID，服务器据此判断到底是哪一个用户。\r\n①URL 重写：在 URL 中添加用户会话的信息作为请求的参数，或者将唯一的会话 ID 添加到 URL 结尾以标识一个会话。\r\n②设置表单隐藏域：将和会话跟踪相关的字段添加到隐式表单域中，这些信息不会在浏览器中显示但是提交表单时会提交给服务器。\r\n这两种方式很难处理跨越多个页面的信息传递，因为如果每次都要修改 URL 或在页面中添加隐式表单域来存储用户会话相关信息，事情将变得非常麻烦。\r\n③cookie：cookie 有两种，一种是基于窗口的，浏览器窗口关闭后，cookie 就没有了；另一种是将信息存储在一个临时文件中，并设置存在的时间。当用户通过浏览器和服务器建立一次会话后，会话 ID 就会随响应信息返回存储在基于窗口的 cookie 中，那就意味着只要浏览器没有关闭，会话没有超时，下一次请求时这个会话 ID 又会提交给服务器让服务器识别用户身份。会话中可以为用户保存信息。会话对象是在服务器内存中的，而基于窗口的 cookie 是在客户端内存中的。如果浏览器禁用了 cookie，那么就需要通过下面两种方式进行会话跟踪。当然，在使用 cookie 时要注意几点：首先不要在 cookie 中存放敏感信息；其次 cookie 存储的数据量有限（4k），不能将过多的内容存储 cookie 中；再者浏览器通常只允许一个站点最多存放 20 个 cookie。当然，和用户会话相关的其他信息（除了会话 ID）也可以存在 cookie 方便进行会话跟踪。\r\n④HttpSession：在所有会话跟踪技术中，HttpSession 对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建 HttpSession，每个用户可以访问他自己的 HttpSession。可以通过 HttpServletRequest 对象的 getSession 方法获得 HttpSession，通过 HttpSession 的 setAttribute 方法可以将一个值放在 HttpSession 中，通过调用 HttpSession 对象的 getAttribute 方法，同时传入属性名就可以获取保存在 HttpSession 中的对象。与上面三种方式不同的是，HttpSession 放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的 Servlet 容器可以在内存将满时将 HttpSession 中的对象移到其他存储设备中，但是这样势必影响性能。添加到 HttpSession 中的值可以是任意 Java 对象，这个对象最好实现了 Serializable 接口，这样 Servlet 容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。\r\n\r\n> ** 补充：**HTML5 中可以使用 Web Storage 技术通过 JavaScript 来保存数据，例如可以使用 localStorage 和 sessionStorage 来保存用户会话的信息，也能够实现会话跟踪。\r\n\r\n**106、过滤器有哪些作用和用法？**\r\n答： Java Web 开发中的过滤器（filter）是从 Servlet 2.3 规范开始增加的功能，并在 Servlet 2.4 规范中得到增强。对 Web 应用来说，过滤器是一个驻留在服务器端的 Web 组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过滤。当 Web 容器接受到一个对资源的请求时，它将判断是否有过滤器与这个资源相关联。如果有，那么容器将把请求交给过滤器进行处理。在过滤器中，你可以改变请求的内容，或者重新设置请求的报头信息，然后再将请求发送给目标资源。当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，在过滤器中你可以对响应的内容进行转换，然后再将响应发送到客户端。\r\n\r\n常见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件、对 XML 的输出应用 XSLT 等。\r\n\r\n和过滤器相关的接口主要有：Filter、FilterConfig 和 FilterChain。\r\n\r\n编码过滤器的例子：\r\n\r\n```\r\nimport java.io.IOException;\r\n\r\nimport javax.servlet.Filter;\r\nimport javax.servlet.FilterChain;\r\nimport javax.servlet.FilterConfig;\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.ServletRequest;\r\nimport javax.servlet.ServletResponse;\r\nimport javax.servlet.annotation.WebFilter;\r\nimport javax.servlet.annotation.WebInitParam;\r\n\r\n@WebFilter(urlPatterns = { \"*\" }, \r\n        initParams = {@WebInitParam()})\r\npublic class CodingFilter implements Filter {\r\n    private String defaultEncoding = \"utf-8\";\r\n\r\n    @Override\r\n    public void destroy() {\r\n    }\r\n\r\n    @Override\r\n    public void doFilter(ServletRequest req, ServletResponse resp,\r\n            FilterChain chain) throws IOException, ServletException {\r\n        req.setCharacterEncoding(defaultEncoding);\r\n        resp.setCharacterEncoding(defaultEncoding);\r\n        chain.doFilter(req, resp);\r\n    }\r\n\r\n    @Override\r\n    public void init(FilterConfig config) throws ServletException {\r\n        String encoding = config.getInitParameter(\"encoding\");\r\n        if (encoding != null) {\r\n            defaultEncoding = encoding;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n下载计数过滤器的例子：\r\n\r\n```\r\nimport java.io.File;\r\nimport java.io.FileReader;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\nimport java.util.Properties;\r\nimport java.util.concurrent.ExecutorService;\r\nimport java.util.concurrent.Executors;\r\n\r\nimport javax.servlet.Filter;\r\nimport javax.servlet.FilterChain;\r\nimport javax.servlet.FilterConfig;\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.ServletRequest;\r\nimport javax.servlet.ServletResponse;\r\nimport javax.servlet.annotation.WebFilter;\r\nimport javax.servlet.http.HttpServletRequest;\r\n\r\n@WebFilter(urlPatterns = {\"/*\"})\r\npublic class DownloadCounterFilter implements Filter {\r\n\r\n    private ExecutorService executorService = Executors.newSingleThreadExecutor();\r\n    private Properties downloadLog;\r\n    private File logFile;\r\n\r\n    @Override\r\n    public void destroy() {\r\n        executorService.shutdown();\r\n    }\r\n\r\n    @Override\r\n    public void doFilter(ServletRequest req, ServletResponse resp,\r\n            FilterChain chain) throws IOException, ServletException {\r\n        HttpServletRequest request = (HttpServletRequest) req;\r\n        final String uri = request.getRequestURI();\r\n        executorService.execute(new Runnable() {\r\n\r\n            @Override\r\n            public void run() {\r\n                String value = downloadLog.getProperty(uri);\r\n                if(value == null) {\r\n                    downloadLog.setProperty(uri, \"1\");\r\n                }\r\n                else {\r\n                    int count = Integer.parseInt(value);\r\n                    downloadLog.setProperty(uri, String.valueOf(++count));\r\n                }\r\n                try {\r\n                    downloadLog.store(new FileWriter(logFile), \"\");\r\n                } \r\n                catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        });\r\n        chain.doFilter(req, resp);\r\n    }\r\n\r\n    @Override\r\n    public void init(FilterConfig config) throws ServletException {\r\n        String appPath = config.getServletContext().getRealPath(\"/\");\r\n        logFile = new File(appPath, \"downloadLog.txt\");\r\n        if(!logFile.exists()) {\r\n            try {\r\n                logFile.createNewFile();\r\n            } \r\n            catch(IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        downloadLog = new Properties();\r\n        try {\r\n            downloadLog.load(new FileReader(logFile));\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n> **说明：**这里使用了 Servlet 3 规范中的注解来部署过滤器，当然也可以在 web.xml 中使用 <filter> 和 < filter-mapping > 标签部署过滤器，如 108 题中所示。\r\n\r\n**107、监听器有哪些作用和用法？**\r\n答：Java Web 开发中的监听器（listener）就是 application、session、request 三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件，如下所示：\r\n①ServletContextListener：对 Servlet 上下文的创建和销毁进行监听。\r\n②ServletContextAttributeListener：监听 Servlet 上下文属性的添加、删除和替换。\r\n③HttpSessionListener：对 Session 的创建和销毁进行监听。\r\n\r\n> 补充：session 的销毁有两种情况：1). session 超时（可以在 web.xml 中通过 <session-config>/<session-timeout > 标签配置超时时间）；2). 通过调用 session 对象的 invalidate() 方法使 session 失效。\r\n\r\n④HttpSessionAttributeListener：对 Session 对象中属性的添加、删除和替换进行监听。\r\n⑤ServletRequestListener：对请求对象的初始化和销毁进行监听。\r\n⑥ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听。\r\n\r\n下面是一个统计网站最多在线人数监听器的例子。\r\n\r\n```\r\nimport javax.servlet.ServletContextEvent;\r\nimport javax.servlet.ServletContextListener;\r\nimport javax.servlet.annotation.WebListener;\r\n\r\n/**\r\n 上下文监听器，在服务器启动时初始化onLineCount和maxOnLineCount两个变量\r\n 并将其置于服务器上下文（ServletContext）中，其初始值都是0\r\n*/\r\n@WebListener\r\npublic class InitListener implements ServletContextListener {\r\n\r\n    @Override\r\n    public void contextDestroyed(ServletContextEvent evt) {\r\n    }\r\n\r\n    @Override\r\n    public void contextInitialized(ServletContextEvent evt) {\r\n        evt.getServletContext().setAttribute(\"onLineCount\", 0);\r\n        evt.getServletContext().setAttribute(\"maxOnLineCount\", 0);\r\n    }\r\n\r\n}\r\n```\r\n\r\n```\r\nimport java.text.DateFormat;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\n\r\nimport javax.servlet.ServletContext;\r\nimport javax.servlet.annotation.WebListener;\r\nimport javax.servlet.http.HttpSessionEvent;\r\nimport javax.servlet.http.HttpSessionListener;\r\n\r\n/**\r\n 会话监听器，在用户会话创建和销毁的时候根据情况\r\n 修改onLineCount和maxOnLineCount的值\r\n*/\r\n@WebListener\r\npublic class MaxCountListener implements HttpSessionListener {\r\n\r\n    @Override\r\n    public void sessionCreated(HttpSessionEvent event) {\r\n        ServletContext ctx = event.getSession().getServletContext();\r\n        int count = Integer.parseInt(ctx.getAttribute(\"onLineCount\").toString());\r\n        count++;\r\n        ctx.setAttribute(\"onLineCount\", count);\r\n        int maxOnLineCount = Integer.parseInt(ctx.getAttribute(\"maxOnLineCount\").toString());\r\n        if (count > maxOnLineCount) {\r\n            ctx.setAttribute(\"maxOnLineCount\", count);\r\n            DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n            ctx.setAttribute(\"date\", df.format(new Date()));\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void sessionDestroyed(HttpSessionEvent event) {\r\n        ServletContext app = event.getSession().getServletContext();\r\n        int count = Integer.parseInt(app.getAttribute(\"onLineCount\").toString());\r\n        count--;\r\n        app.setAttribute(\"onLineCount\", count);\r\n    }\r\n}\r\n```\r\n\r\n> **说明：**这里使用了 Servlet 3 规范中的 @WebListener 注解配置监听器，当然你可以在 web.xml 文件中用 <listener> 标签配置监听器，如 108 题中所示。\r\n\r\n**108、web.xml 文件中可以配置哪些内容？**\r\n答：web.xml 用于配置 Web 应用的相关信息，如：监听器（listener）、过滤器（filter）、 Servlet、相关参数、会话超时时间、安全验证方式、错误页面等，下面是一些开发中常见的配置：\r\n\r\n①配置 Spring 上下文加载监听器加载 Spring 配置文件并创建 IoC 容器：\r\n\r\n```\r\n  <context-param>\r\n     <param-name>contextConfigLocation</param-name>\r\n    <param-value>classpath:applicationContext.xml</param-value>\r\n  </context-param>\r\n\r\n  <listener>\r\n     <listener-class>\r\n       org.springframework.web.context.ContextLoaderListener\r\n     </listener-class>\r\n  </listener>\r\n```\r\n\r\n②配置 Spring 的 OpenSessionInView 过滤器来解决延迟加载和 Hibernate 会话关闭的矛盾：\r\n\r\n```\r\n  <filter>\r\n      <filter-name>openSessionInView</filter-name>\r\n      <filter-class>\r\n         org.springframework.orm.hibernate3.support.OpenSessionInViewFilter\r\n      </filter-class>\r\n  </filter>\r\n\r\n  <filter-mapping>\r\n      <filter-name>openSessionInView</filter-name>\r\n      <url-pattern>/*</url-pattern>\r\n  </filter-mapping>\r\n```\r\n\r\n③配置会话超时时间为 10 分钟：\r\n\r\n```\r\n  <session-config>\r\n      <session-timeout>10</session-timeout>\r\n  </session-config>\r\n```\r\n\r\n④配置 404 和 Exception 的错误页面：\r\n\r\n```\r\n  <error-page>\r\n      <error-code>404</error-code>\r\n      <location>/error.jsp</location>\r\n  </error-page>\r\n\r\n  <error-page>\r\n      <exception-type>java.lang.Exception</exception-type>\r\n      <location>/error.jsp</location>\r\n  </error-page>\r\n```\r\n\r\n⑤配置安全认证方式：\r\n\r\n```\r\n  <security-constraint>\r\n      <web-resource-collection>\r\n          <web-resource-name>ProtectedArea</web-resource-name>\r\n          <url-pattern>/admin/*</url-pattern>\r\n          <http-method>GET</http-method>\r\n          <http-method>POST</http-method>\r\n      </web-resource-collection>\r\n      <auth-constraint>\r\n          <role-name>admin</role-name>\r\n      </auth-constraint>\r\n  </security-constraint>\r\n\r\n  <login-config>\r\n      <auth-method>BASIC</auth-method>\r\n  </login-config>\r\n\r\n  <security-role>\r\n      <role-name>admin</role-name>\r\n  </security-role>\r\n```\r\n\r\n> **说明：**对 Servlet（小服务）、Listener（监听器）和 Filter（过滤器）等 Web 组件的配置，Servlet 3 规范提供了基于注解的配置方式，可以分别使用 @WebServlet、@WebListener、@WebFilter 注解进行配置。\r\n> \r\n> * * *\r\n> \r\n> **补充：**如果 Web 提供了有价值的商业信息或者是敏感数据，那么站点的安全性就是必须考虑的问题。安全认证是实现安全性的重要手段，认证就是要解决 “Are you who you say you are?” 的问题。认证的方式非常多，简单说来可以分为三类：\r\n> A. What you know? — 口令\r\n> B. What you have? — 数字证书（U 盾、密保卡）\r\n> C. Who you are? — 指纹识别、虹膜识别\r\n> 在 Tomcat 中可以通过建立安全套接字层（Secure Socket Layer, SSL）以及通过基本验证或表单验证来实现对安全性的支持。\r\n\r\n**109、你的项目中使用过哪些 JSTL 标签？**\r\n答：项目中主要使用了 JSTL 的核心标签库，包括 <c:if>、<c:choose>、<c: when>、<c: otherwise>、<c:forEach > 等，主要用于构造循环和分支结构以控制显示逻辑。\r\n\r\n> **说明：**虽然 JSTL 标签库提供了 core、sql、fmt、xml 等标签库，但是实际开发中建议只使用核心标签库（core），而且最好只使用分支和循环标签并辅以表达式语言（EL），这样才能真正做到数据显示和业务逻辑的分离，这才是最佳实践。\r\n\r\n**110、使用标签库有什么好处？如何自定义 JSP 标签？**\r\n答：使用标签库的好处包括以下几个方面：\r\n- 分离 JSP 页面的内容和逻辑，简化了 Web 开发；\r\n- 开发者可以创建自定义标签来封装业务逻辑和显示逻辑；\r\n- 标签具有很好的可移植性、可维护性和可重用性；\r\n- 避免了对 Scriptlet（小脚本）的使用（很多公司的项目开发都不允许在 JSP 中书写小脚本）\r\n\r\n自定义 JSP 标签包括以下几个步骤：\r\n- 编写一个 Java 类实现实现 Tag/BodyTag/IterationTag 接口（开发中通常不直接实现这些接口而是继承 TagSupport/BodyTagSupport/SimpleTagSupport 类，这是对缺省适配模式的应用），重写 doStartTag()、doEndTag() 等方法，定义标签要完成的功能\r\n- 编写扩展名为 tld 的标签描述文件对自定义标签进行部署，tld 文件通常放在 WEB-INF 文件夹下或其子目录中\r\n- 在 JSP 页面中使用 taglib 指令引用该标签库\r\n\r\n下面是一个自定义标签库的例子。\r\n\r\n步骤 1 - 标签类源代码 TimeTag.java：\r\n\r\n```\r\npackage com.jackfrued.tags;\r\n\r\nimport java.io.IOException;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\n\r\nimport javax.servlet.jsp.JspException;\r\nimport javax.servlet.jsp.JspWriter;\r\nimport javax.servlet.jsp.tagext.TagSupport;\r\n\r\npublic class TimeTag extends TagSupport {\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    private String format = \"yyyy-MM-dd hh:mm:ss\";\r\n    private String foreColor = \"black\";\r\n    private String backColor = \"white\";\r\n\r\n    public int doStartTag() throws JspException {\r\n         SimpleDateFormat sdf = new SimpleDateFormat(format);\r\n         JspWriter writer = pageContext.getOut();\r\n         StringBuilder sb = new StringBuilder();\r\n         sb.append(String.format(\"<span style=\'color:%s;background-color:%s\'>%s</span>\",\r\n             foreColor, backColor, sdf.format(new Date())));\r\n         try {\r\n           writer.print(sb.toString());\r\n         } catch(IOException e) {\r\n           e.printStackTrace();\r\n         }\r\n         return SKIP_BODY;\r\n      }\r\n\r\n    public void setFormat(String format) {\r\n        this.format = format;\r\n    }\r\n\r\n    public void setForeColor(String foreColor) {\r\n        this.foreColor = foreColor;\r\n    }\r\n\r\n    public void setBackColor(String backColor) {\r\n        this.backColor = backColor;\r\n    }\r\n}\r\n```\r\n\r\n步骤 2 - 编写标签库描述文件 my.tld：\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee \r\n    http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\"\r\n    version=\"2.0\">\r\n\r\n    <description>定义标签库</description>\r\n    <tlib-version>1.0</tlib-version>\r\n    <short-name>MyTag</short-name>\r\n    <tag>\r\n        <name>time</name>\r\n        <tag-class>com.jackfrued.tags.TimeTag</tag-class>\r\n        <body-content>empty</body-content>\r\n        <attribute>\r\n            <name>format</name>\r\n            <required>false</required>\r\n        </attribute>\r\n        <attribute>\r\n            <name>foreColor</name>\r\n        </attribute>\r\n        <attribute>\r\n            <name>backColor</name>\r\n        </attribute>\r\n    </tag>\r\n</taglib>\r\n```\r\n\r\n步骤 3 - 在 JSP 页面中使用自定义标签：\r\n\r\n```\r\n<%@ page pageEncoding=\"UTF-8\"%>\r\n<%@ taglib prefix=\"my\" uri=\"/WEB-INF/tld/my.tld\" %>\r\n<%\r\nString path = request.getContextPath();\r\nString basePath = request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort() + path + \"/\";\r\n%>\r\n\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <base href=\"<%=basePath%>\">\r\n    <title>首页</title>\r\n    <style type=\"text/css\">\r\n        * { font-family: \"Arial\"; font-size:72px; }\r\n    </style>\r\n  </head>\r\n\r\n  <body>\r\n    <my:time format=\"yyyy-MM-dd\" backColor=\"blue\" foreColor=\"yellow\"/>\r\n  </body>\r\n</html>\r\n```\r\n\r\n> **提示：**如果要将自定义的标签库发布成 JAR 文件，需要将标签库描述文件（tld 文件）放在 JAR 文件的 META-INF 目录下，可以 JDK 中的 jar 工具完成 JAR 文件的生成，如果不清楚如何操作，可以请教[谷老师和百老师](http://www.baigoogledu.com)。\r\n\r\n**111、说一下表达式语言（EL）的隐式对象及其作用。**\r\n答：EL 的隐式对象包括：pageContext、initParam（访问上下文参数）、param（访问请求参数）、paramValues、header（访问请求头）、headerValues、cookie（访问 cookie）、applicationScope（访问 application 作用域）、sessionScope（访问 session 作用域）、requestScope（访问 request 作用域）、pageScope（访问 page 作用域）。\r\n\r\n用法如下所示：\r\n\r\n```\r\n${pageContext.request.method}\r\n${pageContext[\"request\"][\"method\"]}\r\n${pageContext.request[\"method\"]}\r\n${pageContext[\"request\"].method}\r\n${initParam.defaultEncoding}\r\n${header[\"accept-language\"]}\r\n${headerValues[\"accept-language\"][0]}\r\n${cookie.jsessionid.value}\r\n${sessionScope.loginUser.username}\r\n```\r\n\r\n> **补充：**表达式语言的. 和 [] 运算作用是一致的，唯一的差别在于如果访问的属性名不符合 Java 标识符命名规则，例如上面的 accept-language 就不是一个有效的 Java 标识符，那么这时候就只能用 [] 运算符而不能使用. 运算符获取它的值\r\n\r\n**112、表达式语言（EL）支持哪些运算符？**\r\n答：除了. 和 [] 运算符，EL 还提供了：\r\n- 算术运算符：+、-、*、/ 或 div、% 或 mod\r\n- 关系运算符：== 或 eq、!= 或 ne、> 或 gt、>= 或 ge、< 或 lt、<= 或 le\r\n- 逻辑运算符：&& 或 and、|| 或 or、! 或 not\r\n- 条件运算符：${statement? A : B}（跟 Java 的条件运算符类似）\r\n- empty 运算符：检查一个值是否为 null 或者空（数组长度为 0 或集合中没有元素也返回 true）\r\n\r\n**113、Java Web 开发的 Model 1 和 Model 2 分别指的是什么？**\r\n答：Model 1 是以页面为中心的 Java Web 开发，使用 JSP+JavaBean 技术将页面显示逻辑和业务逻辑处理分开，JSP 实现页面显示，JavaBean 对象用来保存数据和实现业务逻辑。Model 2 是基于 MVC（模型 - 视图 - 控制器，Model-View-Controller）架构模式的开发模型，实现了模型和视图的彻底分离，利于团队开发和代码复用，如下图所示。\r\n\r\n![](https://img-blog.csdn.net/20150409102658882)\r\n\r\n**114、Servlet 3 中的异步处理指的是什么？**\r\n答：在 Servlet 3 中引入了一项新的技术可以让 Servlet 异步处理请求。有人可能会质疑，既然都有多线程了，还需要异步处理请求吗？答案是肯定的，因为如果一个任务处理时间相当长，那么 Servlet 或 Filter 会一直占用着请求处理线程直到任务结束，随着并发用户的增加，容器将会遭遇线程超出的风险，这这种情况下很多的请求将会被堆积起来而后续的请求可能会遭遇拒绝服务，直到有资源可以处理请求为止。异步特性可以帮助应用节省容器中的线程，特别适合执行时间长而且用户需要得到结果的任务，如果用户不需要得到结果则直接将一个 Runnable 对象交给 Executor 并立即返回即可。（如果不清楚多线程和线程池的相关内容，请查看[《Java 面试题全集（上）》](http://blog.csdn.net/jackfrued/article/details/44921941)关于多线程和线程池的部分或阅读我的另一篇文章[《关于 Java 并发编程的总结和思考》](http://blog.csdn.net/jackfrued/article/details/44499227)）\r\n\r\n> **补充：**多线程在 Java 诞生初期无疑是一个亮点，而 Servlet 单实例多线程的工作方式也曾为其赢得美名，然而技术的发展往往会颠覆我们很多的认知，就如同当年爱因斯坦的相对论颠覆了牛顿的经典力学一般。事实上，异步处理绝不是 Serlvet 3 首创，如果你了解 Node.js 的话，对 Servlet 3 的这个重要改进就不以为奇了。\r\n\r\n下面是一个支持异步处理请求的 Servlet 的例子。\r\n\r\n```\r\nimport java.io.IOException;\r\nimport javax.servlet.AsyncContext;\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\n@WebServlet(urlPatterns = {\"/async\"}, asyncSupported = true)\r\npublic class AsyncServlet extends HttpServlet {\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    @Override\r\n    public void doGet(HttpServletRequest req, HttpServletResponse resp) \r\n            throws ServletException, IOException {\r\n        // 开启Tomcat异步Servlet支持\r\n        req.setAttribute(\"org.apache.catalina.ASYNC_SUPPORTED\", true);\r\n\r\n        final AsyncContext ctx = req.startAsync();  // 启动异步处理的上下文\r\n        // ctx.setTimeout(30000);\r\n        ctx.start(new Runnable() {\r\n\r\n            @Override\r\n            public void run() {\r\n                // 在此处添加异步处理的代码\r\n\r\n                ctx.complete();\r\n            }\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n**115、如何在基于 Java 的 Web 项目中实现文件上传和下载？**\r\n答：在 Sevlet 3 以前，Servlet API 中没有支持上传功能的 API，因此要实现上传功能需要引入第三方工具从 POST 请求中获得上传的附件或者通过自行处理输入流来获得上传的文件，我们推荐使用 Apache 的 commons-fileupload。\r\n从 Servlet 3 开始，文件上传变得无比简单，相信看看下面的例子一切都清楚了。\r\n\r\n上传页面 index.jsp：\r\n\r\n```\r\n<%@ page pageEncoding=\"utf-8\"%>\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\r\n<title>Photo Upload</title>\r\n</head>\r\n<body>\r\n<h1>Select your photo and upload</h1>\r\n<hr/>\r\n<div style=\"color:red;font-size:14px;\">${hint}</div>\r\n<form action=\"UploadServlet\" method=\"post\" enctype=\"multipart/form-data\">\r\n    Photo file: <input type=\"file\"  />\r\n    <input type=\"submit\" value=\"Upload\" />\r\n</form>\r\n</body>\r\n</html>\r\n```\r\n\r\n支持上传的 Servlet：\r\n\r\n```\r\npackage com.jackfrued.servlet;\r\n\r\nimport java.io.IOException;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.MultipartConfig;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport javax.servlet.http.Part;\r\n\r\n@WebServlet(\"/UploadServlet\")\r\n@MultipartConfig\r\npublic class UploadServlet extends HttpServlet {\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    protected void doPost(HttpServletRequest request,\r\n            HttpServletResponse response) throws ServletException, IOException {\r\n        // 可以用request.getPart()方法获得名为photo的上传附件\r\n        // 也可以用request.getParts()获得所有上传附件（多文件上传）\r\n        // 然后通过循环分别处理每一个上传的文件\r\n        Part part = request.getPart(\"photo\");\r\n        if (part != null && part.getSubmittedFileName().length() > 0) {\r\n            // 用ServletContext对象的getRealPath()方法获得上传文件夹的绝对路径\r\n            String savePath = request.getServletContext().getRealPath(\"/upload\");\r\n            // Servlet 3.1规范中可以用Part对象的getSubmittedFileName()方法获得上传的文件名\r\n            // 更好的做法是为上传的文件进行重命名（避免同名文件的相互覆盖）\r\n            part.write(savePath + \"/\" + part.getSubmittedFileName());\r\n            request.setAttribute(\"hint\", \"Upload Successfully!\");\r\n        } else {\r\n            request.setAttribute(\"hint\", \"Upload failed!\");\r\n        }\r\n        // 跳转回到上传页面\r\n        request.getRequestDispatcher(\"index.jsp\").forward(request, response);\r\n    }\r\n\r\n}\r\n```\r\n\r\n**116、服务器收到用户提交的表单数据，到底是调用 Servlet 的 doGet() 还是 doPost() 方法？**\r\n答：HTML 的 <form> 元素有一个 method 属性，用来指定提交表单的方式，其值可以是 get 或 post。我们自定义的 Servlet 一般情况下会重写 doGet() 或 doPost() 两个方法之一或全部，如果是 GET 请求就调用 doGet() 方法，如果是 POST 请求就调用 doPost() 方法，那为什么为什么这样呢？我们自定义的 Servlet 通常继承自 HttpServlet，HttpServlet 继承自 GenericServlet 并重写了其中的 service() 方法，这个方法是 Servlet 接口中定义的。HttpServlet 重写的 service() 方法会先获取用户请求的方法，然后根据请求方法调用 doGet()、doPost()、doPut()、doDelete() 等方法，如果在自定义 Servlet 中重写了这些方法，那么显然会调用重写过的（自定义的）方法，这显然是对模板方法模式的应用（如果不理解，请参考阎宏博士的《Java 与模式》一书的第 37 章）。当然，自定义 Servlet 中也可以直接重写 service() 方法，那么不管是哪种方式的请求，都可以通过自己的代码进行处理，这对于不区分请求方法的场景比较合适。\r\n\r\n**117、JSP 中的静态包含和动态包含有什么区别？**\r\n答：静态包含是通过 JSP 的 include 指令包含页面，动态包含是通过 JSP 标准动作 <jsp:forward> 包含页面。静态包含是编译时包含，如果包含的页面不存在则会产生编译错误，而且两个页面的 \"contentType\" 属性应保持一致，因为两个页面会合二为一，只产生一个 class 文件，因此被包含页面发生的变动再包含它的页面更新前不会得到更新。动态包含是运行时包含，可以向被包含的页面传递参数，包含页面和被包含页面是独立的，会编译出两个 class 文件，如果被包含的页面不存在，不会产生编译错误，也不影响页面其他部分的执行。代码如下所示：\r\n\r\n```\r\n<%-- 静态包含 --%>\r\n<%@ include file=\"...\" %>\r\n\r\n<%-- 动态包含 --%>\r\n<jsp:include page=\"...\">\r\n    <jsp:param  />\r\n</jsp:include>\r\n```\r\n\r\n**118、Servlet 中如何获取用户提交的查询参数或表单数据？**\r\n答：可以通过请求对象（HttpServletRequest）的 getParameter() 方法通过参数名获得参数值。如果有包含多个值的参数（例如复选框），可以通过请求对象的 getParameterValues() 方法获得。当然也可以通过请求对象的 getParameterMap() 获得一个参数名和参数值的映射（Map）。\r\n\r\n**119、Servlet 中如何获取用户配置的初始化参数以及服务器上下文参数？**\r\n答：可以通过重写 Servlet 接口的 init(ServletConfig) 方法并通过 ServletConfig 对象的 getInitParameter() 方法来获取 Servlet 的初始化参数。可以通过 ServletConfig 对象的 getServletContext() 方法获取 ServletContext 对象，并通过该对象的 getInitParameter() 方法来获取服务器上下文参数。当然，ServletContext 对象也在处理用户请求的方法（如 doGet() 方法）中通过请求对象的 getServletContext() 方法来获得。\r\n\r\n**120、如何设置请求的编码以及响应内容的类型？**\r\n答：通过请求对象（ServletRequest）的 setCharacterEncoding(String) 方法可以设置请求的编码，其实要彻底解决乱码问题就应该让页面、服务器、请求和响应、Java 程序都使用统一的编码，最好的选择当然是 UTF-8；通过响应对象（ServletResponse）的 setContentType(String) 方法可以设置响应内容的类型，当然也可以通过 HttpServletResponsed 对象的 setHeader(String, String) 方法来设置。\r\n\r\n> **说明：**现在如果还有公司在面试的时候问 JSP 的声明标记、表达式标记、小脚本标记这些内容的话，这样的公司也不用去了，其实 JSP 内置对象、JSP 指令这些东西基本上都可以忘却了，关于 Java Web 开发的相关知识，可以看一下我的[《Servlet&JSP 思维导图》](http://blog.csdn.net/jackfrued/article/details/42617675)，上面有完整的知识点的罗列。想了解如何实现自定义 MVC 框架的，可以看一下我的[《Java Web 自定义 MVC 框架详解》](http://blog.csdn.net/jackfrued/article/details/42774459)。\r\n\r\n**121、解释一下网络应用的模式及其特点。**\r\n答：典型的网络应用模式大致有三类：B/S、C/S、P2P。其中 B 代表浏览器（Browser）、C 代表客户端（Client）、S 代表服务器（Server），P2P 是对等模式，不区分客户端和服务器。B/S 应用模式中可以视为特殊的 C/S 应用模式，只是将 C/S 应用模式中的特殊的客户端换成了浏览器，因为几乎所有的系统上都有浏览器，那么只要打开浏览器就可以使用应用，没有安装、配置、升级客户端所带来的各种开销。P2P 应用模式中，成千上万台彼此连接的计算机都处于对等的地位，整个网络一般来说不依赖专用的集中服务器。网络中的每一台计算机既能充当网络服务的请求者，又对其它计算机的请求作出响应，提供资源和服务。通常这些资源和服务包括：信息的共享和交换、计算资源（如 CPU 的共享）、存储共享（如缓存和磁盘空间的使用）等，这种应用模式最大的阻力安全性、版本等问题，目前有很多应用都混合使用了多种应用模型，最常见的网络视频应用，它几乎把三种模式都用上了。\r\n\r\n> **补充：**此题要跟 \"电子商务模式\" 区分开，因为有很多人被问到这个问题的时候马上想到的是 B2B（如阿里巴巴）、B2C（如当当、亚马逊、京东）、C2C（如淘宝、拍拍）、C2B（如威客）、O2O（如美团、饿了么）。对于这类问题，可以去[百度](http://www.baidu.com)上面科普一下。\r\n\r\n**122、什么是 Web Service（Web 服务）？**\r\n答：从表面上看，Web Service 就是一个应用程序，它向外界暴露出一个能够通过 Web 进行调用的 API。这就是说，你能够用编程的方法透明的调用这个应用程序，不需要了解它的任何细节，跟你使用的编程语言也没有关系。例如可以创建一个提供天气预报的 Web Service，那么无论你用哪种编程语言开发的应用都可以通过调用它的 API 并传入城市信息来获得该城市的天气预报。之所以称之为 Web Service，是因为它基于 HTTP 协议传输数据，这使得运行在不同机器上的不同应用无须借助附加的、专门的第三方软件或硬件，就可相互交换数据或集成。\r\n\r\n> **补充：**这里必须要提及的一个概念是 SOA（Service-Oriented Architecture，面向服务的架构），SOA 是一种思想，它将应用程序的不同功能单元通过中立的契约联系起来，独立于硬件平台、操作系统和编程语言，使得各种形式的功能单元能够更好的集成。显然，Web Service 是 SOA 的一种较好的解决方案，它更多的是一种标准，而不是一种具体的技术。\r\n\r\n**123、概念解释：SOAP、WSDL、UDDI。**\r\n答：\r\n- SOAP：简单对象访问协议（<u>S</u>imple <u>O</u>bject <u>A</u>ccess <u>P</u>rotocol），是 Web Service 中交换数据的一种协议规范。\r\n- WSDL：Web 服务描述语言（Web Service Description Language），它描述了 Web 服务的公共接口。这是一个基于 XML 的关于如何与 Web 服务通讯和使用的服务描述；也就是描述与目录中列出的 Web 服务进行交互时需要绑定的协议和信息格式。通常采用抽象语言描述该服务支持的操作和信息，使用的时候再将实际的网络协议和信息格式绑定给该服务。\r\n- UDDI：统一描述、发现和集成（Universal Description, Discovery and Integration），它是一个基于 XML 的跨平台的描述规范，可以使世界范围内的企业在互联网上发布自己所提供的服务。简单的说，UDDI 是访问各种 WSDL 的一个门面（可以参考设计模式中的门面模式）。\r\n\r\n> **提示：**关于 Web Service 的相关概念和知识可以在 [W3CSchool](http://www.w3cschool.cc/webservices/webservices-tutorial.html) 上找到相关的资料。\r\n\r\n**124、Java 规范中和 Web Service 相关的规范有哪些？**\r\n答：Java 规范中和 Web Service 相关的有三个：\r\n- JAX-WS(JSR 224)：这个规范是早期的基于 SOAP 的 Web Service 规范 JAX-RPC 的替代版本，它并不提供向下兼容性，因为 RPC 样式的 WSDL 以及相关的 API 已经在 Java EE5 中被移除了。WS-MetaData 是 JAX-WS 的依赖规范，提供了基于注解配置 Web Service 和 SOAP 消息的相关 API。\r\n- JAXM(JSR 67)：定义了发送和接收消息所需的 API, 相当于 Web Service 的服务器端。\r\n- JAX-RS(JSR 311 & JSR 339 & JSR 370)：是 Java 针对 REST（Representation State Transfer）架构风格制定的一套 Web Service 规范。REST 是一种软件架构模式，是一种风格，它不像 SOAP 那样本身承载着一种消息协议， (两种风格的 Web Service 均采用了 HTTP 做传输协议，因为 HTTP 协议能穿越防火墙，Java 的远程方法调用（RMI）等是重量级协议，通常不能穿越防火墙），因此可以将 REST 视为基于 HTTP 协议的软件架构。REST 中最重要的两个概念是资源定位和资源操作，而 HTTP 协议恰好完整的提供了这两个点。HTTP 协议中的 URI 可以完成资源定位，而 GET、POST、OPTION、DELETE 方法可以完成资源操作。因此 REST 完全依赖 HTTP 协议就可以完成 Web Service，而不像 SOAP 协议那样只利用了 HTTP 的传输特性，定位和操作都是由 SOAP 协议自身完成的，也正是由于 SOAP 消息的存在使得基于 SOAP 的 Web Service 显得笨重而逐渐被淘汰。\r\n\r\n**125、介绍一下你了解的 Java 领域的 Web Service 框架。**\r\n答：Java 领域的 Web Service 框架很多，包括 [Axis2](https://axis.apache.org/axis2/java/core/)（Axis 的升级版本）、[Jersey](https://jersey.java.net)（RESTful 的 Web Service 框架）、[CXF](http://cxf.apache.org)（XFire 的延续版本）、[Hessian](http://hessian.caucho.com)、[Turmeric](https://github.com/ebay)、[JBoss SOA](http://www.redhat.com/en/technologies/jboss-middleware) 等，其中绝大多数都是开源框架。\r\n\r\n> **提示：**面试被问到这类问题的时候一定选择自己用过的最熟悉的作答，如果之前没有了解过就应该在面试前花一些时间了解其中的两个，并比较其优缺点，这样才能在面试时给出一个漂亮的答案。\r\n\r\n<link href=\"https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7b4cdcb592.css\" rel=\"stylesheet\"> <sr-plugin-count>共计：34861 个字</sr-plugin-count>',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,0);
/*!40000 ALTER TABLE `typecho_contents` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_fields`
--

DROP TABLE IF EXISTS `typecho_fields`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_fields` (
  `cid` int(10) unsigned NOT NULL,
  `name` varchar(200) NOT NULL,
  `type` varchar(8) DEFAULT 'str',
  `str_value` text,
  `int_value` int(10) DEFAULT '0',
  `float_value` float DEFAULT '0',
  PRIMARY KEY (`cid`,`name`),
  KEY `int_value` (`int_value`),
  KEY `float_value` (`float_value`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_fields`
--

LOCK TABLES `typecho_fields` WRITE;
/*!40000 ALTER TABLE `typecho_fields` DISABLE KEYS */;
INSERT INTO `typecho_fields` VALUES (14,'thumbnail','str','',0,0),(14,'previewContent','str','',0,0),(20,'thumbnail','str','',0,0),(20,'previewContent','str','',0,0),(14,'description','str','',0,0),(14,'picUrl','str','',0,0),(23,'picUrl','str','',0,0),(23,'description','str','',0,0),(24,'picUrl','str','',0,0),(24,'description','str','',0,0),(26,'picUrl','str','',0,0),(26,'description','str','',0,0),(27,'picUrl','str','',0,0),(27,'description','str','',0,0),(28,'picUrl','str','',0,0),(28,'description','str','',0,0),(29,'picUrl','str','',0,0),(29,'description','str','',0,0),(32,'picUrl','str','',0,0),(32,'description','str','',0,0),(33,'picUrl','str','',0,0),(33,'description','str','',0,0),(35,'picUrl','str','',0,0),(35,'description','str','',0,0),(7,'picUrl','str','',0,0),(7,'description','str','',0,0),(6,'picUrl','str','',0,0),(6,'description','str','',0,0),(38,'picUrl','str','',0,0),(38,'description','str','',0,0);
/*!40000 ALTER TABLE `typecho_fields` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_golinks`
--

DROP TABLE IF EXISTS `typecho_golinks`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_golinks` (
  `id` int(8) NOT NULL AUTO_INCREMENT,
  `key` varchar(32) NOT NULL,
  `target` varchar(10000) NOT NULL,
  `count` int(8) DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_golinks`
--

LOCK TABLES `typecho_golinks` WRITE;
/*!40000 ALTER TABLE `typecho_golinks` DISABLE KEYS */;
/*!40000 ALTER TABLE `typecho_golinks` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_metas`
--

DROP TABLE IF EXISTS `typecho_metas`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_metas` (
  `mid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(200) DEFAULT NULL,
  `slug` varchar(200) DEFAULT NULL,
  `type` varchar(32) NOT NULL,
  `description` varchar(200) DEFAULT NULL,
  `count` int(10) unsigned DEFAULT '0',
  `order` int(10) unsigned DEFAULT '0',
  `parent` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`mid`),
  KEY `slug` (`slug`)
) ENGINE=MyISAM AUTO_INCREMENT=12 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_metas`
--

LOCK TABLES `typecho_metas` WRITE;
/*!40000 ALTER TABLE `typecho_metas` DISABLE KEYS */;
INSERT INTO `typecho_metas` VALUES (1,'未归档','default','category','只是一个默认分类',4,1,0),(2,'剑指offer','剑指offer','tag',NULL,2,0,0),(3,'java','java','tag',NULL,2,0,0),(4,'java','java','category',NULL,0,2,0),(5,'生活','生活','category',NULL,0,3,0),(6,'算法','算法','category',NULL,0,4,0),(7,'SpringCloud','SpringCloud','category',NULL,1,1,4),(8,'java 基础','java-基础','category',NULL,4,2,4),(9,'剑指offer','剑指offer','category',NULL,3,1,6),(10,'问题备忘录','问题备忘录','category',NULL,0,5,0),(11,'effective-java','effective-java','category',NULL,2,3,4);
/*!40000 ALTER TABLE `typecho_metas` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_options`
--

DROP TABLE IF EXISTS `typecho_options`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_options` (
  `name` varchar(32) NOT NULL,
  `user` int(10) unsigned NOT NULL DEFAULT '0',
  `value` text,
  PRIMARY KEY (`name`,`user`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_options`
--

LOCK TABLES `typecho_options` WRITE;
/*!40000 ALTER TABLE `typecho_options` DISABLE KEYS */;
INSERT INTO `typecho_options` VALUES ('theme',0,'Material'),('timezone',0,'28800'),('lang',0,NULL),('charset',0,'UTF-8'),('contentType',0,'text/html'),('gzip',0,'0'),('generator',0,'Typecho 1.2/18.10.23'),('title',0,'Hello World'),('description',0,'Just So So ...'),('keywords',0,'typecho,php,blog'),('rewrite',0,'0'),('frontPage',0,'recent'),('frontArchive',0,'0'),('commentsRequireMail',0,'1'),('commentsWhitelist',0,'0'),('commentsRequireURL',0,'0'),('commentsRequireModeration',0,'0'),('plugins',0,'a:2:{s:9:\"activated\";a:8:{s:10:\"RobotsPlus\";a:1:{s:7:\"handles\";a:1:{s:21:\"Widget_Archive:header\";a:1:{i:0;a:2:{i:0;s:17:\"RobotsPlus_Plugin\";i:1;s:5:\"isbot\";}}}}s:7:\"Sitemap\";a:0:{}s:7:\"GoLinks\";a:0:{}s:12:\"RoutesHelper\";a:0:{}s:10:\"HelloWorld\";a:1:{s:7:\"handles\";a:1:{s:21:\"admin/menu.php:navBar\";a:1:{i:0;a:2:{i:0;s:17:\"HelloWorld_Plugin\";i:1;s:6:\"render\";}}}}s:7:\"editorG\";a:1:{s:7:\"handles\";a:2:{s:27:\"admin/write-post.php:bottom\";a:1:{i:0;a:2:{i:0;s:14:\"editorG_Plugin\";i:1;s:6:\"button\";}}s:27:\"admin/write-page.php:bottom\";a:1:{i:0;a:2:{i:0;s:14:\"editorG_Plugin\";i:1;s:6:\"button\";}}}}s:15:\"CodeHighlighter\";a:1:{s:7:\"handles\";a:2:{s:21:\"Widget_Archive:header\";a:1:{i:0;a:2:{i:0;s:22:\"CodeHighlighter_Plugin\";i:1;s:6:\"header\";}}s:21:\"Widget_Archive:footer\";a:1:{i:0;a:2:{i:0;s:22:\"CodeHighlighter_Plugin\";i:1;s:6:\"footer\";}}}}s:13:\"MarkdownParse\";a:1:{s:7:\"handles\";a:2:{s:33:\"Widget_Abstract_Contents:markdown\";a:1:{i:0;a:2:{i:0;s:20:\"MarkdownParse_Plugin\";i:1;s:5:\"parse\";}}s:33:\"Widget_Abstract_Comments:markdown\";a:1:{i:0;a:2:{i:0;s:20:\"MarkdownParse_Plugin\";i:1;s:5:\"parse\";}}}}}s:7:\"handles\";a:7:{s:21:\"Widget_Archive:header\";a:2:{i:0;a:2:{i:0;s:17:\"RobotsPlus_Plugin\";i:1;s:5:\"isbot\";}s:5:\"0.001\";a:2:{i:0;s:22:\"CodeHighlighter_Plugin\";i:1;s:6:\"header\";}}s:21:\"admin/menu.php:navBar\";a:1:{i:0;a:2:{i:0;s:17:\"HelloWorld_Plugin\";i:1;s:6:\"render\";}}s:27:\"admin/write-post.php:bottom\";a:1:{i:0;a:2:{i:0;s:14:\"editorG_Plugin\";i:1;s:6:\"button\";}}s:27:\"admin/write-page.php:bottom\";a:1:{i:0;a:2:{i:0;s:14:\"editorG_Plugin\";i:1;s:6:\"button\";}}s:21:\"Widget_Archive:footer\";a:1:{i:0;a:2:{i:0;s:22:\"CodeHighlighter_Plugin\";i:1;s:6:\"footer\";}}s:33:\"Widget_Abstract_Contents:markdown\";a:1:{i:0;a:2:{i:0;s:20:\"MarkdownParse_Plugin\";i:1;s:5:\"parse\";}}s:33:\"Widget_Abstract_Comments:markdown\";a:1:{i:0;a:2:{i:0;s:20:\"MarkdownParse_Plugin\";i:1;s:5:\"parse\";}}}}'),('commentDateFormat',0,'F jS, Y \\a\\t h:i a'),('siteUrl',0,'http://118.126.105.229'),('defaultCategory',0,'1'),('allowRegister',0,'0'),('defaultAllowComment',0,'1'),('defaultAllowPing',0,'1'),('defaultAllowFeed',0,'1'),('pageSize',0,'5'),('postsListSize',0,'10'),('commentsListSize',0,'10'),('commentsHTMLTagAllowed',0,NULL),('postDateFormat',0,'Y-m-d'),('feedFullText',0,'0'),('editorSize',0,'350'),('autoSave',0,'0'),('markdown',0,'1'),('xmlrpcMarkdown',0,'0'),('commentsMaxNestingLevels',0,'5'),('commentsPostTimeout',0,'2592000'),('commentsUrlNofollow',0,'1'),('commentsShowUrl',0,'1'),('commentsMarkdown',0,'0'),('commentsPageBreak',0,'0'),('commentsThreaded',0,'1'),('commentsPageSize',0,'20'),('commentsPageDisplay',0,'last'),('commentsOrder',0,'ASC'),('commentsCheckReferer',0,'1'),('commentsAutoClose',0,'0'),('commentsPostIntervalEnable',0,'1'),('commentsPostInterval',0,'60'),('commentsShowCommentOnly',0,'0'),('commentsAvatar',0,'1'),('commentsAvatarRating',0,'G'),('commentsAntiSpam',0,'1'),('routingTable',0,'a:28:{i:0;a:27:{s:5:\"index\";a:6:{s:3:\"url\";s:1:\"/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:8:\"|^[/]?$|\";s:6:\"format\";s:1:\"/\";s:6:\"params\";a:0:{}}s:7:\"archive\";a:6:{s:3:\"url\";s:6:\"/blog/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:13:\"|^/blog[/]?$|\";s:6:\"format\";s:6:\"/blog/\";s:6:\"params\";a:0:{}}s:2:\"do\";a:6:{s:3:\"url\";s:22:\"/action/[action:alpha]\";s:6:\"widget\";s:9:\"Widget_Do\";s:6:\"action\";s:6:\"action\";s:4:\"regx\";s:32:\"|^/action/([_0-9a-zA-Z-]+)[/]?$|\";s:6:\"format\";s:10:\"/action/%s\";s:6:\"params\";a:1:{i:0;s:6:\"action\";}}s:4:\"post\";a:6:{s:3:\"url\";s:23:\"/[category]/[slug].html\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:30:\"|^/([^/]+)/([^/]+)\\.html[/]?$|\";s:6:\"format\";s:11:\"/%s/%s.html\";s:6:\"params\";a:2:{i:0;s:8:\"category\";i:1;s:4:\"slug\";}}s:10:\"attachment\";a:6:{s:3:\"url\";s:26:\"/attachment/[cid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:28:\"|^/attachment/([0-9]+)[/]?$|\";s:6:\"format\";s:15:\"/attachment/%s/\";s:6:\"params\";a:1:{i:0;s:3:\"cid\";}}s:8:\"category\";a:6:{s:3:\"url\";s:17:\"/category/[slug]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:25:\"|^/category/([^/]+)[/]?$|\";s:6:\"format\";s:13:\"/category/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"slug\";}}s:3:\"tag\";a:6:{s:3:\"url\";s:12:\"/tag/[slug]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:20:\"|^/tag/([^/]+)[/]?$|\";s:6:\"format\";s:8:\"/tag/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"slug\";}}s:6:\"author\";a:6:{s:3:\"url\";s:22:\"/author/[uid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:24:\"|^/author/([0-9]+)[/]?$|\";s:6:\"format\";s:11:\"/author/%s/\";s:6:\"params\";a:1:{i:0;s:3:\"uid\";}}s:6:\"search\";a:6:{s:3:\"url\";s:19:\"/search/[keywords]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:23:\"|^/search/([^/]+)[/]?$|\";s:6:\"format\";s:11:\"/search/%s/\";s:6:\"params\";a:1:{i:0;s:8:\"keywords\";}}s:10:\"index_page\";a:6:{s:3:\"url\";s:21:\"/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:22:\"|^/page/([0-9]+)[/]?$|\";s:6:\"format\";s:9:\"/page/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"page\";}}s:12:\"archive_page\";a:6:{s:3:\"url\";s:26:\"/blog/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:27:\"|^/blog/page/([0-9]+)[/]?$|\";s:6:\"format\";s:14:\"/blog/page/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"page\";}}s:13:\"category_page\";a:6:{s:3:\"url\";s:32:\"/category/[slug]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:34:\"|^/category/([^/]+)/([0-9]+)[/]?$|\";s:6:\"format\";s:16:\"/category/%s/%s/\";s:6:\"params\";a:2:{i:0;s:4:\"slug\";i:1;s:4:\"page\";}}s:8:\"tag_page\";a:6:{s:3:\"url\";s:27:\"/tag/[slug]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:29:\"|^/tag/([^/]+)/([0-9]+)[/]?$|\";s:6:\"format\";s:11:\"/tag/%s/%s/\";s:6:\"params\";a:2:{i:0;s:4:\"slug\";i:1;s:4:\"page\";}}s:11:\"author_page\";a:6:{s:3:\"url\";s:37:\"/author/[uid:digital]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:33:\"|^/author/([0-9]+)/([0-9]+)[/]?$|\";s:6:\"format\";s:14:\"/author/%s/%s/\";s:6:\"params\";a:2:{i:0;s:3:\"uid\";i:1;s:4:\"page\";}}s:11:\"search_page\";a:6:{s:3:\"url\";s:34:\"/search/[keywords]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:32:\"|^/search/([^/]+)/([0-9]+)[/]?$|\";s:6:\"format\";s:14:\"/search/%s/%s/\";s:6:\"params\";a:2:{i:0;s:8:\"keywords\";i:1;s:4:\"page\";}}s:12:\"archive_year\";a:6:{s:3:\"url\";s:18:\"/[year:digital:4]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:19:\"|^/([0-9]{4})[/]?$|\";s:6:\"format\";s:4:\"/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"year\";}}s:13:\"archive_month\";a:6:{s:3:\"url\";s:36:\"/[year:digital:4]/[month:digital:2]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:30:\"|^/([0-9]{4})/([0-9]{2})[/]?$|\";s:6:\"format\";s:7:\"/%s/%s/\";s:6:\"params\";a:2:{i:0;s:4:\"year\";i:1;s:5:\"month\";}}s:11:\"archive_day\";a:6:{s:3:\"url\";s:52:\"/[year:digital:4]/[month:digital:2]/[day:digital:2]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:41:\"|^/([0-9]{4})/([0-9]{2})/([0-9]{2})[/]?$|\";s:6:\"format\";s:10:\"/%s/%s/%s/\";s:6:\"params\";a:3:{i:0;s:4:\"year\";i:1;s:5:\"month\";i:2;s:3:\"day\";}}s:17:\"archive_year_page\";a:6:{s:3:\"url\";s:38:\"/[year:digital:4]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:33:\"|^/([0-9]{4})/page/([0-9]+)[/]?$|\";s:6:\"format\";s:12:\"/%s/page/%s/\";s:6:\"params\";a:2:{i:0;s:4:\"year\";i:1;s:4:\"page\";}}s:18:\"archive_month_page\";a:6:{s:3:\"url\";s:56:\"/[year:digital:4]/[month:digital:2]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:44:\"|^/([0-9]{4})/([0-9]{2})/page/([0-9]+)[/]?$|\";s:6:\"format\";s:15:\"/%s/%s/page/%s/\";s:6:\"params\";a:3:{i:0;s:4:\"year\";i:1;s:5:\"month\";i:2;s:4:\"page\";}}s:16:\"archive_day_page\";a:6:{s:3:\"url\";s:72:\"/[year:digital:4]/[month:digital:2]/[day:digital:2]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:55:\"|^/([0-9]{4})/([0-9]{2})/([0-9]{2})/page/([0-9]+)[/]?$|\";s:6:\"format\";s:18:\"/%s/%s/%s/page/%s/\";s:6:\"params\";a:4:{i:0;s:4:\"year\";i:1;s:5:\"month\";i:2;s:3:\"day\";i:3;s:4:\"page\";}}s:12:\"comment_page\";a:6:{s:3:\"url\";s:53:\"[permalink:string]/comment-page-[commentPage:digital]\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:36:\"|^(.+)/comment\\-page\\-([0-9]+)[/]?$|\";s:6:\"format\";s:18:\"%s/comment-page-%s\";s:6:\"params\";a:2:{i:0;s:9:\"permalink\";i:1;s:11:\"commentPage\";}}s:4:\"feed\";a:6:{s:3:\"url\";s:20:\"/feed[feed:string:0]\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:4:\"feed\";s:4:\"regx\";s:17:\"|^/feed(.*)[/]?$|\";s:6:\"format\";s:7:\"/feed%s\";s:6:\"params\";a:1:{i:0;s:4:\"feed\";}}s:8:\"feedback\";a:6:{s:3:\"url\";s:31:\"[permalink:string]/[type:alpha]\";s:6:\"widget\";s:15:\"Widget_Feedback\";s:6:\"action\";s:6:\"action\";s:4:\"regx\";s:29:\"|^(.+)/([_0-9a-zA-Z-]+)[/]?$|\";s:6:\"format\";s:5:\"%s/%s\";s:6:\"params\";a:2:{i:0;s:9:\"permalink\";i:1;s:4:\"type\";}}s:4:\"page\";a:6:{s:3:\"url\";s:12:\"/[slug].html\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:22:\"|^/([^/]+)\\.html[/]?$|\";s:6:\"format\";s:8:\"/%s.html\";s:6:\"params\";a:1:{i:0;s:4:\"slug\";}}s:7:\"sitemap\";a:6:{s:3:\"url\";s:12:\"/sitemap.xml\";s:6:\"widget\";s:14:\"Sitemap_Action\";s:6:\"action\";s:6:\"action\";s:4:\"regx\";s:21:\"|^/sitemap\\.xml[/]?$|\";s:6:\"format\";s:12:\"/sitemap.xml\";s:6:\"params\";a:0:{}}s:2:\"go\";a:6:{s:3:\"url\";s:10:\"/go/[key]/\";s:6:\"widget\";s:14:\"GoLinks_Action\";s:6:\"action\";s:6:\"golink\";s:4:\"regx\";s:19:\"|^/go/([^/]+)[/]?$|\";s:6:\"format\";s:7:\"/go/%s/\";s:6:\"params\";a:1:{i:0;s:3:\"key\";}}}s:5:\"index\";a:3:{s:3:\"url\";s:1:\"/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:7:\"archive\";a:3:{s:3:\"url\";s:6:\"/blog/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:2:\"do\";a:3:{s:3:\"url\";s:22:\"/action/[action:alpha]\";s:6:\"widget\";s:9:\"Widget_Do\";s:6:\"action\";s:6:\"action\";}s:4:\"post\";a:3:{s:3:\"url\";s:23:\"/[category]/[slug].html\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:10:\"attachment\";a:3:{s:3:\"url\";s:26:\"/attachment/[cid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:8:\"category\";a:3:{s:3:\"url\";s:17:\"/category/[slug]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:3:\"tag\";a:3:{s:3:\"url\";s:12:\"/tag/[slug]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:6:\"author\";a:3:{s:3:\"url\";s:22:\"/author/[uid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:6:\"search\";a:3:{s:3:\"url\";s:19:\"/search/[keywords]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:10:\"index_page\";a:3:{s:3:\"url\";s:21:\"/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:12:\"archive_page\";a:3:{s:3:\"url\";s:26:\"/blog/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:13:\"category_page\";a:3:{s:3:\"url\";s:32:\"/category/[slug]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:8:\"tag_page\";a:3:{s:3:\"url\";s:27:\"/tag/[slug]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:11:\"author_page\";a:3:{s:3:\"url\";s:37:\"/author/[uid:digital]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:11:\"search_page\";a:3:{s:3:\"url\";s:34:\"/search/[keywords]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:12:\"archive_year\";a:3:{s:3:\"url\";s:18:\"/[year:digital:4]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:13:\"archive_month\";a:3:{s:3:\"url\";s:36:\"/[year:digital:4]/[month:digital:2]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:11:\"archive_day\";a:3:{s:3:\"url\";s:52:\"/[year:digital:4]/[month:digital:2]/[day:digital:2]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:17:\"archive_year_page\";a:3:{s:3:\"url\";s:38:\"/[year:digital:4]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:18:\"archive_month_page\";a:3:{s:3:\"url\";s:56:\"/[year:digital:4]/[month:digital:2]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:16:\"archive_day_page\";a:3:{s:3:\"url\";s:72:\"/[year:digital:4]/[month:digital:2]/[day:digital:2]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:12:\"comment_page\";a:3:{s:3:\"url\";s:53:\"[permalink:string]/comment-page-[commentPage:digital]\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:4:\"feed\";a:3:{s:3:\"url\";s:20:\"/feed[feed:string:0]\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:4:\"feed\";}s:8:\"feedback\";a:3:{s:3:\"url\";s:31:\"[permalink:string]/[type:alpha]\";s:6:\"widget\";s:15:\"Widget_Feedback\";s:6:\"action\";s:6:\"action\";}s:4:\"page\";a:3:{s:3:\"url\";s:12:\"/[slug].html\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:7:\"sitemap\";a:3:{s:3:\"url\";s:12:\"/sitemap.xml\";s:6:\"widget\";s:14:\"Sitemap_Action\";s:6:\"action\";s:6:\"action\";}s:2:\"go\";a:3:{s:3:\"url\";s:10:\"/go/[key]/\";s:6:\"widget\";s:14:\"GoLinks_Action\";s:6:\"action\";s:6:\"golink\";}}'),('actionTable',0,'a:2:{s:7:\"golinks\";s:14:\"GoLinks_Action\";s:12:\"RoutesHelper\";s:19:\"RoutesHelper_Action\";}'),('panelTable',0,'a:2:{s:5:\"child\";a:3:{i:1;a:1:{i:0;a:6:{i:0;s:12:\"蜘蛛日志\";i:1;s:18:\"查看蜘蛛日志\";i:2;s:41:\"extending.php?panel=RobotsPlus%2FLogs.php\";i:3;s:13:\"administrator\";i:4;b:0;i:5;s:0:\"\";}}i:2;a:1:{i:0;a:6:{i:0;s:12:\"链接转换\";i:1;s:18:\"链接转换管理\";i:2;s:39:\"extending.php?panel=GoLinks%2Fpanel.php\";i:3;s:13:\"administrator\";i:4;b:0;i:5;s:0:\"\";}}i:4;a:1:{i:0;a:6:{i:0;s:12:\"路由助手\";i:1;s:12:\"路由助手\";i:2;s:44:\"extending.php?panel=RoutesHelper%2Fpanel.php\";i:3;s:13:\"administrator\";i:4;b:0;i:5;s:0:\"\";}}}s:4:\"file\";a:3:{i:0;s:21:\"RobotsPlus%2FLogs.php\";i:1;s:19:\"GoLinks%2Fpanel.php\";i:2;s:24:\"RoutesHelper%2Fpanel.php\";}}'),('attachmentTypes',0,'@image@,@media@,@doc@,jar,gz,md,tar,rpm'),('secret',0,'Dp^4iCsb58UnxQ3Ob9UpxZPuz9ssoUMR'),('installed',0,'1'),('allowXmlRpc',0,'2'),('autoSave',1,'1'),('markdown',1,'1'),('xmlrpcMarkdown',1,'1'),('defaultAllowComment',1,'1'),('defaultAllowPing',1,'1'),('defaultAllowFeed',1,'1'),('theme:material2',0,'a:40:{s:6:\"switch\";a:4:{i:0;s:12:\"SmoothScroll\";i:1;s:15:\"ShowLoadingLine\";i:2;s:4:\"PJAX\";i:3;s:5:\"Pangu\";}s:8:\"analysis\";N;s:12:\"loadingcolor\";N;s:13:\"loadingbuffer\";s:3:\"800\";s:6:\"BGtype\";s:1:\"1\";s:7:\"bgcolor\";N;s:12:\"GradientType\";s:1:\"0\";s:15:\"ThumbnailOption\";s:1:\"1\";s:10:\"TitleColor\";s:4:\"#FFF\";s:13:\"RandomPicAmnt\";s:2:\"19\";s:9:\"commentis\";s:1:\"0\";s:11:\"DSshortname\";N;s:6:\"CDNURL\";N;s:6:\"langis\";s:1:\"0\";s:8:\"sticky_1\";N;s:8:\"sticky_2\";N;s:10:\"ThemeColor\";s:7:\"#039BE5\";s:10:\"alinkcolor\";s:7:\"#039BE5\";s:16:\"ChromeThemeColor\";s:7:\"#039BE5\";s:9:\"avatarURL\";N;s:7:\"favicon\";N;s:8:\"dailypic\";N;s:4:\"logo\";N;s:12:\"dailypicLink\";s:1:\"#\";s:8:\"logoLink\";N;s:6:\"slogan\";s:16:\"Nice to meet you\";s:9:\"footersns\";a:3:{i:0;s:11:\"ShowTwitter\";i:1;s:12:\"ShowFacebook\";i:2;s:14:\"ShowGooglePlus\";}s:10:\"TwitterURL\";s:4:\"NULL\";s:11:\"FacebookURL\";s:4:\"NULL\";s:13:\"GooglePlusURL\";s:4:\"NULL\";s:8:\"WeiboURL\";N;s:12:\"InstagramURL\";N;s:9:\"GithubURL\";N;s:9:\"TumblrURL\";N;s:11:\"BilibiliURL\";N;s:11:\"TelegramURL\";N;s:8:\"ZhihuURL\";N;s:11:\"LinkedinURL\";N;s:11:\"CustomFonts\";s:124:\"Roboto, \'Helvetica Neue\', Helvetica, \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei\', \'微软雅黑\', Arial, sans-serif\";s:12:\"RobotoSource\";s:1:\"1\";}'),('plugin:RobotsPlus',0,'a:3:{s:7:\"botlist\";a:8:{i:0;s:5:\"baidu\";i:1;s:6:\"google\";i:2;s:5:\"sogou\";i:3;s:6:\"youdao\";i:4;s:4:\"soso\";i:5;s:4:\"bing\";i:6;s:5:\"yahoo\";i:7;s:3:\"360\";}s:9:\"pagecount\";s:2:\"20\";s:9:\"droptable\";s:1:\"1\";}'),('plugin:HelloWorld',0,'a:1:{s:4:\"word\";s:11:\"Hello World\";}'),('plugin:CodeHighlighter',0,'a:2:{s:10:\"code_style\";s:11:\"okaikia.css\";s:14:\"showLineNumber\";N;}'),('theme:Material',0,'a:58:{s:6:\"switch\";a:6:{i:0;s:9:\"ShowPixiv\";i:1;s:12:\"SmoothScroll\";i:2;s:15:\"ShowLoadingLine\";i:3;s:8:\"PanguPHP\";i:4;s:9:\"HighLight\";i:5;s:13:\"LazyloadIndex\";}s:9:\"commentis\";s:1:\"0\";s:11:\"CommentRows\";s:1:\"1\";s:15:\"DisqusShortname\";s:0:\"\";s:14:\"DisqusSiteName\";s:0:\"\";s:9:\"DisqusApi\";s:30:\"https://disqus.skk.moe/disqus/\";s:12:\"DisqusApiKey\";s:0:\"\";s:11:\"DisqusAdmin\";s:0:\"\";s:16:\"DisqusAdminLabel\";s:0:\"\";s:19:\"SwitchToDisqusSince\";s:1:\"0\";s:6:\"qrcode\";s:1:\"0\";s:8:\"searchis\";s:1:\"0\";s:7:\"CDNType\";s:1:\"0\";s:6:\"CDNURL\";s:0:\"\";s:8:\"language\";s:5:\"zh-CN\";s:9:\"footersns\";N;s:11:\"FacebookURL\";s:0:\"\";s:10:\"TwitterURL\";s:0:\"\";s:13:\"GooglePlusURL\";s:0:\"\";s:8:\"WeiboURL\";s:0:\"\";s:12:\"InstagramURL\";s:0:\"\";s:9:\"TumblrURL\";s:0:\"\";s:9:\"GithubURL\";s:0:\"\";s:11:\"LinkedinURL\";s:0:\"\";s:8:\"ZhihuURL\";s:0:\"\";s:11:\"BilibiliURL\";s:0:\"\";s:11:\"TelegramURL\";s:0:\"\";s:7:\"V2EXURL\";s:0:\"\";s:12:\"post_license\";s:105:\"This blog is under a <a href=\"/creativecommons.html\" target=\"_blank\">CC BY-NC-SA 3.0 Unported License</a>\";s:11:\"footer_text\";s:0:\"\";s:12:\"RobotoSource\";s:1:\"0\";s:8:\"analysis\";s:323:\"<!-- Global site tag (gtag.js) - Google Analytics -->\r\n<script async src=\"https://www.googletagmanager.com/gtag/js?id=UA-135362700-1\"></script>\r\n<script>\r\n  window.dataLayer = window.dataLayer || [];\r\n  function gtag(){dataLayer.push(arguments);}\r\n  gtag(\'js\', new Date());\r\n\r\n  gtag(\'config\', \'UA-135362700-1\');\r\n</script>\";s:7:\"adsense\";s:0:\"\";s:11:\"DNSPrefetch\";s:0:\"\";s:12:\"loadingcolor\";s:4:\"#29d\";s:13:\"loadingbuffer\";s:3:\"800\";s:11:\"SearchColor\";s:0:\"\";s:6:\"BGtype\";s:1:\"1\";s:7:\"bgcolor\";s:0:\"\";s:12:\"GradientType\";s:1:\"0\";s:15:\"ThumbnailOption\";s:1:\"3\";s:10:\"TitleColor\";s:4:\"#FFF\";s:13:\"RandomPicAmnt\";s:2:\"19\";s:10:\"ThemeColor\";s:7:\"#0097A7\";s:10:\"alinkcolor\";s:7:\"#00838F\";s:16:\"ChromeThemeColor\";s:7:\"#0097A7\";s:16:\"ButtonThemeColor\";s:7:\"#757575\";s:13:\"CardElevation\";s:1:\"2\";s:9:\"avatarURL\";s:28:\"http://i.imgur.com/xS97r.jpg\";s:7:\"favicon\";s:0:\"\";s:13:\"sidebarheader\";s:0:\"\";s:8:\"dailypic\";s:0:\"\";s:4:\"logo\";s:0:\"\";s:8:\"logosize\";s:1:\"0\";s:12:\"dailypicLink\";s:1:\"#\";s:8:\"logoLink\";s:1:\"#\";s:6:\"slogan\";s:20:\"Hi, nice to meet you\";s:11:\"CustomFonts\";s:124:\"Roboto, \'Helvetica Neue\', Helvetica, \'PingFang SC\', \'Hiragino Sans GB\', \'Microsoft YaHei\', \'微软雅黑\', Arial, sans-serif\";}');
/*!40000 ALTER TABLE `typecho_options` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_relationships`
--

DROP TABLE IF EXISTS `typecho_relationships`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_relationships` (
  `cid` int(10) unsigned NOT NULL,
  `mid` int(10) unsigned NOT NULL,
  PRIMARY KEY (`cid`,`mid`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_relationships`
--

LOCK TABLES `typecho_relationships` WRITE;
/*!40000 ALTER TABLE `typecho_relationships` DISABLE KEYS */;
INSERT INTO `typecho_relationships` VALUES (1,1),(3,8),(4,1),(6,1),(7,2),(7,3),(7,9),(8,2),(8,3),(8,9),(10,9),(14,8),(23,7),(24,7),(26,8),(27,8),(28,11),(29,11),(32,1),(33,1),(35,1),(38,1);
/*!40000 ALTER TABLE `typecho_relationships` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_robots_logs`
--

DROP TABLE IF EXISTS `typecho_robots_logs`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_robots_logs` (
  `lid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `bot` varchar(16) DEFAULT NULL,
  `url` varchar(64) DEFAULT NULL,
  `ip` varchar(16) DEFAULT NULL,
  `ltime` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`lid`)
) ENGINE=MyISAM AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_robots_logs`
--

LOCK TABLES `typecho_robots_logs` WRITE;
/*!40000 ALTER TABLE `typecho_robots_logs` DISABLE KEYS */;
INSERT INTO `typecho_robots_logs` VALUES (1,'google','/','66.102.6.53',1551367431),(2,'google','/','66.102.6.51',1551367432),(3,'google','/','66.102.6.51',1551548351),(4,'google','/','66.102.6.55',1551548352);
/*!40000 ALTER TABLE `typecho_robots_logs` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_users`
--

DROP TABLE IF EXISTS `typecho_users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_users` (
  `uid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(32) DEFAULT NULL,
  `password` varchar(64) DEFAULT NULL,
  `mail` varchar(200) DEFAULT NULL,
  `url` varchar(200) DEFAULT NULL,
  `screenName` varchar(32) DEFAULT NULL,
  `created` int(10) unsigned DEFAULT '0',
  `activated` int(10) unsigned DEFAULT '0',
  `logged` int(10) unsigned DEFAULT '0',
  `group` varchar(16) DEFAULT 'visitor',
  `authCode` varchar(64) DEFAULT NULL,
  PRIMARY KEY (`uid`),
  UNIQUE KEY `name` (`name`),
  UNIQUE KEY `mail` (`mail`)
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_users`
--

LOCK TABLES `typecho_users` WRITE;
/*!40000 ALTER TABLE `typecho_users` DISABLE KEYS */;
INSERT INTO `typecho_users` VALUES (1,'yimiao','$P$BYJJ430ciyYqUOovV27MPgZCPShZ/k1','yimiaoxiehou@gmail.com','http://yimiaoxiehou.github.io','yimiao',1545183095,1551410080,1551364869,'administrator','57801e77157364934db3e68ea482a4d4');
/*!40000 ALTER TABLE `typecho_users` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2019-03-21  1:30:30
